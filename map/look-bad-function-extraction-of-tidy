diff --git a/src/acl.erl b/src/acl.erl
index 180346e..5efdda2 100644
--- a/src/acl.erl
+++ b/src/acl.erl
@@ -295,13 +295,8 @@ load_from_config() ->
 					end,
 					ACLs),
 			  lists:foreach(fun ({Access, Rules}) ->
-						NRules = lists:map(fun ({ACL,
-									 Type}) ->
-									   {Type,
-									    [{acl,
-									      ACL}]}
-								   end,
-								   Rules),
+						NRules = [load_from_config_1(V1)
+							  || V1 <- Rules],
 						add_access(Host, Access,
 							   NRules ++
 							     [{deny, [all]}])
@@ -318,6 +313,8 @@ load_from_config() ->
 		  end,
 		  Hosts).
 
+load_from_config_1({ACL, Type}) -> {Type, [{acl, ACL}]}.
+
 - spec ( { { reload_from_config , 0 } , [ { type , 238 , 'fun' , [ { type , 238 , product , [ ] } , { atom , 238 , ok } ] } ] } ) .
 
 
@@ -649,8 +646,8 @@ parse_ip_netmask(S) ->
 
 transform_access_rules_config(Config)
     when is_list(Config) ->
-    lists:map(fun transform_access_rules_config2/1,
-	      lists:flatten(Config));
+    [transform_access_rules_config2(V1)
+     || V1 <- lists:flatten(Config)];
 transform_access_rules_config(Config) ->
     transform_access_rules_config([Config]).
 
@@ -662,15 +659,18 @@ transform_access_rules_config2({Type, ACL})
     {Type, [{acl, ACL}]};
 transform_access_rules_config2({Res, Rules})
     when is_list(Rules) ->
-    T = lists:map(fun ({Type, Args}) when is_list(Args) ->
-			  normalize_spec({Type, hd(lists:flatten(Args))});
-		      (V) -> normalize_spec(V)
-		  end,
-		  lists:flatten(Rules)),
+    T = [transform_access_rules_config2_1(V1)
+	 || V1 <- lists:flatten(Rules)],
     {Res, T};
 transform_access_rules_config2({Res, Rule}) ->
     {Res, [Rule]}.
 
+transform_access_rules_config2_1({Type, Args})
+    when is_list(Args) ->
+    normalize_spec({Type, hd(lists:flatten(Args))});
+transform_access_rules_config2_1(V) ->
+    normalize_spec(V).
+
 access_rules_validator(Name) when is_atom(Name) -> Name;
 access_rules_validator(Rules0) ->
     Rules = transform_access_rules_config(Rules0),
@@ -746,29 +746,20 @@ transform_options(Opts) ->
 		    [] -> [];
 		    L1 -> [{access, L1}]
 		  end,
-    ACLOpts2 = case lists:map(fun ({ACLName, Os}) ->
-				      {ACLName,
-				       ejabberd_config:collect_options(Os)}
-			      end,
-			      ACLOpts1)
+    ACLOpts2 = case [transform_options_1(V1)
+		     || V1 <- ACLOpts1]
 		   of
 		 [] -> [];
 		 L2 -> [{acl, L2}]
 	       end,
-    NewAccessOpts1 = case lists:map(fun ({NAName, Os}) ->
-					    {NAName,
-					     transform_access_rules_config(Os)}
-				    end,
-				    lists:flatten(NewAccessOpts))
+    NewAccessOpts1 = case [transform_options_2(V2)
+			   || V2 <- lists:flatten(NewAccessOpts)]
 			 of
 		       [] -> [];
 		       L3 -> [{access_rules, L3}]
 		     end,
-    ShaperOpts1 = case lists:map(fun ({SName, Ss}) ->
-					 {SName,
-					  transform_access_rules_config(Ss)}
-				 end,
-				 lists:flatten(ShaperOpts))
+    ShaperOpts1 = case [transform_options_3(V3)
+			|| V3 <- lists:flatten(ShaperOpts)]
 		      of
 		    [] -> [];
 		    L4 -> [{shaper_rules, L4}]
@@ -776,6 +767,15 @@ transform_options(Opts) ->
     ACLOpts2 ++
       AccessOpts1 ++ NewAccessOpts1 ++ ShaperOpts1 ++ Opts5.
 
+transform_options_1({ACLName, Os}) ->
+    {ACLName, ejabberd_config:collect_options(Os)}.
+
+transform_options_2({NAName, Os}) ->
+    {NAName, transform_access_rules_config(Os)}.
+
+transform_options_3({SName, Ss}) ->
+    {SName, transform_access_rules_config(Ss)}.
+
 transform_options({acl, Name, Type}, Opts) ->
     T = case Type of
 	  all -> all;
diff --git a/src/ejabberd_access_permissions.erl b/src/ejabberd_access_permissions.erl
index c04f309..eae59e0 100644
--- a/src/ejabberd_access_permissions.erl
+++ b/src/ejabberd_access_permissions.erl
@@ -263,14 +263,8 @@ get_definitions(#state{definitions = none,
 				Acc ++ Generator()
 			end,
 			[], Gens),
-    NDefs0 = lists:map(fun ({Name,
-			     {From, Who, {Add, Del}}}) ->
-			       Cmds =
-				   filter_commands_with_permissions(AllCommands,
-								    Add, Del),
-			       {Name, {From, Who, Cmds}}
-		       end,
-		       ApiPerms ++ Frags),
+    NDefs0 = [get_definitions_1(V1, AllCommands)
+	      || V1 <- ApiPerms ++ Frags],
     NDefs = case lists:keyfind(<<"console commands">>, 1,
 			       NDefs0)
 		of
@@ -284,6 +278,12 @@ get_definitions(#state{definitions = none,
 	    end,
     {State#state{definitions = NDefs}, NDefs}.
 
+get_definitions_1({Name, {From, Who, {Add, Del}}},
+		  AllCommands) ->
+    Cmds = filter_commands_with_permissions(AllCommands,
+					    Add, Del),
+    {Name, {From, Who, Cmds}}.
+
 matches_definition({_Name, {From, Who, What}}, Cmd,
 		   Module, Host, CallerInfo) ->
     case What == all orelse lists:member(Cmd, What) of
@@ -328,8 +328,12 @@ filter_commands_with_permissions(AllCommands, Add,
 						Add, []),
     CommandsDel = filter_commands_with_patterns(CommandsAdd,
 						Del, []),
-    lists:map(fun (#ejabberd_commands{name = N}) -> N end,
-	      CommandsAdd -- CommandsDel).
+    [filter_commands_with_permissions_1(V1)
+     || V1 <- CommandsAdd -- CommandsDel].
+
+filter_commands_with_permissions_1(#ejabberd_commands{name
+							  = N}) ->
+    N.
 
 filter_commands_with_patterns([], _Patterns, Acc) ->
     Acc;
@@ -401,85 +405,87 @@ parse_from(Name, Val) ->
 parse_who(Name, Atom, ParseOauth) when is_atom(Atom) ->
     parse_who(Name, [Atom], ParseOauth);
 parse_who(Name, Defs, ParseOauth) when is_list(Defs) ->
-    lists:map(fun ([Val]) ->
-		      [NVal] = parse_who(Name, [Val], ParseOauth), NVal;
-		  ({access, Val}) ->
-		      try acl:access_rules_validator(Val) of
-			Rule -> {access, Rule}
-		      catch
-			{invalid_syntax, Msg} ->
-			    report_error(<<"Invalid access rule: '~s' used inside "
-					   "'who' section for api_permission '~s'">>,
-					 [Msg, Name]);
-			error:_ ->
-			    report_error(<<"Invalid access rule '~p' used inside "
-					   "'who' section for api_permission '~s'">>,
-					 [Val, Name])
-		      end;
-		  ({oauth, OauthList}) when is_list(OauthList) ->
-		      case ParseOauth of
-			oauth ->
-			    Nested = parse_who(Name, lists:flatten(OauthList),
-					       scope),
-			    {Scopes, Rest} = lists:partition(fun ({scope, _}) ->
-								     true;
-								 (_) -> false
-							     end,
-							     Nested),
-			    case Scopes of
-			      [] ->
-				  report_error(<<"Oauth rule must contain at least one "
-						 "scope rule in 'who' section for api_permissio"
-						 "n '~s'">>,
-					       [Name]);
-			      _ ->
-				  {oauth,
-				   lists:foldl(fun ({scope, S}, A) -> S ++ A
-					       end,
-					       [], Scopes),
-				   Rest}
-			    end;
-			scope ->
-			    report_error(<<"Oauth rule can't be embedded inside "
-					   "other oauth rule in 'who' section for "
-					   "api_permission '~s'">>,
-					 [Name])
-		      end;
-		  ({scope, ScopeList}) ->
-		      case ParseOauth of
-			oauth ->
-			    report_error(<<"Scope can be included only inside oauth "
-					   "rule in 'who' section for api_permission "
-					   "'~s'">>,
-					 [Name]);
-			scope ->
-			    ScopeList2 = case ScopeList of
-					   V when is_binary(V) -> [V];
-					   V2 when is_list(V2) -> V2;
-					   V3 ->
-					       report_error(<<"Invalid value for scope '~p' in 'who' "
-							      "section for api_permission '~s'">>,
-							    [V3, Name])
-					 end,
-			    {scope, ScopeList2}
-		      end;
-		  (Atom) when is_atom(Atom) -> {acl, {acl, Atom}};
-		  (Other) ->
-		      try acl:normalize_spec(Other) of
-			Rule2 -> {acl, Rule2}
-		      catch
-			_:_ ->
-			    report_error(<<"Invalid value '~p' used inside 'who' "
-					   "section for api_permission '~s'">>,
-					 [Other, Name])
-		      end
-	      end,
-	      Defs);
+    [parse_who_1(V1, Name, ParseOauth) || V1 <- Defs];
 parse_who(Name, Val, _ParseOauth) ->
     report_error(<<"Invalid value '~p' used inside 'who' "
 		   "section for api_permission '~s'">>,
 		 [Val, Name]).
 
+parse_who_1([Val], Name, ParseOauth) ->
+    [NVal] = parse_who(Name, [Val], ParseOauth), NVal;
+parse_who_1({access, Val}, Name, ParseOauth) ->
+    try acl:access_rules_validator(Val) of
+      Rule -> {access, Rule}
+    catch
+      {invalid_syntax, Msg} ->
+	  report_error(<<"Invalid access rule: '~s' used inside "
+			 "'who' section for api_permission '~s'">>,
+		       [Msg, Name]);
+      error:_ ->
+	  report_error(<<"Invalid access rule '~p' used inside "
+			 "'who' section for api_permission '~s'">>,
+		       [Val, Name])
+    end;
+parse_who_1({oauth, OauthList}, Name, ParseOauth)
+    when is_list(OauthList) ->
+    case ParseOauth of
+      oauth ->
+	  Nested = parse_who(Name, lists:flatten(OauthList),
+			     scope),
+	  {Scopes, Rest} = lists:partition(fun ({scope, _}) ->
+						   true;
+					       (_) -> false
+					   end,
+					   Nested),
+	  case Scopes of
+	    [] ->
+		report_error(<<"Oauth rule must contain at least one "
+			       "scope rule in 'who' section for api_permissio"
+			       "n '~s'">>,
+			     [Name]);
+	    _ ->
+		{oauth,
+		 lists:foldl(fun ({scope, S}, A) -> S ++ A end, [],
+			     Scopes),
+		 Rest}
+	  end;
+      scope ->
+	  report_error(<<"Oauth rule can't be embedded inside "
+			 "other oauth rule in 'who' section for "
+			 "api_permission '~s'">>,
+		       [Name])
+    end;
+parse_who_1({scope, ScopeList}, Name, ParseOauth) ->
+    case ParseOauth of
+      oauth ->
+	  report_error(<<"Scope can be included only inside oauth "
+			 "rule in 'who' section for api_permission "
+			 "'~s'">>,
+		       [Name]);
+      scope ->
+	  ScopeList2 = case ScopeList of
+			 V when is_binary(V) -> [V];
+			 V2 when is_list(V2) -> V2;
+			 V3 ->
+			     report_error(<<"Invalid value for scope '~p' in 'who' "
+					    "section for api_permission '~s'">>,
+					  [V3, Name])
+		       end,
+	  {scope, ScopeList2}
+    end;
+parse_who_1(Atom, Name, ParseOauth)
+    when is_atom(Atom) ->
+    {acl, {acl, Atom}};
+parse_who_1(Other, Name, ParseOauth) ->
+    try acl:normalize_spec(Other) of
+      Rule2 -> {acl, Rule2}
+    catch
+      _:_ ->
+	  report_error(<<"Invalid value '~p' used inside 'who' "
+			 "section for api_permission '~s'">>,
+		       [Other, Name])
+    end.
+
 parse_what(Name, Binary) when is_binary(Binary) ->
     parse_what(Name, [Binary]);
 parse_what(Name, Defs) when is_list(Defs) ->
diff --git a/src/ejabberd_acme.erl b/src/ejabberd_acme.erl
index 39dd234..6b91e3b 100644
--- a/src/ejabberd_acme.erl
+++ b/src/ejabberd_acme.erl
@@ -1378,14 +1378,12 @@ generate_key() ->
 
 
 opt_type(acme) ->
-    fun (L) ->
-	    lists:map(fun ({ca_url, URL}) ->
-			      {ca_url, misc:try_url(URL)};
-			  ({contact, Contact}) ->
-			      [<<_, _/binary>>, <<_, _/binary>>] =
-				  binary:split(Contact, <<":">>),
-			      {contact, Contact}
-		      end,
-		      L)
-    end;
+    fun (L) -> [opt_type_1(V1) || V1 <- L] end;
 opt_type(_) -> [acme].
+
+opt_type_1({ca_url, URL}) ->
+    {ca_url, misc:try_url(URL)};
+opt_type_1({contact, Contact}) ->
+    [<<_, _/binary>>, <<_, _/binary>>] =
+	binary:split(Contact, <<":">>),
+    {contact, Contact}.
diff --git a/src/ejabberd_admin.erl b/src/ejabberd_admin.erl
index df6726e..a49cd42 100644
--- a/src/ejabberd_admin.erl
+++ b/src/ejabberd_admin.erl
@@ -593,7 +593,9 @@ unregister(User, Host) ->
 registered_users(Host) ->
     Users = ejabberd_auth:get_users(Host),
     SUsers = lists:sort(Users),
-    lists:map(fun ({U, _S}) -> U end, SUsers).
+    [registered_users_1(V1) || V1 <- SUsers].
+
+registered_users_1({U, _S}) -> U.
 
 registered_vhosts() -> ejabberd_config:get_myhosts().
 
@@ -724,8 +726,11 @@ keep_tables() ->
 %% Returns the list of modules tables in use, according to the list of actually
 %% loaded modules
 keep_modules_tables() ->
-    lists:map(fun (Module) -> module_tables(Module) end,
-	      gen_mod:loaded_modules(ejabberd_config:get_myname())).
+    [keep_modules_tables_1(V1)
+     || V1
+	    <- gen_mod:loaded_modules(ejabberd_config:get_myname())].
+
+keep_modules_tables_1(Module) -> module_tables(Module).
 
 %% TODO: This mapping should probably be moved to a callback function in each
 %% module.
@@ -745,16 +750,16 @@ module_tables(_Other) -> [].
 get_local_tables() ->
     Tabs1 = lists:delete(schema,
 			 mnesia:system_info(local_tables)),
-    Tabs = lists:filter(fun (T) ->
-				case mnesia:table_info(T, storage_type) of
-				  disc_copies -> true;
-				  disc_only_copies -> true;
-				  _ -> false
-				end
-			end,
-			Tabs1),
+    Tabs = [V1 || V1 <- Tabs1, get_local_tables_1(V1)],
     Tabs.
 
+get_local_tables_1(T) ->
+    case mnesia:table_info(T, storage_type) of
+      disc_copies -> true;
+      disc_only_copies -> true;
+      _ -> false
+    end.
+
 dump_mnesia(Path) ->
     Tabs = get_local_tables(), dump_tables(Path, Tabs).
 
@@ -780,12 +785,7 @@ dump_to_textfile(File, Tabs) ->
 		     file:open(File, [write])).
 
 dump_to_textfile(yes, Tabs, {ok, F}) ->
-    Defs = lists:map(fun (T) ->
-			     {T,
-			      [{record_name, mnesia:table_info(T, record_name)},
-			       {attributes, mnesia:table_info(T, attributes)}]}
-		     end,
-		     Tabs),
+    Defs = [dump_to_textfile_1(V1) || V1 <- Tabs],
     io:format(F, "~p.~n", [{tables, Defs}]),
     lists:foreach(fun (T) -> dump_tab(F, T) end, Tabs),
     file:close(F);
@@ -794,6 +794,11 @@ dump_to_textfile(_, _, {ok, F}) ->
 dump_to_textfile(_, _, {error, Reason}) ->
     {error, Reason}.
 
+dump_to_textfile_1(T) ->
+    {T,
+     [{record_name, mnesia:table_info(T, record_name)},
+      {attributes, mnesia:table_info(T, attributes)}]}.
+
 dump_tab(F, T) ->
     W = mnesia:table_info(T, wild_pattern),
     {atomic, All} = mnesia:transaction(fun () ->
diff --git a/src/ejabberd_auth.erl b/src/ejabberd_auth.erl
index 826679f..5b404f8 100644
--- a/src/ejabberd_auth.erl
+++ b/src/ejabberd_auth.erl
@@ -385,12 +385,13 @@ count_users(Server, Opts) ->
     case jid:nameprep(Server) of
       error -> 0;
       LServer ->
-	  lists:sum(lists:map(fun (M) ->
-				      db_count_users(LServer, Opts, M)
-			      end,
-			      auth_modules(LServer)))
+	  lists:sum([count_users_1(V1, LServer, Opts)
+		     || V1 <- auth_modules(LServer)])
     end.
 
+count_users_1(M, LServer, Opts) ->
+    db_count_users(LServer, Opts, M).
+
 - spec ( { { get_password , 2 } , [ { type , 335 , 'fun' , [ { type , 335 , product , [ { type , 335 , binary , [ ] } , { type , 335 , binary , [ ] } ] } , { type , 335 , union , [ { atom , 335 , false } , { type , 335 , password , [ ] } ] } ] } ] } ) .
 
 
@@ -936,10 +937,7 @@ import(_LServer, {sql, _}, sql, <<"users">>, _) -> ok.
 
 
 opt_type(auth_method) ->
-    fun (V) when is_list(V) ->
-	    lists:map(fun (M) -> ejabberd_config:v_db(?MODULE, M)
-		      end,
-		      V);
+    fun (V) when is_list(V) -> [opt_type_1(V1) || V1 <- V];
 	(V) -> [ejabberd_config:v_db(?MODULE, V)]
     end;
 opt_type(auth_password_format) ->
@@ -964,3 +962,5 @@ opt_type(_) ->
     [auth_method, auth_password_format, auth_use_cache,
      auth_cache_missed, auth_cache_life_time,
      auth_cache_size].
+
+opt_type_1(M) -> ejabberd_config:v_db(?MODULE, M).
diff --git a/src/ejabberd_bosh.erl b/src/ejabberd_bosh.erl
index bc9c7e2..b15ce07 100644
--- a/src/ejabberd_bosh.erl
+++ b/src/ejabberd_bosh.erl
@@ -693,12 +693,9 @@ do_reply(State, From, Body, RID) ->
 
 bounce_receivers(State, _Reason) ->
     Receivers = gb_trees:to_list(State#state.receivers),
-    ShapedReceivers = lists:map(fun ({_, From,
-				      #body{attrs = Attrs} = Body}) ->
-					RID = get_attr(rid, Attrs),
-					{RID, {From, Body}}
-				end,
-				p1_queue:to_list(State#state.shaped_receivers)),
+    ShapedReceivers = [bounce_receivers_1(V1)
+		       || V1
+			      <- p1_queue:to_list(State#state.shaped_receivers)],
     lists:foldl(fun ({RID, {From, _Body}}, AccState) ->
 			NewBody = #body{http_reason = <<"Session closed">>,
 					attrs =
@@ -708,6 +705,10 @@ bounce_receivers(State, _Reason) ->
 		end,
 		State, Receivers ++ ShapedReceivers).
 
+bounce_receivers_1({_, From,
+		    #body{attrs = Attrs} = Body}) ->
+    RID = get_attr(rid, Attrs), {RID, {From, Body}}.
+
 bounce_els_from_obuf(State) ->
     Opts = ejabberd_config:codec_options(State#state.host),
     p1_queue:foreach(fun ({xmlstreamelement, El}) ->
@@ -755,18 +756,7 @@ maybe_add_xmlstreamend(Els, <<"terminate">>) ->
 maybe_add_xmlstreamend(Els, _) -> Els.
 
 encode_body(#body{attrs = Attrs, els = Els}, Type) ->
-    Attrs1 = lists:map(fun ({K, V}) when is_atom(K) ->
-			       AmK = iolist_to_binary(atom_to_list(K)),
-			       case V of
-				 true -> {AmK, <<"true">>};
-				 false -> {AmK, <<"false">>};
-				 I when is_integer(I), I >= 0 ->
-				     {AmK, integer_to_binary(I)};
-				 _ -> {AmK, V}
-			       end;
-			   ({K, V}) -> {K, V}
-		       end,
-		       Attrs),
+    Attrs1 = [encode_body_1(V1) || V1 <- Attrs],
     Attrs2 = [{<<"xmlns">>, ?NS_HTTP_BIND} | Attrs1],
     {Attrs3, XMLs} = lists:foldr(fun ({xmlstreamraw, XML},
 				      {AttrsAcc, XMLBuf}) ->
@@ -857,6 +847,17 @@ encode_body(#body{attrs = Attrs, els = Els}, Type) ->
 	   <<"</body>">>]
     end.
 
+encode_body_1({K, V}) when is_atom(K) ->
+    AmK = iolist_to_binary(atom_to_list(K)),
+    case V of
+      true -> {AmK, <<"true">>};
+      false -> {AmK, <<"false">>};
+      I when is_integer(I), I >= 0 ->
+	  {AmK, integer_to_binary(I)};
+      _ -> {AmK, V}
+    end;
+encode_body_1({K, V}) -> {K, V}.
+
 encode_element(El, xml) -> fxml:element_to_binary(El);
 encode_element(El, json) -> El.
 
diff --git a/src/ejabberd_c2s.erl b/src/ejabberd_c2s.erl
index 46fddfe..b282501 100644
--- a/src/ejabberd_c2s.erl
+++ b/src/ejabberd_c2s.erl
@@ -554,8 +554,7 @@ opt_type(resource_conflict) ->
 	(acceptnew) -> acceptnew
     end;
 opt_type(disable_sasl_mechanisms) ->
-    fun (V) when is_list(V) ->
-	    lists:map(fun (M) -> str:to_upper(M) end, V);
+    fun (V) when is_list(V) -> [opt_type_1(V1) || V1 <- V];
 	(V) -> [str:to_upper(V)]
     end;
 opt_type(_) ->
@@ -563,6 +562,8 @@ opt_type(_) ->
      c2s_protocol_options, c2s_tls_compression,
      resource_conflict, disable_sasl_mechanisms].
 
+opt_type_1(M) -> str:to_upper(M).
+
 listen_opt_type(certfile = Opt) ->
     fun (S) ->
 	    ?WARNING_MSG("Listening option '~s' for ~s is deprecated, "
diff --git a/src/ejabberd_captcha.erl b/src/ejabberd_captcha.erl
index 62b9017..68b6613 100644
--- a/src/ejabberd_captcha.erl
+++ b/src/ejabberd_captcha.erl
@@ -474,11 +474,14 @@ get_transfer_protocol(PortString) ->
 
 get_port_listeners(PortNumber) ->
     AllListeners = ejabberd_config:get_option(listen, []),
-    lists:filter(fun ({{Port, _IP, _Transport}, _Module,
-		       _Opts}) ->
-			 Port == PortNumber
-		 end,
-		 AllListeners).
+    [V1
+     || V1 <- AllListeners,
+	get_port_listeners_1(V1, PortNumber)].
+
+get_port_listeners_1({{Port, _IP, _Transport}, _Module,
+		      _Opts},
+		     PortNumber) ->
+    Port == PortNumber.
 
 get_captcha_transfer_protocol([]) ->
     throw(<<"The port number mentioned in captcha_host "
diff --git a/src/ejabberd_commands.erl b/src/ejabberd_commands.erl
index ddbb881..de35a30 100644
--- a/src/ejabberd_commands.erl
+++ b/src/ejabberd_commands.erl
@@ -362,12 +362,7 @@ unregister_commands(Commands) ->
 
 
 expose_commands(Commands) ->
-    Names = lists:map(fun (#ejabberd_commands{name =
-						  Name}) ->
-			      Name;
-			  (Name) when is_atom(Name) -> Name
-		      end,
-		      Commands),
+    Names = [expose_commands_1(V1) || V1 <- Commands],
     case ejabberd_config:add_option(commands,
 				    [{add_commands, Names}])
 	of
@@ -376,6 +371,10 @@ expose_commands(Commands) ->
       {atomic, Result} -> Result
     end.
 
+expose_commands_1(#ejabberd_commands{name = Name}) ->
+    Name;
+expose_commands_1(Name) when is_atom(Name) -> Name.
+
 - spec ( { { list_commands , 0 } , [ { type , 365 , 'fun' , [ { type , 365 , product , [ ] } , { type , 365 , list , [ { type , 365 , tuple , [ { type , 365 , atom , [ ] } , { type , 365 , list , [ { type , 365 , aterm , [ ] } ] } , { type , 365 , string , [ ] } ] } ] } ] } ] } ) .
 
 
@@ -586,10 +585,7 @@ get_exposed_commands() ->
 
 get_exposed_commands(Version) ->
     Opts0 = ejabberd_config:get_option(commands, []),
-    Opts = lists:map(fun (V) when is_tuple(V) -> [V];
-			 (V) -> V
-		     end,
-		     Opts0),
+    Opts = [get_exposed_commands_1(V1) || V1 <- Opts0],
     CommandsList = list_commands_policy(Version),
     OpenCmds = [N || {N, _, _, open} <- CommandsList],
     RestrictedCmds = [N
@@ -611,6 +607,9 @@ get_exposed_commands(Version) ->
 		       [], Opts),
     Cmds.
 
+get_exposed_commands_1(V) when is_tuple(V) -> [V];
+get_exposed_commands_1(V) -> V.
+
 %% This is used to allow mixing command policy (like open, user, admin, restricted), with command entry
 expand_commands(L, OpenCmds, UserCmds, AdminCmds,
 		RestrictedCmds)
diff --git a/src/ejabberd_commands_doc.erl b/src/ejabberd_commands_doc.erl
index 37f4154..3684c2f 100644
--- a/src/ejabberd_commands_doc.erl
+++ b/src/ejabberd_commands_doc.erl
@@ -114,23 +114,24 @@ perl_gen({Name, atom}, Atom, _Indent, HTMLOutput) ->
     [?ARG(Name), ?OP_L(" => "), ?STR_A(Atom)];
 perl_gen({Name, {tuple, Fields}}, Tuple, Indent,
 	 HTMLOutput) ->
-    Res = lists:map(fun ({A, B}) ->
-			    perl_gen(A, B, Indent, HTMLOutput)
-		    end,
-		    lists:zip(Fields, tuple_to_list(Tuple))),
+    Res = [perl_gen_1(V1, HTMLOutput, Indent)
+	   || V1 <- lists:zip(Fields, tuple_to_list(Tuple))],
     [?ARG(Name), ?OP_L(" => {"),
      list_join_with(Res, [?OP_L(", ")]), ?OP_L("}")];
 perl_gen({Name, {list, ElDesc}}, List, Indent,
 	 HTMLOutput) ->
-    Res = lists:map(fun (E) ->
-			    [?OP_L("{"),
-			     perl_gen(ElDesc, E, Indent, HTMLOutput),
-			     ?OP_L("}")]
-		    end,
-		    List),
+    Res = [perl_gen_1(V2, ElDesc, HTMLOutput, Indent)
+	   || V2 <- List],
     [?ARG(Name), ?OP_L(" => ["),
      list_join_with(Res, [?OP_L(", ")]), ?OP_L("]")].
 
+perl_gen_1({A, B}, HTMLOutput, Indent) ->
+    perl_gen(A, B, Indent, HTMLOutput).
+
+perl_gen_1(E, ElDesc, HTMLOutput, Indent) ->
+    [?OP_L("{"), perl_gen(ElDesc, E, Indent, HTMLOutput),
+     ?OP_L("}")].
+
 perl_call(Name, ArgsDesc, Values, HTMLOutput) ->
     {Indent, Preamble} = if HTMLOutput -> {<<"">>, []};
 			    true -> {<<"    ">>, <<"~~~ perl\n">>}
@@ -139,15 +140,15 @@ perl_call(Name, ArgsDesc, Values, HTMLOutput) ->
      ?ID_L("proxy"), ?OP_L("("), ?ID_L("$url"), ?OP_L(")->"),
      ?ID_L("call"), ?OP_L("("), ?STR_A(Name), ?OP_L(", {"),
      ?BR, Indent, <<"  ">>,
-     list_join_with(lists:map(fun ({A, B}) ->
-				      perl_gen(A, B, <<Indent/binary, "  ">>,
-					       HTMLOutput)
-			      end,
-			      lists:zip(ArgsDesc, Values)),
+     list_join_with([perl_call_1(V1, HTMLOutput, Indent)
+		     || V1 <- lists:zip(ArgsDesc, Values)],
 		    [?OP_L(","), ?BR, Indent, <<"  ">>]),
      ?BR, Indent, ?OP_L("})->"), ?ID_L("results"),
      ?OP_L("()")].
 
+perl_call_1({A, B}, HTMLOutput, Indent) ->
+    perl_gen(A, B, <<Indent/binary, "  ">>, HTMLOutput).
+
 java_gen_map(Vals, Indent, HTMLOutput) ->
     {Split, NL} = case Indent of
 		    none -> {<<" ">>, <<" ">>};
@@ -174,10 +175,8 @@ java_gen({Name, atom}, Atom, _Indent, HTMLOutput) ->
 java_gen({Name, {tuple, Fields}}, Tuple, Indent,
 	 HTMLOutput) ->
     NewIndent = <<"  ", Indent/binary>>,
-    Res = lists:map(fun ({A, B}) ->
-			    [java_gen(A, B, NewIndent, HTMLOutput)]
-		    end,
-		    lists:zip(Fields, tuple_to_list(Tuple))),
+    Res = [java_gen_1(V1, HTMLOutput, NewIndent)
+	   || V1 <- lists:zip(Fields, tuple_to_list(Tuple))],
     [?ID_L("put"), ?OP_L("("), ?STR_A(Name), ?OP_L(", "),
      java_gen_map(Res, Indent, HTMLOutput), ?OP_L(")")];
 java_gen({Name, {list, ElDesc}}, List, Indent,
@@ -189,16 +188,20 @@ java_gen({Name, {list, ElDesc}}, List, Indent,
 			  [?BR, <<"  ", Indent/binary>>],
 			  <<"      ", Indent/binary>>}
 		   end,
-    Res = lists:map(fun (E) ->
-			    java_gen_map([java_gen(ElDesc, E, I, HTMLOutput)],
-					 none, HTMLOutput)
-		    end,
-		    List),
+    Res = [java_gen_1(V2, ElDesc, HTMLOutput, I)
+	   || V2 <- List],
     [?ID_L("put"), ?OP_L("("), ?STR_A(Name), ?OP_L(", "),
      ?KW_L("new "), ?ID_L("Object"), ?OP_L("[] {"), NI,
      list_join_with(Res, [?OP_L(","), NI]), NI2,
      ?OP_L("});")].
 
+java_gen_1({A, B}, HTMLOutput, NewIndent) ->
+    [java_gen(A, B, NewIndent, HTMLOutput)].
+
+java_gen_1(E, ElDesc, HTMLOutput, I) ->
+    java_gen_map([java_gen(ElDesc, E, I, HTMLOutput)], none,
+		 HTMLOutput).
+
 java_call(Name, ArgsDesc, Values, HTMLOutput) ->
     {Indent, Preamble} = if HTMLOutput -> {<<"">>, []};
 			    true -> {<<"    ">>, <<"~~~ java\n">>}
@@ -215,13 +218,14 @@ java_call(Name, ArgsDesc, Values, HTMLOutput) ->
      ?OP_L("("), ?ID_L("config"), ?OP_L(");"), ?BR, Indent,
      ?BR, Indent, ?ID_L("client"), ?OP_L("."),
      ?ID_L("execute"), ?OP_L("("), ?STR_A(Name), ?OP_L(", "),
-     java_gen_map(lists:map(fun ({A, B}) ->
-				    java_gen(A, B, Indent, HTMLOutput)
-			    end,
-			    lists:zip(ArgsDesc, Values)),
+     java_gen_map([java_call_1(V1, HTMLOutput, Indent)
+		   || V1 <- lists:zip(ArgsDesc, Values)],
 		  Indent, HTMLOutput),
      ?OP_L(");")].
 
+java_call_1({A, B}, HTMLOutput, Indent) ->
+    java_gen(A, B, Indent, HTMLOutput).
+
 - define ( XML_S ( N , V ) , ? OP_L ( "<" ) , ? FIELD_L ( ? ? N ) , ? OP_L ( ">" ) , V ) .
 
 
@@ -265,10 +269,8 @@ xml_gen({Name, atom}, Atom, Indent, HTMLOutput) ->
 xml_gen({Name, {tuple, Fields}}, Tuple, Indent,
 	HTMLOutput) ->
     NewIndent = <<"    ", Indent/binary>>,
-    Res = lists:map(fun ({A, B}) ->
-			    xml_gen(A, B, NewIndent, HTMLOutput)
-		    end,
-		    lists:zip(Fields, tuple_to_list(Tuple))),
+    Res = [xml_gen_1(V1, HTMLOutput, NewIndent)
+	   || V1 <- lists:zip(Fields, tuple_to_list(Tuple))],
     [?XML(member, Indent,
 	  [?XML_L(name, Indent, 1, (?ID_A(Name))),
 	   ?XML(value, Indent, 1,
@@ -277,28 +279,28 @@ xml_gen({Name, {list, ElDesc}}, List, Indent,
 	HTMLOutput) ->
     Ind1 = <<"        ", Indent/binary>>,
     Ind2 = <<"    ", Ind1/binary>>,
-    Res = lists:map(fun (E) ->
-			    [?XML(value, Ind1,
-				  [?XML(struct, Ind1, 1,
-					(xml_gen(ElDesc, E, Ind2,
-						 HTMLOutput)))])]
-		    end,
-		    List),
+    Res = [xml_gen_1(V2, ElDesc, HTMLOutput, Ind1, Ind2)
+	   || V2 <- List],
     [?XML(member, Indent,
 	  [?XML_L(name, Indent, 1, (?ID_A(Name))),
 	   ?XML(value, Indent, 1,
 		[?XML(array, Indent, 2,
 		      [?XML(data, Indent, 3, Res)])])])].
 
+xml_gen_1({A, B}, HTMLOutput, NewIndent) ->
+    xml_gen(A, B, NewIndent, HTMLOutput).
+
+xml_gen_1(E, ElDesc, HTMLOutput, Ind1, Ind2) ->
+    [?XML(value, Ind1,
+	  [?XML(struct, Ind1, 1,
+		(xml_gen(ElDesc, E, Ind2, HTMLOutput)))])].
+
 xml_call(Name, ArgsDesc, Values, HTMLOutput) ->
     {Indent, Preamble} = if HTMLOutput -> {<<"">>, []};
 			    true -> {<<"    ">>, <<"~~~ xml">>}
 			 end,
-    Res = lists:map(fun ({A, B}) ->
-			    xml_gen(A, B, <<Indent/binary, "          ">>,
-				    HTMLOutput)
-		    end,
-		    lists:zip(ArgsDesc, Values)),
+    Res = [xml_call_1(V1, HTMLOutput, Indent)
+	   || V1 <- lists:zip(ArgsDesc, Values)],
     [Preamble,
      ?XML(methodCall, Indent,
 	  [?XML_L(methodName, Indent, 1, (?ID_A(Name))),
@@ -307,6 +309,10 @@ xml_call(Name, ArgsDesc, Values, HTMLOutput) ->
 		      [?XML(value, Indent, 3,
 			    [?XML(struct, Indent, 4, Res)])])])])].
 
+xml_call_1({A, B}, HTMLOutput, Indent) ->
+    xml_gen(A, B, <<Indent/binary, "          ">>,
+	    HTMLOutput).
+
 %    [?ARG_S(Name), ?OP_L(": "), ?STR(Str)];
 json_gen({_Name, integer}, Int, _Indent, HTMLOutput) ->
     [?NUM(Int)];
@@ -327,36 +333,39 @@ json_gen({_Name,
 	  {list, {_, {tuple, [{_, atom}, ValFmt]}}}},
 	 List, Indent, HTMLOutput) ->
     Indent2 = <<"  ", Indent/binary>>,
-    Res = lists:map(fun ({N, V}) ->
-			    [?STR_A(N), ?OP_L(": "),
-			     json_gen(ValFmt, V, Indent2, HTMLOutput)]
-		    end,
-		    List),
+    Res = [json_gen_1(V1, HTMLOutput, Indent2, ValFmt)
+	   || V1 <- List],
     [?OP_L("{"), ?BR, Indent2,
      list_join_with(Res, [?OP_L(","), ?BR, Indent2]), ?BR,
      Indent, ?OP_L("}")];
 json_gen({_Name, {tuple, Fields}}, Tuple, Indent,
 	 HTMLOutput) ->
     Indent2 = <<"  ", Indent/binary>>,
-    Res = lists:map(fun ({{N, _} = A, B}) ->
-			    [?STR_A(N), ?OP_L(": "),
-			     json_gen(A, B, Indent2, HTMLOutput)]
-		    end,
-		    lists:zip(Fields, tuple_to_list(Tuple))),
+    Res = [json_gen_1(V2, HTMLOutput, Indent2)
+	   || V2 <- lists:zip(Fields, tuple_to_list(Tuple))],
     [?OP_L("{"), ?BR, Indent2,
      list_join_with(Res, [?OP_L(","), ?BR, Indent2]), ?BR,
      Indent, ?OP_L("}")];
 json_gen({_Name, {list, ElDesc}}, List, Indent,
 	 HTMLOutput) ->
     Indent2 = <<"  ", Indent/binary>>,
-    Res = lists:map(fun (E) ->
-			    json_gen(ElDesc, E, Indent2, HTMLOutput)
-		    end,
-		    List),
+    Res = [json_gen_2(V3, ElDesc, HTMLOutput, Indent2)
+	   || V3 <- List],
     [?OP_L("["), ?BR, Indent2,
      list_join_with(Res, [?OP_L(","), ?BR, Indent2]), ?BR,
      Indent, ?OP_L("]")].
 
+json_gen_1({N, V}, HTMLOutput, Indent2, ValFmt) ->
+    [?STR_A(N), ?OP_L(": "),
+     json_gen(ValFmt, V, Indent2, HTMLOutput)].
+
+json_gen_1({{N, _} = A, B}, HTMLOutput, Indent2) ->
+    [?STR_A(N), ?OP_L(": "),
+     json_gen(A, B, Indent2, HTMLOutput)].
+
+json_gen_2(E, ElDesc, HTMLOutput, Indent2) ->
+    json_gen(ElDesc, E, Indent2, HTMLOutput).
+
 json_call(Name, ArgsDesc, Values, ResultDesc, Result,
 	  HTMLOutput) ->
     {Indent, Preamble} = if HTMLOutput -> {<<"">>, []};
@@ -391,17 +400,17 @@ json_call(Name, ArgsDesc, Values, ResultDesc, Result,
 	      end,
     [Preamble, Indent, ?ID_L("POST /api/"), ?ID_A(Name),
      ?BR, Indent, ?OP_L("{"), ?BR, Indent, <<"  ">>,
-     list_join_with(lists:map(fun ({{N, _} = A, B}) ->
-				      [?STR_A(N), ?OP_L(": "),
-				       json_gen(A, B, <<Indent/binary, "  ">>,
-						HTMLOutput)]
-			      end,
-			      lists:zip(ArgsDesc, Values)),
+     list_join_with([json_call_1(V2, HTMLOutput, Indent)
+		     || V2 <- lists:zip(ArgsDesc, Values)],
 		    [?OP_L(","), ?BR, Indent, <<"  ">>]),
      ?BR, Indent, ?OP_L("}"), ?BR, Indent, ?BR, Indent,
      ?ID_L("HTTP/1.1"), ?ID(CodeStr), ?BR, Indent,
      ResultStr].
 
+json_call_1({{N, _} = A, B}, HTMLOutput, Indent) ->
+    [?STR_A(N), ?OP_L(": "),
+     json_gen(A, B, <<Indent/binary, "  ">>, HTMLOutput)].
+
 generate_example_input({_Name, integer},
 		       {LastStr, LastNum}) ->
     {LastNum + 1, {LastStr, LastNum + 1}};
@@ -641,10 +650,8 @@ gen_doc(#ejabberd_commands{name = Name, tags = _Tags,
 find_commands_definitions() ->
     case code:lib_dir(ejabberd, ebin) of
       {error, _} ->
-	  lists:map(fun ({N, _, _}) ->
-			    ejabberd_commands:get_command_definition(N)
-		    end,
-		    ejabberd_commands:list_commands());
+	  [find_commands_definitions_1(V1)
+	   || V1 <- ejabberd_commands:list_commands()];
       Path ->
 	  lists:flatmap(fun (P) ->
 				Mod = list_to_atom(filename:rootname(P)),
@@ -660,21 +667,14 @@ find_commands_definitions() ->
 			filelib:wildcard("*.beam", Path))
     end.
 
+find_commands_definitions_1({N, _, _}) ->
+    ejabberd_commands:get_command_definition(N).
+
 generate_html_output(File, RegExp, Languages) ->
     Cmds = find_commands_definitions(),
     {ok, RE} = re:compile(RegExp),
-    Cmds2 = lists:filter(fun (#ejabberd_commands{name =
-						     Name,
-						 module = Module}) ->
-				 re:run(atom_to_list(Name), RE,
-					[{capture, none}])
-				   == match
-				   orelse
-				   re:run(atom_to_list(Module), RE,
-					  [{capture, none}])
-				     == match
-			 end,
-			 Cmds),
+    Cmds2 = [V1
+	     || V1 <- Cmds, generate_html_output_1(V1, RE)],
     Cmds3 = lists:sort(fun (#ejabberd_commands{name = N1},
 			    #ejabberd_commands{name = N2}) ->
 			       N1 =< N2
@@ -683,13 +683,25 @@ generate_html_output(File, RegExp, Languages) ->
     Cmds4 = [maybe_add_policy_arguments(Cmd)
 	     || Cmd <- Cmds3],
     Langs = binary:split(Languages, <<",">>, [global]),
-    Out = lists:map(fun (C) -> gen_doc(C, true, Langs) end,
-		    Cmds4),
+    Out = [generate_html_output_2(V2, Langs)
+	   || V2 <- Cmds4],
     {ok, Fh} = file:open(File, [write]),
     io:format(Fh, "~s", [[html_pre(), Out, html_post()]]),
     file:close(Fh),
     ok.
 
+generate_html_output_1(#ejabberd_commands{name = Name,
+					  module = Module},
+		       RE) ->
+    re:run(atom_to_list(Name), RE, [{capture, none}]) ==
+      match
+      orelse
+      re:run(atom_to_list(Module), RE, [{capture, none}]) ==
+	match.
+
+generate_html_output_2(C, Langs) ->
+    gen_doc(C, true, Langs).
+
 maybe_add_policy_arguments(#ejabberd_commands{args =
 						  Args1,
 					      policy = user} =
@@ -701,18 +713,8 @@ maybe_add_policy_arguments(Cmd) -> Cmd.
 generate_md_output(File, RegExp, Languages) ->
     Cmds = find_commands_definitions(),
     {ok, RE} = re:compile(RegExp),
-    Cmds2 = lists:filter(fun (#ejabberd_commands{name =
-						     Name,
-						 module = Module}) ->
-				 re:run(atom_to_list(Name), RE,
-					[{capture, none}])
-				   == match
-				   orelse
-				   re:run(atom_to_list(Module), RE,
-					  [{capture, none}])
-				     == match
-			 end,
-			 Cmds),
+    Cmds2 = [V1
+	     || V1 <- Cmds, generate_md_output_1(V1, RE)],
     Cmds3 = lists:sort(fun (#ejabberd_commands{name = N1},
 			    #ejabberd_commands{name = N2}) ->
 			       N1 =< N2
@@ -726,13 +728,24 @@ generate_md_output(File, RegExp, Languages) ->
 	  ": true\nmenu: Administration API\norder: "
 	  "40\n// Autogenerated with 'ejabberdctl "
 	  "gen_markdown_doc_for_commands'\n---">>,
-    Out = lists:map(fun (C) -> gen_doc(C, false, Langs) end,
-		    Cmds4),
+    Out = [generate_md_output_2(V2, Langs) || V2 <- Cmds4],
     {ok, Fh} = file:open(File, [write]),
     io:format(Fh, "~s~s", [Header, Out]),
     file:close(Fh),
     ok.
 
+generate_md_output_1(#ejabberd_commands{name = Name,
+					module = Module},
+		     RE) ->
+    re:run(atom_to_list(Name), RE, [{capture, none}]) ==
+      match
+      orelse
+      re:run(atom_to_list(Module), RE, [{capture, none}]) ==
+	match.
+
+generate_md_output_2(C, Langs) ->
+    gen_doc(C, false, Langs).
+
 html_pre() ->
     "<!DOCTYPE>\n<html>\n  <head>\n    <meta "
     "http-equiv='content-type' content='text/html; "
diff --git a/src/ejabberd_config.erl b/src/ejabberd_config.erl
index 60f2da5..9958b03 100644
--- a/src/ejabberd_config.erl
+++ b/src/ejabberd_config.erl
@@ -262,16 +262,16 @@ convert_to_yaml(File, Output) ->
 		   <- State#state.opts],
     {GOpts, HOpts} = split_by_hosts(Opts),
     NewOpts = GOpts ++
-		lists:map(fun ({Host, Opts1}) ->
-				  {host_config, [{Host, Opts1}]}
-			  end,
-			  HOpts),
+		[convert_to_yaml_1(V1) || V1 <- HOpts],
     Data = fast_yaml:encode(lists:reverse(NewOpts)),
     case Output of
       stdout -> io:format("~s~n", [Data]);
       FileName -> file:write_file(FileName, Data)
     end.
 
+convert_to_yaml_1({Host, Opts1}) ->
+    {host_config, [{Host, Opts1}]}.
+
 %% Some Erlang apps expects env parameters to be list and not binary.
 %% For example, Mnesia is not able to start if mnesia dir is passed as a binary.
 %% However, binary is most common on Elixir, so it is easy to make a setup mistake.
@@ -418,15 +418,16 @@ search_hosts(Term, State) ->
 
 set_hosts_in_options(Hosts, State) ->
     PrepHosts = normalize_hosts(Hosts),
-    NewOpts = lists:filter(fun ({local_config,
-				 {hosts, global}, _}) ->
-				   false;
-			       (_) -> true
-			   end,
-			   State#state.opts),
+    NewOpts = [V1
+	       || V1 <- State#state.opts, set_hosts_in_options_1(V1)],
     set_option({hosts, global}, PrepHosts,
 	       State#state{hosts = PrepHosts, opts = NewOpts}).
 
+set_hosts_in_options_1({local_config, {hosts, global},
+			_}) ->
+    false;
+set_hosts_in_options_1(_) -> true.
+
 normalize_hosts(Hosts) -> normalize_hosts(Hosts, []).
 
 normalize_hosts([], PrepHosts) ->
@@ -751,15 +752,15 @@ change_val(auth_method, Val) ->
 			    L = if is_list(V) -> V;
 				   true -> [V]
 				end,
-			    lists:map(fun (odbc) -> sql;
-					  (internal) -> mnesia;
-					  (A) when is_atom(A) -> A
-				      end,
-				      L)
+			    [change_val_1(V1) || V1 <- L]
 		    end,
 		    [mnesia]);
 change_val(_Opt, Val) -> Val.
 
+change_val_1(odbc) -> sql;
+change_val_1(internal) -> mnesia;
+change_val_1(A) when is_atom(A) -> A.
+
 set_option(Opt, Val, State) ->
     State#state{opts =
 		    [#local_config{key = Opt, value = Val}
@@ -784,13 +785,13 @@ append_option({Opt, Host}, Val, State) ->
 set_opts(State) ->
     Opts = State#state.opts,
     ets:insert(ejabberd_options,
-	       lists:map(fun (#local_config{key = Key, value = Val}) ->
-				 {Key, Val}
-			 end,
-			 Opts)),
+	       [set_opts_1(V1) || V1 <- Opts]),
     set_fqdn(),
     set_log_level().
 
+set_opts_1(#local_config{key = Key, value = Val}) ->
+    {Key, Val}.
+
 set_fqdn() ->
     FQDNs = case get_option(fqdn, []) of
 	      [] ->
@@ -982,12 +983,12 @@ v_dbs(Mod) ->
 
 
 v_dbs_mods(Mod) ->
-    lists:map(fun (M) ->
-		      binary_to_atom(<<(atom_to_binary(Mod, utf8))/binary,
-				       "_", (atom_to_binary(M, utf8))/binary>>,
-				     utf8)
-	      end,
-	      v_dbs(Mod)).
+    [v_dbs_mods_1(V1, Mod) || V1 <- v_dbs(Mod)].
+
+v_dbs_mods_1(M, Mod) ->
+    binary_to_atom(<<(atom_to_binary(Mod, utf8))/binary,
+		     "_", (atom_to_binary(M, utf8))/binary>>,
+		   utf8).
 
 - spec ( { { v_host , 1 } , [ { type , 974 , 'fun' , [ { type , 974 , product , [ { type , 974 , binary , [ ] } ] } , { type , 974 , binary , [ ] } ] } ] } ) .
 
@@ -1100,43 +1101,38 @@ get_modules_with_options(Modules) ->
 
 
 validate_opts(#state{opts = Opts} = State, ModOpts) ->
-    try NewOpts = lists:map(fun (#local_config{key =
-						   {Opt, _Host},
-					       value = Val} =
-				     In) ->
-				    case dict:find(Opt, ModOpts) of
-				      {ok, [Mod | _]} ->
-					  VFun = Mod:opt_type(Opt),
-					  try VFun(Val) of
-					    NewVal ->
-						In#local_config{value = NewVal}
-					  catch
-					    {invalid_syntax, Error} ->
-						?ERROR_MSG("Invalid value for option '~s' (~s): ~s",
-							   [Opt, Error,
-							    misc:format_val({yaml,
-									     Val})]),
-						erlang:error(invalid_option);
-					    _:R when R /= undef ->
-						?ERROR_MSG("Invalid value for option '~s': ~s",
-							   [Opt,
-							    misc:format_val({yaml,
-									     Val})]),
-						erlang:error(invalid_option)
-					  end;
-				      _ ->
-					  ?ERROR_MSG("Unknown option '~s'",
-						     [Opt]),
-					  erlang:error(unknown_option)
-				    end
-			    end,
-			    Opts),
+    try NewOpts = [validate_opts_1(V1, ModOpts)
+		   || V1 <- Opts],
 	{ok, State#state{opts = NewOpts}}
     catch
       _:invalid_option -> {error, invalid_option};
       _:unknown_option -> {error, unknown_option}
     end.
 
+validate_opts_1(#local_config{key = {Opt, _Host},
+			      value = Val} =
+		    In,
+		ModOpts) ->
+    case dict:find(Opt, ModOpts) of
+      {ok, [Mod | _]} ->
+	  VFun = Mod:opt_type(Opt),
+	  try VFun(Val) of
+	    NewVal -> In#local_config{value = NewVal}
+	  catch
+	    {invalid_syntax, Error} ->
+		?ERROR_MSG("Invalid value for option '~s' (~s): ~s",
+			   [Opt, Error, misc:format_val({yaml, Val})]),
+		erlang:error(invalid_option);
+	    _:R when R /= undef ->
+		?ERROR_MSG("Invalid value for option '~s': ~s",
+			   [Opt, misc:format_val({yaml, Val})]),
+		erlang:error(invalid_option)
+	  end;
+      _ ->
+	  ?ERROR_MSG("Unknown option '~s'", [Opt]),
+	  erlang:error(unknown_option)
+    end.
+
 %% @spec (Path::string()) -> true | false
 is_file_readable(Path) ->
     case file:read_file_info(Path) of
@@ -1220,23 +1216,22 @@ replace_module(Module) ->
     end.
 
 replace_modules(Modules) ->
-    lists:map(fun ({Module, Opts}) ->
-		      case replace_module(Module) of
-			{NewModule, DBType} ->
-			    emit_deprecation_warning(Module, NewModule, DBType),
-			    NewOpts = [{db_type, DBType}
-				       | lists:keydelete(db_type, 1, Opts)],
-			    {NewModule,
-			     transform_module_options(Module, NewOpts)};
-			NewModule ->
-			    if Module /= NewModule ->
-				   emit_deprecation_warning(Module, NewModule);
-			       true -> ok
-			    end,
-			    {NewModule, transform_module_options(Module, Opts)}
-		      end
-	      end,
-	      Modules).
+    [replace_modules_1(V1) || V1 <- Modules].
+
+replace_modules_1({Module, Opts}) ->
+    case replace_module(Module) of
+      {NewModule, DBType} ->
+	  emit_deprecation_warning(Module, NewModule, DBType),
+	  NewOpts = [{db_type, DBType} | lists:keydelete(db_type,
+							 1, Opts)],
+	  {NewModule, transform_module_options(Module, NewOpts)};
+      NewModule ->
+	  if Module /= NewModule ->
+		 emit_deprecation_warning(Module, NewModule);
+	     true -> ok
+	  end,
+	  {NewModule, transform_module_options(Module, Opts)}
+    end.
 
 %% Elixir module naming
 %% ====================
diff --git a/src/ejabberd_ctl.erl b/src/ejabberd_ctl.erl
index e98ee9b..0aaa3f9 100644
--- a/src/ejabberd_ctl.erl
+++ b/src/ejabberd_ctl.erl
@@ -619,22 +619,25 @@ format_command_lines(CALD, MaxCmdLen, MaxC, ShCode,
 			 long);
 format_command_lines(CALD, MaxCmdLen, MaxC, ShCode,
 		     dual) ->
-    lists:map(fun ({Cmd, Args, CmdArgsL, Desc}) ->
-		      DescFmt = prepare_description(MaxCmdLen + 4, MaxC,
-						    Desc),
-		      ["   ", ?B(Cmd), " ", [[?U(Arg), " "] || Arg <- Args],
-		       string:chars($ , MaxCmdLen - CmdArgsL + 1), DescFmt,
-		       "\n"]
-	      end,
-	      CALD);
+    [format_command_lines_1(V1, MaxC, MaxCmdLen)
+     || V1 <- CALD];
 format_command_lines(CALD, _MaxCmdLen, MaxC, ShCode,
 		     long) ->
-    lists:map(fun ({Cmd, Args, _CmdArgsL, Desc}) ->
-		      DescFmt = prepare_description(8, MaxC, Desc),
-		      ["\n   ", ?B(Cmd), " ", [[?U(Arg), " "] || Arg <- Args],
-		       "\n", "        ", DescFmt, "\n"]
-	      end,
-	      CALD).
+    [format_command_lines_1(V2, MaxC) || V2 <- CALD].
+
+format_command_lines_1({Cmd, Args, CmdArgsL, Desc},
+		       MaxC, MaxCmdLen) ->
+    DescFmt = prepare_description(MaxCmdLen + 4, MaxC,
+				  Desc),
+    ["   ", ?B(Cmd), " ", [[?U(Arg), " "] || Arg <- Args],
+     string:chars($ , MaxCmdLen - CmdArgsL + 1), DescFmt,
+     "\n"].
+
+format_command_lines_1({Cmd, Args, _CmdArgsL, Desc},
+		       MaxC) ->
+    DescFmt = prepare_description(8, MaxC, Desc),
+    ["\n   ", ?B(Cmd), " ", [[?U(Arg), " "] || Arg <- Args],
+     "\n", "        ", DescFmt, "\n"].
 
 %%-----------------------------
 %% Print Tags
@@ -666,21 +669,21 @@ print_usage_tags(Tag, MaxC, ShCode, Version) ->
 		      {value, {Tag, CNs}} -> CNs;
 		      false -> []
 		    end,
-    CommandsList = lists:map(fun (NameString) ->
-				     C =
-					 ejabberd_commands:get_command_definition(list_to_atom(NameString),
-										  Version),
-				     #ejabberd_commands{name = Name,
-							args = Args,
-							desc = Desc} =
-					 C,
-				     tuple_command_help({Name, Args, Desc})
-			     end,
-			     CommandsNames),
+    CommandsList = [print_usage_tags_1(V1, Version)
+		    || V1 <- CommandsNames],
     print_usage_commands(HelpMode, MaxC, ShCode,
 			 CommandsList),
     print("\n", []).
 
+print_usage_tags_1(NameString, Version) ->
+    C =
+	ejabberd_commands:get_command_definition(list_to_atom(NameString),
+						 Version),
+    #ejabberd_commands{name = Name, args = Args,
+		       desc = Desc} =
+	C,
+    tuple_command_help({Name, Args, Desc}).
+
 %%-----------------------------
 %% Print usage of 'help' command
 %%-----------------------------
@@ -769,15 +772,15 @@ filter_commands(All, SubString) ->
 filter_commands_regexp(All, Glob) ->
     RegExp =
 	ejabberd_regexp:sh_to_awk(list_to_binary(Glob)),
-    lists:filter(fun (Command) ->
-			 case ejabberd_regexp:run(list_to_binary(Command),
-						  RegExp)
-			     of
-			   match -> true;
-			   nomatch -> false
-			 end
-		 end,
-		 All).
+    [V1 || V1 <- All, filter_commands_regexp_1(V1, RegExp)].
+
+filter_commands_regexp_1(Command, RegExp) ->
+    case ejabberd_regexp:run(list_to_binary(Command),
+			     RegExp)
+	of
+      match -> true;
+      nomatch -> false
+    end.
 
 %% @spec (Cmd::string(), MaxC::integer(), ShCode::boolean()) -> ok
 print_usage_command(Cmd, MaxC, ShCode, Version) ->
diff --git a/src/ejabberd_http.erl b/src/ejabberd_http.erl
index b54c5c6..b632955 100644
--- a/src/ejabberd_http.erl
+++ b/src/ejabberd_http.erl
@@ -93,13 +93,7 @@ start_link(SockData, Opts) ->
 
 init({SockMod, Socket}, Opts) ->
     TLSEnabled = proplists:get_bool(tls, Opts),
-    TLSOpts1 = lists:filter(fun ({ciphers, _}) -> true;
-				({dhfile, _}) -> true;
-				({cafile, _}) -> true;
-				({protocol_options, _}) -> true;
-				(_) -> false
-			    end,
-			    Opts),
+    TLSOpts1 = [V1 || V1 <- Opts, init_1(V1)],
     TLSOpts2 = case proplists:get_bool(tls_compression,
 				       Opts)
 		   of
@@ -158,6 +152,12 @@ init({SockMod, Socket}, Opts) ->
       {error, _} -> State
     end.
 
+init_1({ciphers, _}) -> true;
+init_1({dhfile, _}) -> true;
+init_1({cafile, _}) -> true;
+init_1({protocol_options, _}) -> true;
+init_1(_) -> false.
+
 accept(_Pid) -> ok.
 
 send_text(_State, none) -> ok;
@@ -779,12 +779,12 @@ rest_dir(N, Path, <<_H, T/binary>>) ->
     rest_dir(N, Path, T).
 
 expand_custom_headers(Headers) ->
-    lists:map(fun ({K, V}) ->
-		      {K,
-		       misc:expand_keyword(<<"@VERSION@">>, V,
-					   ejabberd_config:get_version())}
-	      end,
-	      Headers).
+    [expand_custom_headers_1(V1) || V1 <- Headers].
+
+expand_custom_headers_1({K, V}) ->
+    {K,
+     misc:expand_keyword(<<"@VERSION@">>, V,
+			 ejabberd_config:get_version())}.
 
 code_to_phrase(100) -> <<"Continue">>;
 code_to_phrase(101) -> <<"Switching Protocols ">>;
@@ -943,16 +943,16 @@ transform_listen_option(http_bind, Opts) ->
     [{http_bind, true} | Opts];
 transform_listen_option(http_poll, Opts) -> Opts;
 transform_listen_option({request_handlers, Hs}, Opts) ->
-    Hs1 = lists:map(fun ({PList, Mod})
-			    when is_list(PList) ->
-			    Path = iolist_to_binary([[$/, P] || P <- PList]),
-			    {Path, Mod};
-			(Opt) -> Opt
-		    end,
-		    Hs),
+    Hs1 = [transform_listen_option_1(V1) || V1 <- Hs],
     [{request_handlers, Hs1} | Opts];
 transform_listen_option(Opt, Opts) -> [Opt | Opts].
 
+transform_listen_option_1({PList, Mod})
+    when is_list(PList) ->
+    Path = iolist_to_binary([[$/, P] || P <- PList]),
+    {Path, Mod};
+transform_listen_option_1(Opt) -> Opt.
+
 - spec ( { { opt_type , 1 } , [ { type , 951 , 'fun' , [ { type , 951 , product , [ { type , 951 , atom , [ ] } ] } , { type , 951 , union , [ { type , 951 , 'fun' , [ { type , 951 , product , [ { type , 951 , any , [ ] } ] } , { type , 951 , any , [ ] } ] } , { type , 951 , list , [ { type , 951 , atom , [ ] } ] } ] } ] } ] } ) .
 
 
@@ -991,11 +991,7 @@ listen_opt_type(xmlrpc) ->
     fun (B) when is_boolean(B) -> B end;
 listen_opt_type(request_handlers) ->
     fun (Hs) ->
-	    Hs1 = lists:map(fun ({Mod, Path}) when is_atom(Mod) ->
-				    {Path, Mod};
-				({Path, Mod}) -> {Path, Mod}
-			    end,
-			    Hs),
+	    Hs1 = [listen_opt_type_1(V1) || V1 <- Hs],
 	    Hs2 = [{str:tokens(iolist_to_binary(Path), <<"/">>),
 		    Mod}
 		   || {Path, Mod} <- Hs1],
@@ -1010,6 +1006,10 @@ listen_opt_type(default_host) -> fun iolist_to_binary/1;
 listen_opt_type(custom_headers) ->
     fun expand_custom_headers/1.
 
+listen_opt_type_1({Mod, Path}) when is_atom(Mod) ->
+    {Path, Mod};
+listen_opt_type_1({Path, Mod}) -> {Path, Mod}.
+
 listen_options() ->
     [{certfile, undefined}, {ciphers, undefined},
      {dhfile, undefined}, {cafile, undefined},
diff --git a/src/ejabberd_listener.erl b/src/ejabberd_listener.erl
index ff93c69..272f00d 100644
--- a/src/ejabberd_listener.erl
+++ b/src/ejabberd_listener.erl
@@ -103,12 +103,12 @@ init(_) ->
 
 
 listeners_childspec(Listeners) ->
-    lists:map(fun ({EndPoint, Module, Opts}) ->
-		      ets:insert(?MODULE, {EndPoint, Module, Opts}),
-		      {EndPoint, {?MODULE, start, [EndPoint, Module, Opts]},
-		       transient, brutal_kill, worker, [?MODULE]}
-	      end,
-	      Listeners).
+    [listeners_childspec_1(V1) || V1 <- Listeners].
+
+listeners_childspec_1({EndPoint, Module, Opts}) ->
+    ets:insert(?MODULE, {EndPoint, Module, Opts}),
+    {EndPoint, {?MODULE, start, [EndPoint, Module, Opts]},
+     transient, brutal_kill, worker, [?MODULE]}.
 
 - spec ( { { start_listeners , 0 } , [ { type , 78 , 'fun' , [ { type , 78 , product , [ ] } , { atom , 78 , ok } ] } ] } ) .
 
@@ -495,13 +495,7 @@ transform_option({{Port, IP, Transport}, Mod, Opts}) ->
 		   list_to_binary(inet_parse:ntoa(IP));
 	       true -> IP
 	    end,
-    Opts1 = lists:map(fun ({ip, IPT}) when is_tuple(IPT) ->
-			      {ip, list_to_binary(inet_parse:ntoa(IP))};
-			  (ssl) -> {tls, true};
-			  (A) when is_atom(A) -> {A, true};
-			  (Opt) -> Opt
-		      end,
-		      Opts),
+    Opts1 = [transform_option_1(V1, IP) || V1 <- Opts],
     Opts2 = lists:foldl(fun (Opt, Acc) ->
 				try Mod:transform_listen_option(Opt, Acc) catch
 				  error:undef -> [Opt | Acc]
@@ -527,11 +521,17 @@ transform_option({Port, Mod, Opts}) ->
 		      Opts});
 transform_option(Opt) -> Opt.
 
+transform_option_1({ip, IPT}, IP) when is_tuple(IPT) ->
+    {ip, list_to_binary(inet_parse:ntoa(IP))};
+transform_option_1(ssl, IP) -> {tls, true};
+transform_option_1(A, IP) when is_atom(A) -> {A, true};
+transform_option_1(Opt, IP) -> Opt.
+
 transform_options(Opts) ->
     lists:foldl(fun transform_options/2, [], Opts).
 
 transform_options({listen, LOpts}, Opts) ->
-    [{listen, lists:map(fun transform_option/1, LOpts)}
+    [{listen, [transform_option(V1) || V1 <- LOpts]}
      | Opts];
 transform_options(Opt, Opts) -> [Opt | Opts].
 
@@ -539,7 +539,7 @@ transform_options(Opt, Opts) -> [Opt | Opts].
 
 
 validate_cfg(Listeners) ->
-    Listeners1 = lists:map(fun validate_opts/1, Listeners),
+    Listeners1 = [validate_opts(V1) || V1 <- Listeners],
     Listeners2 = lists:keysort(1, Listeners1),
     check_overlapping_listeners(Listeners2).
 
@@ -634,7 +634,7 @@ validate_opts(Mod, Opts) ->
 						end
 					end,
 					Defaults, Opts),
-    case lists:filter(fun is_atom/1, Defaults1) of
+    case [V1 || V1 <- Defaults1, fun is_atom/1(V1)] of
       [] -> lists:flatten(Opts1);
       MissingRequiredOpts ->
 	  ?ERROR_MSG("Missing required listening option(s): ~s",
diff --git a/src/ejabberd_mnesia.erl b/src/ejabberd_mnesia.erl
index 37b2048..b2bd341 100644
--- a/src/ejabberd_mnesia.erl
+++ b/src/ejabberd_mnesia.erl
@@ -157,8 +157,8 @@ update(Name, Attrs, TabDef) ->
 
 change_table_copy_type(Name, TabDef) ->
     CurrType = mnesia:table_info(Name, storage_type),
-    NewType = case
-		lists:filter(fun is_storage_type_option/1, TabDef)
+    NewType = case [V1
+		    || V1 <- TabDef, is_storage_type_option(V1)]
 		  of
 		[{Type, _} | _] -> Type;
 		[] -> CurrType
@@ -234,39 +234,7 @@ read_schema_file() ->
     end.
 
 validate_schema_opts(File, Opts) ->
-    try {ok,
-	 lists:map(fun ({storage_type, Type})
-			   when Type == ram_copies;
-				Type == disc_copies;
-				Type == disc_only_copies ->
-			   {Type, [node()]};
-		       ({storage_type, _} = Opt) ->
-			   erlang:error({invalid_value, Opt});
-		       ({local_content, Bool}) when is_boolean(Bool) ->
-			   {local_content, Bool};
-		       ({local_content, _} = Opt) ->
-			   erlang:error({invalid_value, Opt});
-		       ({type, Type})
-			   when Type == set; Type == ordered_set; Type == bag ->
-			   {type, Type};
-		       ({type, _} = Opt) -> erlang:error({invalid_value, Opt});
-		       ({attributes, Attrs} = Opt) ->
-			   try lists:all(fun is_atom/1, Attrs) of
-			     true -> {attributes, Attrs};
-			     false -> erlang:error({invalid_value, Opt})
-			   catch
-			     _:_ -> erlang:error({invalid_value, Opt})
-			   end;
-		       ({index, Indexes} = Opt) ->
-			   try lists:all(fun is_atom/1, Indexes) of
-			     true -> {index, Indexes};
-			     false -> erlang:error({invalid_value, Opt})
-			   catch
-			     _:_ -> erlang:error({invalid_value, Opt})
-			   end;
-		       (Opt) -> erlang:error({unknown_option, Opt})
-		   end,
-		   Opts)}
+    try {ok, [validate_schema_opts_1(V1) || V1 <- Opts]}
     catch
       _:{invalid_value, {Opt, Val}} ->
 	  ?ERROR_MSG("Mnesia schema ~s is incorrect: invalid "
@@ -280,6 +248,40 @@ validate_schema_opts(File, Opts) ->
 	  error
     end.
 
+validate_schema_opts_1({storage_type, Type})
+    when Type == ram_copies;
+	 Type == disc_copies;
+	 Type == disc_only_copies ->
+    {Type, [node()]};
+validate_schema_opts_1({storage_type, _} = Opt) ->
+    erlang:error({invalid_value, Opt});
+validate_schema_opts_1({local_content, Bool})
+    when is_boolean(Bool) ->
+    {local_content, Bool};
+validate_schema_opts_1({local_content, _} = Opt) ->
+    erlang:error({invalid_value, Opt});
+validate_schema_opts_1({type, Type})
+    when Type == set; Type == ordered_set; Type == bag ->
+    {type, Type};
+validate_schema_opts_1({type, _} = Opt) ->
+    erlang:error({invalid_value, Opt});
+validate_schema_opts_1({attributes, Attrs} = Opt) ->
+    try lists:all(fun is_atom/1, Attrs) of
+      true -> {attributes, Attrs};
+      false -> erlang:error({invalid_value, Opt})
+    catch
+      _:_ -> erlang:error({invalid_value, Opt})
+    end;
+validate_schema_opts_1({index, Indexes} = Opt) ->
+    try lists:all(fun is_atom/1, Indexes) of
+      true -> {index, Indexes};
+      false -> erlang:error({invalid_value, Opt})
+    catch
+      _:_ -> erlang:error({invalid_value, Opt})
+    end;
+validate_schema_opts_1(Opt) ->
+    erlang:error({unknown_option, Opt}).
+
 create(Name, TabDef) ->
     ?INFO_MSG("Creating Mnesia table '~s'", [Name]),
     case mnesia_op(create_table, [Name, TabDef]) of
@@ -300,15 +302,14 @@ merge(Custom, Default) ->
     NewDefault = case
 		   lists:any(fun is_storage_type_option/1, Custom)
 		     of
-		   true ->
-		       lists:filter(fun (O) -> not is_storage_type_option(O)
-				    end,
-				    Default);
+		   true -> [V1 || V1 <- Default, merge_1(V1)];
 		   false -> Default
 		 end,
     lists:ukeymerge(1, Custom,
 		    lists:ukeysort(1, NewDefault)).
 
+merge_1(O) -> not is_storage_type_option(O).
+
 need_reset(Table, TabDef) ->
     ValuesF = [mnesia:table_info(Table, Key)
 	       || Key <- ?NEED_RESET],
diff --git a/src/ejabberd_piefxis.erl b/src/ejabberd_piefxis.erl
index 1af5d6f..336c5a5 100644
--- a/src/ejabberd_piefxis.erl
+++ b/src/ejabberd_piefxis.erl
@@ -233,7 +233,7 @@ get_offline(User, Server) ->
     case mod_offline:get_offline_els(LUser, LServer) of
       [] -> [];
       Els ->
-	  NewEls = lists:map(fun xmpp:encode/1, Els),
+	  NewEls = [fun xmpp:encode/1(V1) || V1 <- Els],
 	  [#xmlel{name = <<"offline-messages">>,
 		  children = NewEls}]
     end.
@@ -245,18 +245,17 @@ get_privacy(User, Server) ->
     case mod_privacy:get_user_lists(User, Server) of
       {ok,
        #privacy{default = Default, lists = [_ | _] = Lists}} ->
-	  XLists = lists:map(fun ({Name, Items}) ->
-				     XItems =
-					 lists:map(fun mod_privacy:encode_list_item/1,
-						   Items),
-				     #privacy_list{name = Name, items = XItems}
-			     end,
-			     Lists),
+	  XLists = [get_privacy_1(V2) || V2 <- Lists],
 	  [xmpp:encode(#privacy_query{default = Default,
 				      lists = XLists})];
       _ -> []
     end.
 
+get_privacy_1({Name, Items}) ->
+    XItems = [fun mod_privacy:encode_list_item/1(V1)
+	      || V1 <- Items],
+    #privacy_list{name = Name, items = XItems}.
+
 - spec ( { { get_roster , 2 } , [ { type , 244 , 'fun' , [ { type , 244 , product , [ { type , 244 , binary , [ ] } , { type , 244 , binary , [ ] } ] } , { type , 244 , list , [ { type , 244 , xmlel , [ ] } ] } ] } ] } ) .
 
 
diff --git a/src/ejabberd_redis_sup.erl b/src/ejabberd_redis_sup.erl
index 9054c16..6f387ff 100644
--- a/src/ejabberd_redis_sup.erl
+++ b/src/ejabberd_redis_sup.erl
@@ -125,11 +125,12 @@ is_redis_configured(Host) ->
       or RouterConfigured.
 
 get_specs() ->
-    lists:map(fun (I) ->
-		      {I, {ejabberd_redis, start_link, [I]}, transient, 2000,
-		       worker, [?MODULE]}
-	      end,
-	      lists:seq(1, get_pool_size())).
+    [get_specs_1(V1)
+     || V1 <- lists:seq(1, get_pool_size())].
+
+get_specs_1(I) ->
+    {I, {ejabberd_redis, start_link, [I]}, transient, 2000,
+     worker, [?MODULE]}.
 
 get_pool_size() ->
     ejabberd_config:get_option(redis_pool_size,
diff --git a/src/ejabberd_riak.erl b/src/ejabberd_riak.erl
index ed479e4..6045a85 100644
--- a/src/ejabberd_riak.erl
+++ b/src/ejabberd_riak.erl
@@ -503,22 +503,7 @@ encode_key(Term) -> erlang:term_to_binary(Term).
 
 log_error({error, notfound}, _, _) -> ok;
 log_error({error, Why} = Err, Function, Opts) ->
-    Txt = lists:map(fun ({table, Table}) ->
-			    io_lib:fwrite("** Table: ~p~n", [Table]);
-			({key, Key}) -> io_lib:fwrite("** Key: ~p~n", [Key]);
-			({index, Index}) ->
-			    io_lib:fwrite("** Index = ~p~n", [Index]);
-			({start_key, Key}) ->
-			    io_lib:fwrite("** Start Key: ~p~n", [Key]);
-			({end_key, Key}) ->
-			    io_lib:fwrite("** End Key: ~p~n", [Key]);
-			({record, Rec}) ->
-			    io_lib:fwrite("** Record = ~p~n", [Rec]);
-			({index_info, IdxInfo}) ->
-			    io_lib:fwrite("** Index info = ~p~n", [IdxInfo]);
-			(_) -> ""
-		    end,
-		    Opts),
+    Txt = [log_error_1(V1) || V1 <- Opts],
     ErrTxt = if is_binary(Why) ->
 		    io_lib:fwrite("** Error: ~s", [Why]);
 		true -> io_lib:fwrite("** Error: ~p", [Err])
@@ -527,6 +512,22 @@ log_error({error, Why} = Err, Function, Opts) ->
 	       [Function, Txt, ErrTxt]);
 log_error(_, _, _) -> ok.
 
+log_error_1({table, Table}) ->
+    io_lib:fwrite("** Table: ~p~n", [Table]);
+log_error_1({key, Key}) ->
+    io_lib:fwrite("** Key: ~p~n", [Key]);
+log_error_1({index, Index}) ->
+    io_lib:fwrite("** Index = ~p~n", [Index]);
+log_error_1({start_key, Key}) ->
+    io_lib:fwrite("** Start Key: ~p~n", [Key]);
+log_error_1({end_key, Key}) ->
+    io_lib:fwrite("** End Key: ~p~n", [Key]);
+log_error_1({record, Rec}) ->
+    io_lib:fwrite("** Record = ~p~n", [Rec]);
+log_error_1({index_info, IdxInfo}) ->
+    io_lib:fwrite("** Index info = ~p~n", [IdxInfo]);
+log_error_1(_) -> "".
+
 make_invalid_object(Val) ->
     str:format("Invalid object: ~p", [Val]).
 
diff --git a/src/ejabberd_riak_sup.erl b/src/ejabberd_riak_sup.erl
index 4e5fe1e..b268943 100644
--- a/src/ejabberd_riak_sup.erl
+++ b/src/ejabberd_riak_sup.erl
@@ -137,22 +137,27 @@ get_specs() ->
     CACertFile = get_riak_cacertfile(),
     Username = get_riak_username(),
     Password = get_riak_password(),
-    Options = lists:filter(fun (X) -> X /= nil end,
-			   [auto_reconnect, {keepalive, true},
-			    if CACertFile /= nil -> {cacertfile, CACertFile};
-			       true -> nil
-			    end,
-			    if (Username /= nil) and (Password /= nil) ->
-				   {credentials, Username, Password};
-			       true -> nil
-			    end]),
-    lists:map(fun (I) ->
-		      {ejabberd_riak:get_proc(I),
-		       {ejabberd_riak, start_link,
-			[I, Server, Port, StartInterval * 1000, Options]},
-		       transient, 2000, worker, [?MODULE]}
-	      end,
-	      lists:seq(1, PoolSize)).
+    Options = [V1
+	       || V1
+		      <- [auto_reconnect, {keepalive, true},
+			  if CACertFile /= nil -> {cacertfile, CACertFile};
+			     true -> nil
+			  end,
+			  if (Username /= nil) and (Password /= nil) ->
+				 {credentials, Username, Password};
+			     true -> nil
+			  end],
+		  get_specs_1(V1)],
+    [get_specs_1(V2, Options, Port, Server, StartInterval)
+     || V2 <- lists:seq(1, PoolSize)].
+
+get_specs_1(X) -> X /= nil.
+
+get_specs_1(I, Options, Port, Server, StartInterval) ->
+    {ejabberd_riak:get_proc(I),
+     {ejabberd_riak, start_link,
+      [I, Server, Port, StartInterval * 1000, Options]},
+     transient, 2000, worker, [?MODULE]}.
 
 get_start_interval() ->
     ejabberd_config:get_option(riak_start_interval,
diff --git a/src/ejabberd_router_redis.erl b/src/ejabberd_router_redis.erl
index 6d764c6..d4dbe4b 100644
--- a/src/ejabberd_router_redis.erl
+++ b/src/ejabberd_router_redis.erl
@@ -171,9 +171,9 @@ domain_key(Domain) ->
     <<"ejabberd:route:", Domain/binary>>.
 
 decode_routes(Domain, Vals) ->
-    lists:map(fun ({Pid, Data}) ->
-		      {ServerHost, LocalHint} = binary_to_term(Data),
-		      #route{domain = Domain, pid = binary_to_term(Pid),
-			     server_host = ServerHost, local_hint = LocalHint}
-	      end,
-	      Vals).
+    [decode_routes_1(V1, Domain) || V1 <- Vals].
+
+decode_routes_1({Pid, Data}, Domain) ->
+    {ServerHost, LocalHint} = binary_to_term(Data),
+    #route{domain = Domain, pid = binary_to_term(Pid),
+	   server_host = ServerHost, local_hint = LocalHint}.
diff --git a/src/ejabberd_s2s_out.erl b/src/ejabberd_s2s_out.erl
index d8aedc1..4dfb993 100644
--- a/src/ejabberd_s2s_out.erl
+++ b/src/ejabberd_s2s_out.erl
@@ -372,11 +372,7 @@ maybe_report_huge_timeout(_, _) -> ok.
 
 
 opt_type(outgoing_s2s_families) ->
-    fun (Families) ->
-	    lists:map(fun (ipv4) -> inet;
-			  (ipv6) -> inet6
-		      end,
-		      Families)
+    fun (Families) -> [opt_type_1(V1) || V1 <- Families]
     end;
 opt_type(outgoing_s2s_port) ->
     fun (I) when is_integer(I), I > 0, I < 65536 -> I end;
@@ -399,3 +395,6 @@ opt_type(_) ->
     [outgoing_s2s_families, outgoing_s2s_port,
      outgoing_s2s_timeout, s2s_dns_retries, s2s_dns_timeout,
      s2s_max_retry_delay].
+
+opt_type_1(ipv4) -> inet;
+opt_type_1(ipv6) -> inet6.
diff --git a/src/ejabberd_service.erl b/src/ejabberd_service.erl
index c22d33c..d41b16a 100644
--- a/src/ejabberd_service.erl
+++ b/src/ejabberd_service.erl
@@ -159,20 +159,18 @@ listen_opt_type(check_from) ->
 listen_opt_type(password) -> fun iolist_to_binary/1;
 listen_opt_type(hosts) ->
     fun (HostOpts) ->
-	    lists:map(fun ({Host, Opts}) ->
-			      Password = case proplists:get_value(password,
-								  Opts)
-					     of
-					   undefined -> undefined;
-					   P -> iolist_to_binary(P)
-					 end,
-			      {iolist_to_binary(Host), Password}
-		      end,
-		      HostOpts)
+	    [listen_opt_type_1(V1) || V1 <- HostOpts]
     end;
 listen_opt_type(global_routes) ->
     fun (B) when is_boolean(B) -> B end.
 
+listen_opt_type_1({Host, Opts}) ->
+    Password = case proplists:get_value(password, Opts) of
+		 undefined -> undefined;
+		 P -> iolist_to_binary(P)
+	       end,
+    {iolist_to_binary(Host), Password}.
+
 listen_options() ->
     [{access, all}, {shaper, none}, {shaper_rule, none},
      {certfile, undefined}, {ciphers, undefined},
diff --git a/src/ejabberd_shaper.erl b/src/ejabberd_shaper.erl
index 2b35183..7aadd01 100644
--- a/src/ejabberd_shaper.erl
+++ b/src/ejabberd_shaper.erl
@@ -147,17 +147,17 @@ transform_options({shaper, Name, none}, Opts) ->
     [{shaper, [{Name, none}]} | Opts];
 transform_options({shaper, List}, Opts)
     when is_list(List) ->
-    R = lists:map(fun ({Name, Args}) when is_list(Args) ->
-			  MaxRate = proplists:get_value(rate, Args, 1000),
-			  BurstSize = proplists:get_value(burst_size, Args,
-							  MaxRate),
-			  {Name, MaxRate, BurstSize};
-		      ({Name, Val}) -> {Name, Val, Val}
-		  end,
-		  List),
+    R = [transform_options_1(V1) || V1 <- List],
     [{shaper, R} | Opts];
 transform_options(Opt, Opts) -> [Opt | Opts].
 
+transform_options_1({Name, Args}) when is_list(Args) ->
+    MaxRate = proplists:get_value(rate, Args, 1000),
+    BurstSize = proplists:get_value(burst_size, Args,
+				    MaxRate),
+    {Name, MaxRate, BurstSize};
+transform_options_1({Name, Val}) -> {Name, Val, Val}.
+
 - spec ( { { opt_type , 1 } , [ { type , 150 , 'fun' , [ { type , 150 , product , [ { type , 150 , atom , [ ] } ] } , { type , 150 , union , [ { type , 150 , 'fun' , [ { type , 150 , product , [ { type , 150 , any , [ ] } ] } , { type , 150 , any , [ ] } ] } , { type , 150 , list , [ { type , 150 , atom , [ ] } ] } ] } ] } ] } ) .
 
 
diff --git a/src/ejabberd_sql.erl b/src/ejabberd_sql.erl
index 290beb6..19a3a3e 100644
--- a/src/ejabberd_sql.erl
+++ b/src/ejabberd_sql.erl
@@ -838,17 +838,18 @@ sqlite_to_odbc(Host, {rowid, _}) ->
     {updated, sqlite3:changes(sqlite_db(Host))};
 sqlite_to_odbc(_Host,
 	       [{columns, Columns}, {rows, TRows}]) ->
-    Rows = [lists:map(fun (I) when is_integer(I) ->
-			      integer_to_binary(I);
-			  (B) -> B
-		      end,
-		      tuple_to_list(Row))
+    Rows = [[sqlite_to_odbc_1(V1)
+	     || V1 <- tuple_to_list(Row)]
 	    || Row <- TRows],
     {selected, [list_to_binary(C) || C <- Columns], Rows};
 sqlite_to_odbc(_Host, {error, _Code, Reason}) ->
     {error, Reason};
 sqlite_to_odbc(_Host, _) -> {updated, undefined}.
 
+sqlite_to_odbc_1(I) when is_integer(I) ->
+    integer_to_binary(I);
+sqlite_to_odbc_1(B) -> B.
+
 %% == Native PostgreSQL code
 
 %% part of init/1
@@ -947,17 +948,15 @@ mysql_item_to_odbc(Columns, Recs) ->
      Recs}.
 
 to_odbc({selected, Columns, Recs}) ->
-    Rows = [lists:map(fun (I) when is_integer(I) ->
-			      integer_to_binary(I);
-			  (B) -> B
-		      end,
-		      Row)
-	    || Row <- Recs],
+    Rows = [[to_odbc_1(V1) || V1 <- Row] || Row <- Recs],
     {selected, [list_to_binary(C) || C <- Columns], Rows};
 to_odbc({error, Reason}) when is_list(Reason) ->
     {error, list_to_binary(Reason)};
 to_odbc(Res) -> Res.
 
+to_odbc_1(I) when is_integer(I) -> integer_to_binary(I);
+to_odbc_1(B) -> B.
+
 get_db_version(#state{db_type = pgsql} = State) ->
     case pgsql:squery(State#state.db_ref,
 		      <<"select current_setting('server_version_num')">>)
diff --git a/src/ejabberd_sql_pt.erl b/src/ejabberd_sql_pt.erl
index 999da4e..9db7100 100644
--- a/src/ejabberd_sql_pt.erl
+++ b/src/ejabberd_sql_pt.erl
@@ -149,20 +149,20 @@ transform(Form) ->
     end.
 
 top_transform(Forms) when is_list(Forms) ->
-    lists:map(fun (Form) ->
-		      try Form2 = erl_syntax_lib:map(fun (Node) ->
-							     %io:format("asd ~p~n", [Node]),
-							     transform(Node)
-						     end,
-						     Form),
-			  Form3 = erl_syntax:revert(Form2),
-			  Form3
-		      catch
-			{error, Line, Error} ->
-			    {error, {Line, erl_parse, Error}}
-		      end
-	      end,
-	      Forms).
+    [top_transform_1(V1) || V1 <- Forms].
+
+top_transform_1(Form) ->
+    try Form2 = erl_syntax_lib:map(fun (Node) ->
+					   %io:format("asd ~p~n", [Node]),
+					   transform(Node)
+				   end,
+				   Form),
+	Form3 = erl_syntax:revert(Form2),
+	Form3
+    catch
+      {error, Line, Error} ->
+	  {error, {Line, erl_parse, Error}}
+    end.
 
 transform_sql(Arg) ->
     S = erl_syntax:string_value(Arg),
@@ -324,11 +324,7 @@ make_sql_query(State) ->
 				     use_new_schema = true}),
     SHash = <<"Q", (integer_to_binary(Hash))/binary>>,
     Query = pack_query(State#state.query),
-    EQuery = lists:map(fun ({str, S}) ->
-			       erl_syntax:binary([erl_syntax:binary_field(erl_syntax:string(S))]);
-			   ({var, V}) -> make_var(V)
-		       end,
-		       Query),
+    EQuery = [make_sql_query_1(V1) || V1 <- Query],
     erl_syntax:record_expr(erl_syntax:atom(?QUERY_RECORD),
 			   [erl_syntax:record_field(erl_syntax:atom(hash),
 						    %erl_syntax:abstract(SHash)
@@ -338,8 +334,9 @@ make_sql_query(State) ->
 											   none,
 											   [erl_syntax:list(State#state.args)])])),
 			    erl_syntax:record_field(erl_syntax:atom(format_query),
-						    erl_syntax:fun_expr([erl_syntax:clause([erl_syntax:list(lists:map(fun make_var/1,
-														      State#state.params))],
+						    erl_syntax:fun_expr([erl_syntax:clause([erl_syntax:list([make_var(V2)
+													     || V2
+														    <- State#state.params])],
 											   none,
 											   [erl_syntax:list(EQuery)])])),
 			    erl_syntax:record_field(erl_syntax:atom(format_res),
@@ -350,6 +347,10 @@ make_sql_query(State) ->
 						    erl_syntax:abstract({get(?MOD),
 									 State#state.loc}))]).
 
+make_sql_query_1({str, S}) ->
+    erl_syntax:binary([erl_syntax:binary_field(erl_syntax:string(S))]);
+make_sql_query_1({var, V}) -> make_var(V).
+
 pack_query([]) -> [];
 pack_query([{str, S1}, {str, S2} | Rest]) ->
     pack_query([{str, S1 ++ S2} | Rest]);
@@ -462,12 +463,9 @@ make_sql_upsert_update(Table, ParseRes) ->
     State.
 
 make_sql_upsert_insert(Table, ParseRes) ->
-    Vals = lists:map(fun ({_Field, _, ST}) -> ST end,
-		     ParseRes),
-    Fields = lists:map(fun ({Field, _, _ST}) ->
-			       #state{query = [{str, Field}]}
-		       end,
-		       ParseRes),
+    Vals = [make_sql_upsert_insert_1(V1) || V1 <- ParseRes],
+    Fields = [make_sql_upsert_insert_2(V2)
+	      || V2 <- ParseRes],
     State = concat_states([#state{query =
 				      [{str, "INSERT INTO "}, {str, Table},
 				       {str, "("}]},
@@ -477,14 +475,17 @@ make_sql_upsert_insert(Table, ParseRes) ->
 			   #state{query = [{str, ");"}]}]),
     State.
 
+make_sql_upsert_insert_1({_Field, _, ST}) -> ST.
+
+make_sql_upsert_insert_2({Field, _, _ST}) ->
+    #state{query = [{str, Field}]}.
+
 make_sql_upsert_pgsql901(Table, ParseRes) ->
     Update = make_sql_upsert_update(Table, ParseRes),
-    Vals = lists:map(fun ({_Field, _, ST}) -> ST end,
-		     ParseRes),
-    Fields = lists:map(fun ({Field, _, _ST}) ->
-			       #state{query = [{str, Field}]}
-		       end,
-		       ParseRes),
+    Vals = [make_sql_upsert_pgsql901_1(V1)
+	    || V1 <- ParseRes],
+    Fields = [make_sql_upsert_pgsql901_2(V2)
+	      || V2 <- ParseRes],
     Insert = concat_states([#state{query =
 				       [{str, "INSERT INTO "}, {str, Table},
 					{str, "("}]},
@@ -502,11 +503,13 @@ make_sql_upsert_pgsql901(Table, ParseRes) ->
     erl_syntax:application(erl_syntax:atom(ejabberd_sql),
 			   erl_syntax:atom(sql_query_t), [Upsert]).
 
+make_sql_upsert_pgsql901_1({_Field, _, ST}) -> ST.
+
+make_sql_upsert_pgsql901_2({Field, _, _ST}) ->
+    #state{query = [{str, Field}]}.
+
 check_upsert(ParseRes, Pos) ->
-    Set = lists:filter(fun ({_Field, Match, _ST}) ->
-			       Match /= key
-		       end,
-		       ParseRes),
+    Set = [V1 || V1 <- ParseRes, check_upsert_1(V1)],
     case Set of
       [] ->
 	  throw({error, Pos,
@@ -516,6 +519,8 @@ check_upsert(ParseRes, Pos) ->
     end,
     ok.
 
+check_upsert_1({_Field, Match, _ST}) -> Match /= key.
+
 parse_insert(Fields) ->
     {Fs, _} = lists:foldr(fun (F, {Acc, Param}) ->
 				  case erl_syntax:type(F) of
@@ -598,23 +603,25 @@ resolve_vars(ST1, ST2) ->
 				   end
 			   end,
 			   {dict:new(), Max + 1}, ST1#state.params),
-    NewParams = lists:map(fun (Var) ->
-				  case dict:find(Var, Map) of
-				    {ok, New} -> New;
-				    error -> Var
-				  end
-			  end,
-			  ST1#state.params),
-    NewQuery = lists:map(fun ({var, Var}) ->
-				 case dict:find(Var, Map) of
-				   {ok, New} -> {var, New};
-				   error -> {var, Var}
-				 end;
-			     (S) -> S
-			 end,
-			 ST1#state.query),
+    NewParams = [resolve_vars_1(V1, Map)
+		 || V1 <- ST1#state.params],
+    NewQuery = [resolve_vars_2(V2, Map)
+		|| V2 <- ST1#state.query],
     ST1#state{params = NewParams, query = NewQuery}.
 
+resolve_vars_1(Var, Map) ->
+    case dict:find(Var, Map) of
+      {ok, New} -> New;
+      error -> Var
+    end.
+
+resolve_vars_2({var, Var}, Map) ->
+    case dict:find(Var, Map) of
+      {ok, New} -> {var, New};
+      error -> {var, Var}
+    end;
+resolve_vars_2(S, Map) -> S.
+
 join_states([], _Sep) -> #state{};
 join_states([H | T], Sep) ->
     J = [[H] | [[#state{query = [{str, Sep}]}, X]
@@ -631,10 +638,10 @@ set_pos(Tree, Pos) ->
 		       Tree).
 
 filter_upsert_sh(Table, ParseRes) ->
-    lists:filter(fun ({Field, _Match, _ST}) ->
-			 Field /= "server_host" orelse Table == "route"
-		 end,
-		 ParseRes).
+    [V1 || V1 <- ParseRes, filter_upsert_sh_1(V1, Table)].
+
+filter_upsert_sh_1({Field, _Match, _ST}, Table) ->
+    Field /= "server_host" orelse Table == "route".
 
 -ifdef(ENABLE_PT_WARNINGS).
 
diff --git a/src/ejabberd_system_monitor.erl b/src/ejabberd_system_monitor.erl
index 2b31c26..206f77a 100644
--- a/src/ejabberd_system_monitor.erl
+++ b/src/ejabberd_system_monitor.erl
@@ -246,14 +246,12 @@ format_apps(Apps) ->
 
 format_top_procs(Stats) ->
     Stats1 = lists:sublist(Stats, 5),
-    string:join(lists:map(fun (#proc_stat{name = Name} =
-				   Stat) ->
-				  [io_lib:format("** ~w: ", [Name]),
-				   format_proc(Stat)]
-			  end,
-			  Stats1),
+    string:join([format_top_procs_1(V1) || V1 <- Stats1],
 		io_lib:nl()).
 
+format_top_procs_1(#proc_stat{name = Name} = Stat) ->
+    [io_lib:format("** ~w: ", [Name]), format_proc(Stat)].
+
 - spec ( { { format_proc , 1 } , [ { type , 244 , 'fun' , [ { type , 244 , product , [ { type , 244 , proc_stat , [ ] } ] } , { remote_type , 244 , [ { atom , 244 , io } , { atom , 244 , data } , [ ] ] } ] } ] } ) .
 
 
diff --git a/src/ejabberd_update.erl b/src/ejabberd_update.erl
index c82053c..11d730f 100644
--- a/src/ejabberd_update.erl
+++ b/src/ejabberd_update.erl
@@ -95,17 +95,16 @@ get_beams(Files) ->
 
 %% Return only the beams that have different version
 get_updated_beams(Beams) ->
-    lists:filter(fun (Module) ->
-			 NewVsn = get_new_version(Module),
-			 case code:is_loaded(Module) of
-			   {file, _} ->
-			       CurVsn = get_current_version(Module),
-			       NewVsn /= CurVsn andalso
-				 NewVsn /= unknown_version;
-			   false -> false
-			 end
-		 end,
-		 Beams).
+    [V1 || V1 <- Beams, get_updated_beams_1(V1)].
+
+get_updated_beams_1(Module) ->
+    NewVsn = get_new_version(Module),
+    case code:is_loaded(Module) of
+      {file, _} ->
+	  CurVsn = get_current_version(Module),
+	  NewVsn /= CurVsn andalso NewVsn /= unknown_version;
+      false -> false
+    end.
 
 get_new_version(Module) ->
     Path = code:which(Module),
@@ -190,21 +189,21 @@ build_script(Dir, UpdatedBeams) ->
 				 %% found (internal use).
 
 make_script(UpdatedBeams) ->
-    lists:map(fun (Module) ->
-		      {ok, {Module, [{attributes, NewAttrs}]}} =
-			  beam_lib:chunks(code:which(Module), [attributes]),
-		      CurAttrs = Module:module_info(attributes),
-		      case lists:keysearch(update_info, 1, NewAttrs) of
-			{value, {_, [{update, _}]}} ->
-			    case lists:keysearch(update_info, 1, CurAttrs) of
-			      {value, {_, [{update, Extra}]}} ->
-				  {update, Module, {advanced, Extra}};
-			      false -> {update, Module, {advanced, 0}}
-			    end;
-			false -> {load_module, Module}
-		      end
-	      end,
-	      UpdatedBeams).
+    [make_script_1(V1) || V1 <- UpdatedBeams].
+
+make_script_1(Module) ->
+    {ok, {Module, [{attributes, NewAttrs}]}} =
+	beam_lib:chunks(code:which(Module), [attributes]),
+    CurAttrs = Module:module_info(attributes),
+    case lists:keysearch(update_info, 1, NewAttrs) of
+      {value, {_, [{update, _}]}} ->
+	  case lists:keysearch(update_info, 1, CurAttrs) of
+	    {value, {_, [{update, Extra}]}} ->
+		{update, Module, {advanced, Extra}};
+	    false -> {update, Module, {advanced, 0}}
+	  end;
+      false -> {load_module, Module}
+    end.
 
 make_low_level_script(UpdatedBeams, Script) ->
     EJDApp = #application{name = ejabberd,
diff --git a/src/ejabberd_web_admin.erl b/src/ejabberd_web_admin.erl
index 0e92567..33aaed0 100644
--- a/src/ejabberd_web_admin.erl
+++ b/src/ejabberd_web_admin.erl
@@ -95,20 +95,20 @@ get_jid(Auth, HostHTTP, Method) ->
 
 get_menu_items(global, cluster, Lang, JID) ->
     {Base, _, Items} = make_server_menu([], [], Lang, JID),
-    lists:map(fun ({URI, Name}) ->
-		      {<<Base/binary, URI/binary, "/">>, Name};
-		  ({URI, Name, _SubMenu}) ->
-		      {<<Base/binary, URI/binary, "/">>, Name}
-	      end,
-	      Items);
+    [get_menu_items_1(V1, Base) || V1 <- Items];
 get_menu_items(Host, cluster, Lang, JID) ->
     {Base, _, Items} = make_host_menu(Host, [], Lang, JID),
-    lists:map(fun ({URI, Name}) ->
-		      {<<Base/binary, URI/binary, "/">>, Name};
-		  ({URI, Name, _SubMenu}) ->
-		      {<<Base/binary, URI/binary, "/">>, Name}
-	      end,
-	      Items).
+    [get_menu_items_2(V2, Base) || V2 <- Items].
+
+get_menu_items_1({URI, Name}, Base) ->
+    {<<Base/binary, URI/binary, "/">>, Name};
+get_menu_items_1({URI, Name, _SubMenu}, Base) ->
+    {<<Base/binary, URI/binary, "/">>, Name}.
+
+get_menu_items_2({URI, Name}, Base) ->
+    {<<Base/binary, URI/binary, "/">>, Name};
+get_menu_items_2({URI, Name, _SubMenu}, Base) ->
+    {<<Base/binary, URI/binary, "/">>, Name}.
 
 %% get_menu_items(Host, Node, Lang, JID) ->
 %%     {Base, _, Items} = make_host_node_menu(Host, Node, Lang, JID),
@@ -730,21 +730,11 @@ process_admin(Host,
 		       [{<<"action">>, <<"">>}, {<<"method">>, <<"post">>}],
 		       [?CT(<<"Period: ">>),
 			?XAE(<<"select">>, [{<<"name">>, <<"period">>}],
-			     (lists:map(fun ({O, V}) ->
-						Sel = if O == Month ->
-							     [{<<"selected">>,
-							       <<"selected">>}];
-							 true -> []
-						      end,
-						?XAC(<<"option">>,
-						     (Sel ++
-							[{<<"value">>, O}]),
-						     V)
-					end,
-					[{<<"month">>, ?T(<<"Last month">>)},
+			     [process_admin_1(V1, Month)
+			      || V1
+				     <- [{<<"month">>, ?T(<<"Last month">>)},
 					 {<<"year">>, ?T(<<"Last year">>)},
-					 {<<"all">>,
-					  ?T(<<"All activity">>)}]))),
+					 {<<"all">>, ?T(<<"All activity">>)}]]),
 			?C(<<" ">>),
 			?INPUTT(<<"submit">>, <<"ordinary">>,
 				<<"Show Ordinary Table">>),
@@ -808,30 +798,35 @@ process_admin(Host,
       _ -> make_xhtml(Res, Host, Lang, AJID)
     end.
 
+process_admin_1({O, V}, Month) ->
+    Sel = if O == Month ->
+		 [{<<"selected">>, <<"selected">>}];
+	     true -> []
+	  end,
+    ?XAC(<<"option">>, (Sel ++ [{<<"value">>, O}]), V).
+
 %%%==================================
 %%%% acl
 
 acls_to_xhtml(ACLs) ->
     ?XAE(<<"table">>, [],
 	 [?XE(<<"tbody">>,
-	      (lists:map(fun ({acl, Name, Spec} = ACL) ->
-				 SName = iolist_to_binary(atom_to_list(Name)),
-				 ID = term_to_id(ACL),
-				 ?XE(<<"tr">>,
-				     ([?XE(<<"td">>,
-					   [?INPUT(<<"checkbox">>,
-						   <<"selected">>, ID)]),
-				       ?XC(<<"td">>, SName)]
-					++ acl_spec_to_xhtml(ID, Spec)))
-			 end,
-			 ACLs)
-		 ++
+	      ([acls_to_xhtml_1(V1) || V1 <- ACLs] ++
 		 [?XE(<<"tr">>,
 		      ([?X(<<"td">>),
 			?XE(<<"td">>,
 			    [?INPUT(<<"text">>, <<"namenew">>, <<"">>)])]
 			 ++ acl_spec_to_xhtml(<<"new">>, {user, <<"">>})))]))]).
 
+acls_to_xhtml_1({acl, Name, Spec} = ACL) ->
+    SName = iolist_to_binary(atom_to_list(Name)),
+    ID = term_to_id(ACL),
+    ?XE(<<"tr">>,
+	([?XE(<<"td">>,
+	      [?INPUT(<<"checkbox">>, <<"selected">>, ID)]),
+	  ?XC(<<"td">>, SName)]
+	   ++ acl_spec_to_xhtml(ID, Spec))).
+
 acl_spec_to_text({user, {U, S}}) ->
     {user, <<U/binary, "@", S/binary>>};
 acl_spec_to_text({user, U}) -> {user, U};
@@ -866,20 +861,20 @@ acl_spec_select(ID, Opt) ->
     ?XE(<<"td">>,
 	[?XAE(<<"select">>,
 	      [{<<"name">>, <<"type", ID/binary>>}],
-	      (lists:map(fun (O) ->
-				 Sel = if O == Opt ->
-					      [{<<"selected">>,
-						<<"selected">>}];
-					  true -> []
-				       end,
-				 ?XAC(<<"option">>,
-				      (Sel ++
-					 [{<<"value">>,
-					   iolist_to_binary(atom_to_list(O))}]),
-				      (iolist_to_binary(atom_to_list(O))))
-			 end,
-			 [user, server, user_regexp, server_regexp, node_regexp,
-			  user_glob, server_glob, node_glob, all, ip, raw])))]).
+	      [acl_spec_select_1(V1, Opt)
+	       || V1
+		      <- [user, server, user_regexp, server_regexp,
+			  node_regexp, user_glob, server_glob, node_glob, all,
+			  ip, raw]])]).
+
+acl_spec_select_1(O, Opt) ->
+    Sel = if O == Opt -> [{<<"selected">>, <<"selected">>}];
+	     true -> []
+	  end,
+    ?XAC(<<"option">>,
+	 (Sel ++
+	    [{<<"value">>, iolist_to_binary(atom_to_list(O))}]),
+	 (iolist_to_binary(atom_to_list(O)))).
 
 %% @spec (T::any()) -> StringLine::string()
 term_to_string(T) ->
@@ -910,28 +905,7 @@ acl_parse_query(Host, Query) ->
     end.
 
 acl_parse_submit(ACLs, Query) ->
-    NewACLs = lists:map(fun ({acl, Name, Spec} = ACL) ->
-				ID = term_to_id(ACL),
-				case {lists:keysearch(<<"type", ID/binary>>, 1,
-						      Query),
-				      lists:keysearch(<<"value", ID/binary>>, 1,
-						      Query)}
-				    of
-				  {{value, {_, T}}, {value, {_, V}}} ->
-				      {Type, Str} = acl_spec_to_text(Spec),
-				      case
-					{iolist_to_binary(atom_to_list(Type)),
-					 Str}
-					  of
-					{T, V} -> ACL;
-					_ ->
-					    NewSpec = string_to_spec(T, V),
-					    {acl, Name, NewSpec}
-				      end;
-				  _ -> ACL
-				end
-			end,
-			ACLs),
+    NewACLs = [acl_parse_submit_1(V1, Query) || V1 <- ACLs],
     NewACL = case {lists:keysearch(<<"namenew">>, 1, Query),
 		   lists:keysearch(<<"typenew">>, 1, Query),
 		   lists:keysearch(<<"valuenew">>, 1, Query)}
@@ -945,6 +919,21 @@ acl_parse_submit(ACLs, Query) ->
 	     end,
     NewACLs ++ NewACL.
 
+acl_parse_submit_1({acl, Name, Spec} = ACL, Query) ->
+    ID = term_to_id(ACL),
+    case {lists:keysearch(<<"type", ID/binary>>, 1, Query),
+	  lists:keysearch(<<"value", ID/binary>>, 1, Query)}
+	of
+      {{value, {_, T}}, {value, {_, V}}} ->
+	  {Type, Str} = acl_spec_to_text(Spec),
+	  case {iolist_to_binary(atom_to_list(Type)), Str} of
+	    {T, V} -> ACL;
+	    _ ->
+		NewSpec = string_to_spec(T, V), {acl, Name, NewSpec}
+	  end;
+      _ -> ACL
+    end.
+
 string_to_spec(<<"user">>, Val) ->
     string_to_spec2(user, Val);
 string_to_spec(<<"server">>, Val) -> {server, Val};
@@ -984,29 +973,19 @@ string_to_spec2(ACLName, Val) ->
     end.
 
 acl_parse_delete(ACLs, Query) ->
-    NewACLs = lists:filter(fun ({acl, _Name, _Spec} =
-				    ACL) ->
-				   ID = term_to_id(ACL),
-				   not lists:member({<<"selected">>, ID}, Query)
-			   end,
-			   ACLs),
+    NewACLs = [V1
+	       || V1 <- ACLs, acl_parse_delete_1(V1, Query)],
     NewACLs.
 
+acl_parse_delete_1({acl, _Name, _Spec} = ACL, Query) ->
+    ID = term_to_id(ACL),
+    not lists:member({<<"selected">>, ID}, Query).
+
 access_rules_to_xhtml(AccessRules, Lang) ->
     ?XAE(<<"table">>, [],
 	 [?XE(<<"tbody">>,
-	      (lists:map(fun ({access, Name, Rules} = Access) ->
-				 SName = iolist_to_binary(atom_to_list(Name)),
-				 ID = term_to_id(Access),
-				 ?XE(<<"tr">>,
-				     [?XE(<<"td">>,
-					  [?INPUT(<<"checkbox">>,
-						  <<"selected">>, ID)]),
-				      ?XE(<<"td">>,
-					  [?AC(<<SName/binary, "/">>, SName)]),
-				      ?XC(<<"td">>, (term_to_string(Rules)))])
-			 end,
-			 lists:keysort(2, AccessRules))
+	      ([access_rules_to_xhtml_1(V1)
+		|| V1 <- lists:keysort(2, AccessRules)]
 		 ++
 		 [?XE(<<"tr">>,
 		      [?X(<<"td">>),
@@ -1016,6 +995,16 @@ access_rules_to_xhtml(AccessRules, Lang) ->
 			   [?INPUTT(<<"submit">>, <<"addnew">>,
 				    <<"Add New">>)])])]))]).
 
+access_rules_to_xhtml_1({access, Name, Rules} =
+			    Access) ->
+    SName = iolist_to_binary(atom_to_list(Name)),
+    ID = term_to_id(Access),
+    ?XE(<<"tr">>,
+	[?XE(<<"td">>,
+	     [?INPUT(<<"checkbox">>, <<"selected">>, ID)]),
+	 ?XE(<<"td">>, [?AC(<<SName/binary, "/">>, SName)]),
+	 ?XC(<<"td">>, (term_to_string(Rules)))]).
+
 access_parse_query(Host, Query) ->
     AccessRules = mnesia:dirty_select(access,
 				      [{{access, {'$1', Host}, '$2'}, [],
@@ -1088,15 +1077,14 @@ parse_access_rule(Text) ->
 
 list_vhosts(Lang, JID) ->
     Hosts = ejabberd_config:get_myhosts(),
-    HostsAllowed = lists:filter(fun (Host) ->
-					acl:any_rules_allowed(Host,
-							      [configure,
-							       webadmin_view],
-							      JID)
-				end,
-				Hosts),
+    HostsAllowed = [V1
+		    || V1 <- Hosts, list_vhosts_1(V1, JID)],
     list_vhosts2(Lang, HostsAllowed).
 
+list_vhosts_1(Host, JID) ->
+    acl:any_rules_allowed(Host, [configure, webadmin_view],
+			  JID).
+
 list_vhosts2(Lang, Hosts) ->
     SHosts = lists:sort(Hosts),
     [?XE(<<"table">>,
@@ -1106,22 +1094,17 @@ list_vhosts2(Lang, Hosts) ->
 		    ?XCT(<<"td">>, <<"Registered Users">>),
 		    ?XCT(<<"td">>, <<"Online Users">>)])]),
 	  ?XE(<<"tbody">>,
-	      (lists:map(fun (Host) ->
-				 OnlineUsers =
-				     length(ejabberd_sm:get_vh_session_list(Host)),
-				 RegisteredUsers =
-				     ejabberd_auth:count_users(Host),
-				 ?XE(<<"tr">>,
-				     [?XE(<<"td">>,
-					  [?AC(<<"../server/", Host/binary,
-						 "/">>,
-					       Host)]),
-				      ?XC(<<"td">>,
-					  (pretty_string_int(RegisteredUsers))),
-				      ?XC(<<"td">>,
-					  (pretty_string_int(OnlineUsers)))])
-			 end,
-			 SHosts)))])].
+	      [list_vhosts2_1(V1) || V1 <- SHosts])])].
+
+list_vhosts2_1(Host) ->
+    OnlineUsers =
+	length(ejabberd_sm:get_vh_session_list(Host)),
+    RegisteredUsers = ejabberd_auth:count_users(Host),
+    ?XE(<<"tr">>,
+	[?XE(<<"td">>,
+	     [?AC(<<"../server/", Host/binary, "/">>, Host)]),
+	 ?XC(<<"td">>, (pretty_string_int(RegisteredUsers))),
+	 ?XC(<<"td">>, (pretty_string_int(OnlineUsers)))]).
 
 %%%==================================
 %%%% list_users
@@ -1225,49 +1208,38 @@ list_given_users(Host, Users, Prefix, Lang, URLFunc) ->
 		   ?XCT(<<"td">>, <<"Offline Messages">>),
 		   ?XCT(<<"td">>, <<"Last Activity">>)])]),
 	 ?XE(<<"tbody">>,
-	     (lists:map(fun (_SU = {Server, User}) ->
-				US = {User, Server},
-				QueueLenStr = get_offlinemsg_length(ModOffline,
-								    User,
-								    Server),
-				FQueueLen = [?AC((URLFunc({users_queue, Prefix,
-							   User, Server})),
-						 QueueLenStr)],
-				FLast = case
-					  ejabberd_sm:get_user_resources(User,
-									 Server)
-					    of
-					  [] ->
-					      case mod_last:get_last_info(User,
-									  Server)
-						  of
-						not_found -> ?T(<<"Never">>);
-						{ok, Shift, _Status} ->
-						    TimeStamp = {Shift div
-								   1000000,
-								 Shift rem
-								   1000000,
-								 0},
-						    {{Year, Month, Day},
-						     {Hour, Minute, Second}} =
-							calendar:now_to_local_time(TimeStamp),
-						    str:format("~w-~.2.0w-~.2.0w ~.2.0w:~.2.0w:~.2.0w",
-							       [Year, Month,
-								Day, Hour,
-								Minute, Second])
-					      end;
-					  _ -> ?T(<<"Online">>)
-					end,
-				?XE(<<"tr">>,
-				    [?XE(<<"td">>,
-					 [?AC((URLFunc({user, Prefix,
-							misc:url_encode(User),
-							Server})),
-					      (us_to_list(US)))]),
-				     ?XE(<<"td">>, FQueueLen),
-				     ?XC(<<"td">>, FLast)])
-			end,
-			Users)))]).
+	     [list_given_users_1(V1, ModOffline, Prefix, URLFunc)
+	      || V1 <- Users])]).
+
+list_given_users_1(_SU = {Server, User}, ModOffline,
+		   Prefix, URLFunc) ->
+    US = {User, Server},
+    QueueLenStr = get_offlinemsg_length(ModOffline, User,
+					Server),
+    FQueueLen = [?AC((URLFunc({users_queue, Prefix, User,
+			       Server})),
+		     QueueLenStr)],
+    FLast = case ejabberd_sm:get_user_resources(User,
+						Server)
+		of
+	      [] ->
+		  case mod_last:get_last_info(User, Server) of
+		    not_found -> ?T(<<"Never">>);
+		    {ok, Shift, _Status} ->
+			TimeStamp = {Shift div 1000000, Shift rem 1000000, 0},
+			{{Year, Month, Day}, {Hour, Minute, Second}} =
+			    calendar:now_to_local_time(TimeStamp),
+			str:format("~w-~.2.0w-~.2.0w ~.2.0w:~.2.0w:~.2.0w",
+				   [Year, Month, Day, Hour, Minute, Second])
+		  end;
+	      _ -> ?T(<<"Online">>)
+	    end,
+    ?XE(<<"tr">>,
+	[?XE(<<"td">>,
+	     [?AC((URLFunc({user, Prefix, misc:url_encode(User),
+			    Server})),
+		  (us_to_list(US)))]),
+	 ?XE(<<"td">>, FQueueLen), ?XC(<<"td">>, FLast)]).
 
 get_offlinemsg_length(ModOffline, User, Server) ->
     case ModOffline of
@@ -1356,59 +1328,8 @@ user_info(User, Server, Query, Lang) ->
 		   [] -> [?CT(<<"None">>)];
 		   _ ->
 		       [?XE(<<"ul">>,
-			    (lists:map(fun (R) ->
-					       FIP = case
-						       ejabberd_sm:get_user_info(User,
-										 Server,
-										 R)
-							 of
-						       offline -> <<"">>;
-						       Info
-							   when is_list(Info) ->
-							   Node =
-							       proplists:get_value(node,
-										   Info),
-							   Conn =
-							       proplists:get_value(conn,
-										   Info),
-							   {IP, Port} =
-							       proplists:get_value(ip,
-										   Info),
-							   ConnS = case Conn of
-								     c2s ->
-									 <<"plain">>;
-								     c2s_tls ->
-									 <<"tls">>;
-								     c2s_compressed ->
-									 <<"zlib">>;
-								     c2s_compressed_tls ->
-									 <<"tls+zlib">>;
-								     http_bind ->
-									 <<"http-bind">>;
-								     websocket ->
-									 <<"websocket">>;
-								     _ ->
-									 <<"unknown">>
-								   end,
-							   <<ConnS/binary,
-							     "://",
-							     (misc:ip_to_list(IP))/binary,
-							     ":",
-							     (integer_to_binary(Port))/binary,
-							     "#",
-							     (misc:atom_to_binary(Node))/binary>>
-						     end,
-					       case direction(Lang) of
-						 [{_, <<"rtl">>}] ->
-						     ?LI([?C(<<FIP/binary,
-							       " - ",
-							       R/binary>>)]);
-						 _ ->
-						     ?LI([?C(<<R/binary, " - ",
-							       FIP/binary>>)])
-					       end
-				       end,
-				       lists:sort(Resources))))]
+			    [user_info_1(V1, Lang, Server, User)
+			     || V1 <- lists:sort(Resources)])]
 		 end,
     FPassword = [?INPUT(<<"text">>, <<"password">>, <<"">>),
 		 ?C(<<" ">>),
@@ -1455,6 +1376,32 @@ user_info(User, Server, Query, Lang) ->
 			      ?INPUTT(<<"submit">>, <<"removeuser">>,
 				      <<"Remove User">>)]))].
 
+user_info_1(R, Lang, Server, User) ->
+    FIP = case ejabberd_sm:get_user_info(User, Server, R) of
+	    offline -> <<"">>;
+	    Info when is_list(Info) ->
+		Node = proplists:get_value(node, Info),
+		Conn = proplists:get_value(conn, Info),
+		{IP, Port} = proplists:get_value(ip, Info),
+		ConnS = case Conn of
+			  c2s -> <<"plain">>;
+			  c2s_tls -> <<"tls">>;
+			  c2s_compressed -> <<"zlib">>;
+			  c2s_compressed_tls -> <<"tls+zlib">>;
+			  http_bind -> <<"http-bind">>;
+			  websocket -> <<"websocket">>;
+			  _ -> <<"unknown">>
+			end,
+		<<ConnS/binary, "://", (misc:ip_to_list(IP))/binary,
+		  ":", (integer_to_binary(Port))/binary, "#",
+		  (misc:atom_to_binary(Node))/binary>>
+	  end,
+    case direction(Lang) of
+      [{_, <<"rtl">>}] ->
+	  ?LI([?C(<<FIP/binary, " - ", R/binary>>)]);
+      _ -> ?LI([?C(<<R/binary, " - ", FIP/binary>>)])
+    end.
+
 user_parse_query(User, Server, Query) ->
     lists:foldl(fun ({Action, _Value}, Acc)
 			when Acc == nothing ->
@@ -1555,26 +1502,24 @@ get_nodes(Lang) ->
     FRN = if RunningNodes == [] -> ?CT(<<"None">>);
 	     true ->
 		 ?XE(<<"ul">>,
-		     (lists:map(fun (N) ->
-					S = iolist_to_binary(atom_to_list(N)),
-					?LI([?AC(<<"../node/", S/binary, "/">>,
-						 S)])
-				end,
-				lists:sort(RunningNodes))))
+		     [get_nodes_1(V1) || V1 <- lists:sort(RunningNodes)])
 	  end,
     FSN = if StoppedNodes == [] -> ?CT(<<"None">>);
 	     true ->
 		 ?XE(<<"ul">>,
-		     (lists:map(fun (N) ->
-					S = iolist_to_binary(atom_to_list(N)),
-					?LI([?C(S)])
-				end,
-				lists:sort(StoppedNodes))))
+		     [get_nodes_2(V2) || V2 <- lists:sort(StoppedNodes)])
 	  end,
     [?XCT(<<"h1">>, <<"Nodes">>),
      ?XCT(<<"h3">>, <<"Running Nodes">>), FRN,
      ?XCT(<<"h3">>, <<"Stopped Nodes">>), FSN].
 
+get_nodes_1(N) ->
+    S = iolist_to_binary(atom_to_list(N)),
+    ?LI([?AC(<<"../node/", S/binary, "/">>, S)]).
+
+get_nodes_2(N) ->
+    S = iolist_to_binary(atom_to_list(N)), ?LI([?C(S)]).
+
 search_running_node(SNode) ->
     RunningNodes = ejabberd_cluster:get_nodes(),
     search_running_node(SNode, RunningNodes).
@@ -1632,51 +1577,7 @@ get_node(global, Node, [<<"db">>], Query, Lang) ->
 		   ok -> [?XREST(<<"Submitted">>)]
 		 end,
 	  STables = lists:sort(Tables),
-	  Rows = lists:map(fun (Table) ->
-				   STable =
-				       iolist_to_binary(atom_to_list(Table)),
-				   TInfo = case ejabberd_cluster:call(Node,
-								      mnesia,
-								      table_info,
-								      [Table,
-								       all])
-					       of
-					     {badrpc, _} -> [];
-					     I -> I
-					   end,
-				   {Type, Size, Memory} = case
-							    {lists:keysearch(storage_type,
-									     1,
-									     TInfo),
-							     lists:keysearch(size,
-									     1,
-									     TInfo),
-							     lists:keysearch(memory,
-									     1,
-									     TInfo)}
-							      of
-							    {{value,
-							      {storage_type,
-							       T}},
-							     {value, {size, S}},
-							     {value,
-							      {memory, M}}} ->
-								{T, S, M};
-							    _ -> {unknown, 0, 0}
-							  end,
-				   ?XE(<<"tr">>,
-				       [?XC(<<"td">>, STable),
-					?XE(<<"td">>,
-					    [db_storage_select(STable, Type,
-							       Lang)]),
-					?XAC(<<"td">>,
-					     [{<<"class">>, <<"alignright">>}],
-					     (pretty_string_int(Size))),
-					?XAC(<<"td">>,
-					     [{<<"class">>, <<"alignright">>}],
-					     (pretty_string_int(Memory)))])
-			   end,
-			   STables),
+	  Rows = [get_node_1(V1, Lang, Node) || V1 <- STables],
 	  [?XC(<<"h1">>,
 	       (str:format(?T(<<"Database Tables at ~p">>), [Node])))]
 	    ++
@@ -1990,15 +1891,7 @@ get_node(global, Node, [<<"update">>], Query, Lang) ->
     Mods = case UpdatedBeams of
 	     [] -> ?CT(<<"None">>);
 	     _ ->
-		 BeamsLis = lists:map(fun (Beam) ->
-					      BeamString =
-						  iolist_to_binary(atom_to_list(Beam)),
-					      ?LI([?INPUT(<<"checkbox">>,
-							  <<"selected">>,
-							  BeamString),
-						   ?C(BeamString)])
-				      end,
-				      UpdatedBeams),
+		 BeamsLis = [get_node_1(V2) || V2 <- UpdatedBeams],
 		 SelectButtons = [?BR,
 				  ?INPUTATTRS(<<"button">>, <<"selectall">>,
 					      <<"Select All">>,
@@ -2049,6 +1942,37 @@ get_node(Host, Node, NPath, Query, Lang) ->
       _ -> Res
     end.
 
+get_node_1(Table, Lang, Node) ->
+    STable = iolist_to_binary(atom_to_list(Table)),
+    TInfo = case ejabberd_cluster:call(Node, mnesia,
+				       table_info, [Table, all])
+		of
+	      {badrpc, _} -> [];
+	      I -> I
+	    end,
+    {Type, Size, Memory} = case
+			     {lists:keysearch(storage_type, 1, TInfo),
+			      lists:keysearch(size, 1, TInfo),
+			      lists:keysearch(memory, 1, TInfo)}
+			       of
+			     {{value, {storage_type, T}}, {value, {size, S}},
+			      {value, {memory, M}}} ->
+				 {T, S, M};
+			     _ -> {unknown, 0, 0}
+			   end,
+    ?XE(<<"tr">>,
+	[?XC(<<"td">>, STable),
+	 ?XE(<<"td">>, [db_storage_select(STable, Type, Lang)]),
+	 ?XAC(<<"td">>, [{<<"class">>, <<"alignright">>}],
+	      (pretty_string_int(Size))),
+	 ?XAC(<<"td">>, [{<<"class">>, <<"alignright">>}],
+	      (pretty_string_int(Memory)))]).
+
+get_node_1(Beam) ->
+    BeamString = iolist_to_binary(atom_to_list(Beam)),
+    ?LI([?INPUT(<<"checkbox">>, <<"selected">>, BeamString),
+	 ?C(BeamString)]).
+
 %%%==================================
 %%%% node parse
 
@@ -2073,23 +1997,23 @@ node_parse_query(Node, Query) ->
 db_storage_select(ID, Opt, Lang) ->
     ?XAE(<<"select">>,
 	 [{<<"name">>, <<"table", ID/binary>>}],
-	 (lists:map(fun ({O, Desc}) ->
-			    Sel = if O == Opt ->
-					 [{<<"selected">>, <<"selected">>}];
-				     true -> []
-				  end,
-			    ?XACT(<<"option">>,
-				  (Sel ++
-				     [{<<"value">>,
-				       iolist_to_binary(atom_to_list(O))}]),
-				  Desc)
-		    end,
-		    [{ram_copies, <<"RAM copy">>},
+	 [db_storage_select_1(V1, Opt)
+	  || V1
+		 <- [{ram_copies, <<"RAM copy">>},
 		     {disc_copies, <<"RAM and disc copy">>},
 		     {disc_only_copies, <<"Disc only copy">>},
 		     {unknown, <<"Remote copy">>},
 		     {delete_content, <<"Delete content">>},
-		     {delete_table, <<"Delete table">>}]))).
+		     {delete_table, <<"Delete table">>}]]).
+
+db_storage_select_1({O, Desc}, Opt) ->
+    Sel = if O == Opt -> [{<<"selected">>, <<"selected">>}];
+	     true -> []
+	  end,
+    ?XACT(<<"option">>,
+	  (Sel ++
+	     [{<<"value">>, iolist_to_binary(atom_to_list(O))}]),
+	  Desc).
 
 node_db_parse_query(_Node, _Tables, [{nokey, <<>>}]) ->
     nothing;
@@ -2237,40 +2161,7 @@ node_ports_to_xhtml(Ports, Lang) ->
 		    ?XCT(<<"td">>, <<"Module">>),
 		    ?XCT(<<"td">>, <<"Options">>)])]),
 	  ?XE(<<"tbody">>,
-	      (lists:map(fun ({PortIP, Module, Opts} = _E) ->
-				 {_Port, SPort, _TIP, SIP, SSPort, NetProt,
-				  OptsClean} =
-				     get_port_data(PortIP, Opts),
-				 SModule =
-				     iolist_to_binary(atom_to_list(Module)),
-				 {NumLines, SOptsClean} =
-				     term_to_paragraph(OptsClean, 40),
-				 ?XE(<<"tr">>,
-				     [?XAE(<<"td">>, [{<<"size">>, <<"6">>}],
-					   [?C(SPort)]),
-				      ?XAE(<<"td">>, [{<<"size">>, <<"15">>}],
-					   [?C(SIP)]),
-				      ?XAE(<<"td">>, [{<<"size">>, <<"4">>}],
-					   [?C((iolist_to_binary(atom_to_list(NetProt))))]),
-				      ?XE(<<"td">>,
-					  [?INPUTS(<<"text">>,
-						   <<"module", SSPort/binary>>,
-						   SModule, <<"15">>)]),
-				      ?XAE(<<"td">>, (direction(ltr)),
-					   [?TEXTAREA(<<"opts", SSPort/binary>>,
-						      (integer_to_binary(NumLines)),
-						      <<"35">>, SOptsClean)]),
-				      ?XE(<<"td">>,
-					  [?INPUTT(<<"submit">>,
-						   <<"add", SSPort/binary>>,
-						   <<"Restart">>)]),
-				      ?XE(<<"td">>,
-					  [?INPUTT(<<"submit">>,
-						   <<"delete", SSPort/binary>>,
-						   <<"Stop">>)])])
-			 end,
-			 Ports)
-		 ++
+	      ([node_ports_to_xhtml_1(V1) || V1 <- Ports] ++
 		 [?XE(<<"tr">>,
 		      [?XE(<<"td">>,
 			   [?INPUTS(<<"text">>, <<"portnew">>, <<"">>,
@@ -2289,29 +2180,55 @@ node_ports_to_xhtml(Ports, Lang) ->
 			    [?INPUTT(<<"submit">>, <<"addnew">>,
 				     <<"Start">>)])])]))]).
 
+node_ports_to_xhtml_1({PortIP, Module, Opts} = _E) ->
+    {_Port, SPort, _TIP, SIP, SSPort, NetProt, OptsClean} =
+	get_port_data(PortIP, Opts),
+    SModule = iolist_to_binary(atom_to_list(Module)),
+    {NumLines, SOptsClean} = term_to_paragraph(OptsClean,
+					       40),
+    ?XE(<<"tr">>,
+	[?XAE(<<"td">>, [{<<"size">>, <<"6">>}], [?C(SPort)]),
+	 ?XAE(<<"td">>, [{<<"size">>, <<"15">>}], [?C(SIP)]),
+	 ?XAE(<<"td">>, [{<<"size">>, <<"4">>}],
+	      [?C((iolist_to_binary(atom_to_list(NetProt))))]),
+	 ?XE(<<"td">>,
+	     [?INPUTS(<<"text">>, <<"module", SSPort/binary>>,
+		      SModule, <<"15">>)]),
+	 ?XAE(<<"td">>, (direction(ltr)),
+	      [?TEXTAREA(<<"opts", SSPort/binary>>,
+			 (integer_to_binary(NumLines)), <<"35">>, SOptsClean)]),
+	 ?XE(<<"td">>,
+	     [?INPUTT(<<"submit">>, <<"add", SSPort/binary>>,
+		      <<"Restart">>)]),
+	 ?XE(<<"td">>,
+	     [?INPUTT(<<"submit">>, <<"delete", SSPort/binary>>,
+		      <<"Stop">>)])]).
+
 make_netprot_html(NetProt) ->
     ?XAE(<<"select">>, [{<<"name">>, <<"netprotnew">>}],
-	 (lists:map(fun (O) ->
-			    Sel = if O == NetProt ->
-					 [{<<"selected">>, <<"selected">>}];
-				     true -> []
-				  end,
-			    ?XAC(<<"option">>, (Sel ++ [{<<"value">>, O}]), O)
-		    end,
-		    [<<"tcp">>, <<"udp">>]))).
+	 [make_netprot_html_1(V1, NetProt)
+	  || V1 <- [<<"tcp">>, <<"udp">>]]).
+
+make_netprot_html_1(O, NetProt) ->
+    Sel = if O == NetProt ->
+		 [{<<"selected">>, <<"selected">>}];
+	     true -> []
+	  end,
+    ?XAC(<<"option">>, (Sel ++ [{<<"value">>, O}]), O).
 
 get_port_data(PortIP, Opts) ->
     {Port, IPT, _IPV, NetProt, OptsClean} =
 	ejabberd_listener:parse_listener_portip(PortIP, Opts),
     IPS = misc:ip_to_list(IPT),
     SPort = integer_to_binary(Port),
-    SSPort = list_to_binary(lists:map(fun (N) ->
-					      io_lib:format("~.16b", [N])
-				      end,
-				      binary_to_list(erlang:md5([SPort, IPS,
-								 atom_to_list(NetProt)])))),
+    SSPort = list_to_binary([get_port_data_1(V1)
+			     || V1
+				    <- binary_to_list(erlang:md5([SPort, IPS,
+								  atom_to_list(NetProt)]))]),
     {Port, SPort, IPT, IPS, SSPort, NetProt, OptsClean}.
 
+get_port_data_1(N) -> io_lib:format("~.16b", [N]).
+
 node_ports_parse_query(Node, Ports, Query) ->
     lists:foreach(fun ({PortIpNetp, Module1, Opts1}) ->
 			  {Port, _SPort, TIP, _SIP, SSPort, NetProt,
@@ -2401,30 +2318,7 @@ node_modules_to_xhtml(Modules, Lang) ->
 		   [?XCT(<<"td">>, <<"Module">>),
 		    ?XCT(<<"td">>, <<"Options">>)])]),
 	  ?XE(<<"tbody">>,
-	      (lists:map(fun ({Module, Opts} = _E) ->
-				 SModule =
-				     iolist_to_binary(atom_to_list(Module)),
-				 {NumLines, SOpts} = term_to_paragraph(Opts,
-								       40),
-				 ?XE(<<"tr">>,
-				     [?XC(<<"td">>, SModule),
-				      ?XAE(<<"td">>, (direction(ltr)),
-					   [?TEXTAREA(<<"opts",
-							SModule/binary>>,
-						      (integer_to_binary(NumLines)),
-						      <<"40">>, SOpts)]),
-				      ?XE(<<"td">>,
-					  [?INPUTT(<<"submit">>,
-						   <<"restart",
-						     SModule/binary>>,
-						   <<"Restart">>)]),
-				      ?XE(<<"td">>,
-					  [?INPUTT(<<"submit">>,
-						   <<"stop", SModule/binary>>,
-						   <<"Stop">>)])])
-			 end,
-			 Modules)
-		 ++
+	      ([node_modules_to_xhtml_1(V1) || V1 <- Modules] ++
 		 [?XE(<<"tr">>,
 		      [?XE(<<"td">>,
 			   [?INPUT(<<"text">>, <<"modulenew">>, <<"">>)]),
@@ -2435,6 +2329,21 @@ node_modules_to_xhtml(Modules, Lang) ->
 			    [?INPUTT(<<"submit">>, <<"start">>,
 				     <<"Start">>)])])]))]).
 
+node_modules_to_xhtml_1({Module, Opts} = _E) ->
+    SModule = iolist_to_binary(atom_to_list(Module)),
+    {NumLines, SOpts} = term_to_paragraph(Opts, 40),
+    ?XE(<<"tr">>,
+	[?XC(<<"td">>, SModule),
+	 ?XAE(<<"td">>, (direction(ltr)),
+	      [?TEXTAREA(<<"opts", SModule/binary>>,
+			 (integer_to_binary(NumLines)), <<"40">>, SOpts)]),
+	 ?XE(<<"td">>,
+	     [?INPUTT(<<"submit">>, <<"restart", SModule/binary>>,
+		      <<"Restart">>)]),
+	 ?XE(<<"td">>,
+	     [?INPUTT(<<"submit">>, <<"stop", SModule/binary>>,
+		      <<"Stop">>)])]).
+
 node_modules_parse_query(Host, Node, Modules, Query) ->
     lists:foreach(fun ({Module, _Opts1}) ->
 			  SModule = iolist_to_binary(atom_to_list(Module)),
@@ -2533,11 +2442,7 @@ pretty_print_xml(#xmlel{name = Name, attrs = Attrs,
 	   AttrPrefix = [Prefix,
 			 str:copies(<<" ">>, byte_size(Name) + 2)],
 	   [$ , Attr, $=, $', fxml:crypt(Val), $',
-	    lists:map(fun ({Attr1, Val1}) ->
-			      [$\n, AttrPrefix, Attr1, $=, $', fxml:crypt(Val1),
-			       $']
-		      end,
-		      RestAttrs)]
+	    [pretty_print_xml_1(V1, AttrPrefix) || V1 <- RestAttrs]]
      end,
      if Els == [] -> <<"/>\n">>;
 	true ->
@@ -2548,15 +2453,17 @@ pretty_print_xml(#xmlel{name = Name, attrs = Attrs,
 	    if OnlyCData ->
 		   [$>, fxml:get_cdata(Els), $<, $/, Name, $>, $\n];
 	       true ->
-		   [$>, $\n,
-		    lists:map(fun (E) ->
-				      pretty_print_xml(E, [Prefix, <<"  ">>])
-			      end,
-			      Els),
+		   [$>, $\n, [pretty_print_xml_2(V2, Prefix) || V2 <- Els],
 		    Prefix, $<, $/, Name, $>, $\n]
 	    end
      end].
 
+pretty_print_xml_1({Attr1, Val1}, AttrPrefix) ->
+    [$\n, AttrPrefix, Attr1, $=, $', fxml:crypt(Val1), $'].
+
+pretty_print_xml_2(E, Prefix) ->
+    pretty_print_xml(E, [Prefix, <<"  ">>]).
+
 element_to_list(X) when is_atom(X) ->
     iolist_to_binary(atom_to_list(X));
 element_to_list(X) when is_integer(X) ->
diff --git a/src/ejabberd_xmlrpc.erl b/src/ejabberd_xmlrpc.erl
index 0431be0..5c689df 100644
--- a/src/ejabberd_xmlrpc.erl
+++ b/src/ejabberd_xmlrpc.erl
@@ -502,32 +502,29 @@ make_status(_) -> 1.
 
 transform_listen_option({access_commands, ACOpts},
 			Opts) ->
-    NewACOpts = lists:map(fun ({AName, ACmds, AOpts}) ->
-				  {AName,
-				   [{commands, ACmds}, {options, AOpts}]};
-			      (Opt) -> Opt
-			  end,
-			  ACOpts),
+    NewACOpts = [transform_listen_option_1(V1)
+		 || V1 <- ACOpts],
     [{access_commands, NewACOpts} | Opts];
 transform_listen_option(Opt, Opts) -> [Opt | Opts].
 
+transform_listen_option_1({AName, ACmds, AOpts}) ->
+    {AName, [{commands, ACmds}, {options, AOpts}]};
+transform_listen_option_1(Opt) -> Opt.
+
 listen_opt_type(access_commands) ->
     fun (Opts) ->
-	    lists:map(fun ({Ac, AcOpts}) ->
-			      Commands = case proplists:get_value(commands,
-								  lists:flatten(AcOpts),
-								  all)
-					     of
-					   Cmd when is_atom(Cmd) -> Cmd;
-					   Cmds when is_list(Cmds) ->
-					       true = lists:all(fun is_atom/1,
-								Cmds),
-					       Cmds
-					 end,
-			      {<<"ejabberd_xmlrpc compatibility shim">>,
-			       {[?MODULE], [{access, Ac}], Commands}}
-		      end,
-		      lists:flatten(Opts))
+	    [listen_opt_type_1(V1) || V1 <- lists:flatten(Opts)]
     end.
 
+listen_opt_type_1({Ac, AcOpts}) ->
+    Commands = case proplists:get_value(commands,
+					lists:flatten(AcOpts), all)
+		   of
+		 Cmd when is_atom(Cmd) -> Cmd;
+		 Cmds when is_list(Cmds) ->
+		     true = lists:all(fun is_atom/1, Cmds), Cmds
+	       end,
+    {<<"ejabberd_xmlrpc compatibility shim">>,
+     {[?MODULE], [{access, Ac}], Commands}}.
+
 listen_options() -> [{access_commands, []}].
diff --git a/src/ejd2sql.erl b/src/ejd2sql.erl
index 470cd18..47ccee9 100644
--- a/src/ejd2sql.erl
+++ b/src/ejd2sql.erl
@@ -137,11 +137,11 @@ import(Mod, Server, Dir, ToType) ->
 
 import_info(Mod) ->
     Info = Mod:import_info(),
-    lists:map(fun ({Tab, FieldsNum}) ->
-		      FileName = <<Tab/binary, ".txt">>,
-		      {FileName, Tab, Mod, FieldsNum}
-	      end,
-	      Info).
+    [import_info_1(V1, Mod) || V1 <- Info].
+
+import_info_1({Tab, FieldsNum}, Mod) ->
+    FileName = <<Tab/binary, ".txt">>,
+    {FileName, Tab, Mod, FieldsNum}.
 
 %%%----------------------------------------------------------------------
 %%% Internal functions
@@ -341,8 +341,8 @@ format_error({error, Posix}) ->
     file:format_error(Posix).
 
 format_queries(SQLs) ->
-    lists:map(fun (#sql_query{} = SQL) ->
-		      ejabberd_sql:sql_query_to_iolist(SQL);
-		  (SQL) -> SQL
-	      end,
-	      SQLs).
+    [format_queries_1(V1) || V1 <- SQLs].
+
+format_queries_1(#sql_query{} = SQL) ->
+    ejabberd_sql:sql_query_to_iolist(SQL);
+format_queries_1(SQL) -> SQL.
diff --git a/src/eldap.erl b/src/eldap.erl
index 9ac2d3d..d1230fc 100644
--- a/src/eldap.erl
+++ b/src/eldap.erl
@@ -1298,14 +1298,14 @@ do_lookup([], [], Err) -> Err;
 do_lookup([], AddrFamilies, _Err) -> {ok, AddrFamilies}.
 
 host_entry_to_addrs(#hostent{h_addr_list = AddrList}) ->
-    lists:filter(fun (Addr) ->
-			 try get_addr_type(Addr) of
-			   _ -> true
-			 catch
-			   _:badarg -> false
-			 end
-		 end,
-		 AddrList).
+    [V1 || V1 <- AddrList, host_entry_to_addrs_1(V1)].
+
+host_entry_to_addrs_1(Addr) ->
+    try get_addr_type(Addr) of
+      _ -> true
+    catch
+      _:badarg -> false
+    end.
 
 get_addr_type({_, _, _, _}) -> inet;
 get_addr_type({_, _, _, _, _, _, _, _}) -> inet6;
diff --git a/src/eldap_utils.erl b/src/eldap_utils.erl
index 31ea54b..854cee8 100644
--- a/src/eldap_utils.erl
+++ b/src/eldap_utils.erl
@@ -75,15 +75,16 @@ find_ldap_attrs([], _) -> <<>>.
 
 
 get_ldap_attr(LDAPAttr, Attributes) ->
-    Res = lists:filter(fun ({Name, _}) ->
-			       case_insensitive_match(Name, LDAPAttr)
-		       end,
-		       Attributes),
+    Res = [V1
+	   || V1 <- Attributes, get_ldap_attr_1(V1, LDAPAttr)],
     case Res of
       [{_, [Value | _]}] -> Value;
       _ -> <<>>
     end.
 
+get_ldap_attr_1({Name, _}, LDAPAttr) ->
+    case_insensitive_match(Name, LDAPAttr).
+
 - spec ( { { get_user_part , 2 } , [ { type , 85 , 'fun' , [ { type , 85 , product , [ { type , 85 , binary , [ ] } , { type , 85 , binary , [ ] } ] } , { type , 85 , union , [ { type , 85 , tuple , [ { atom , 85 , ok } , { type , 85 , binary , [ ] } ] } , { type , 85 , tuple , [ { atom , 85 , error } , { atom , 85 , badmatch } ] } ] } ] } ] } ) .
 
 
@@ -165,11 +166,11 @@ get_state(Server, Module) ->
 
 
 uids_domain_subst(Host, UIDs) ->
-    lists:map(fun ({U, V}) ->
-		      {U, eldap_filter:do_sub(V, [{<<"%d">>, Host}])};
-		  (A) -> A
-	      end,
-	      UIDs).
+    [uids_domain_subst_1(V1, Host) || V1 <- UIDs].
+
+uids_domain_subst_1({U, V}, Host) ->
+    {U, eldap_filter:do_sub(V, [{<<"%d">>, Host}])};
+uids_domain_subst_1(A, Host) -> A.
 
 - spec ( { { get_config , 2 } , [ { type , 173 , 'fun' , [ { type , 173 , product , [ { type , 173 , binary , [ ] } , { type , 173 , list , [ ] } ] } , { type , 173 , eldap_config , [ ] } ] } ] } ) .
 
@@ -408,13 +409,7 @@ opt_type(ldap_filter) ->
 	(F) -> check_filter(F)
     end;
 opt_type(ldap_uids) ->
-    fun (Us) ->
-	    lists:map(fun ({U, P}) ->
-			      {iolist_to_binary(U), iolist_to_binary(P)};
-			  ({U}) -> {iolist_to_binary(U)};
-			  (U) -> {iolist_to_binary(U)}
-		      end,
-		      lists:flatten(Us))
+    fun (Us) -> [opt_type_1(V1) || V1 <- lists:flatten(Us)]
     end;
 opt_type(_) ->
     [deref_aliases, ldap_backups, ldap_base, ldap_uids,
@@ -423,6 +418,11 @@ opt_type(_) ->
      ldap_tls_certfile, ldap_tls_cacertfile, ldap_tls_depth,
      ldap_tls_verify].
 
+opt_type_1({U, P}) ->
+    {iolist_to_binary(U), iolist_to_binary(P)};
+opt_type_1({U}) -> {iolist_to_binary(U)};
+opt_type_1(U) -> {iolist_to_binary(U)}.
+
 options(_) ->
     [{deref_aliases, unspecified}, {ldap_backups, []},
      {ldap_base, <<"">>},
diff --git a/src/extauth_sup.erl b/src/extauth_sup.erl
index 3b34ba7..fe1523d 100644
--- a/src/extauth_sup.erl
+++ b/src/extauth_sup.erl
@@ -100,13 +100,13 @@ start_link(Host, Prog, Pool) ->
 %%%===================================================================
 init([Host, Prog, Pool]) ->
     PoolSize = extauth:pool_size(Host),
-    Children = lists:map(fun (I) ->
-				 worker_spec(Pool, Prog, I)
-			 end,
-			 lists:seq(1, PoolSize)),
+    Children = [init_1(V1, Pool, Prog)
+		|| V1 <- lists:seq(1, PoolSize)],
     put(extauth_program, Prog),
     {ok, {{one_for_one, PoolSize, 1}, Children}}.
 
+init_1(I, Pool, Prog) -> worker_spec(Pool, Prog, I).
+
 %%%===================================================================
 %%% Internal functions
 %%%===================================================================
diff --git a/src/gen_iq_handler.erl b/src/gen_iq_handler.erl
index c618285..ae153e4 100644
--- a/src/gen_iq_handler.erl
+++ b/src/gen_iq_handler.erl
@@ -182,10 +182,11 @@ iqdisc(_Host) -> no_queue.
 
 
 transform_module_options(Opts) ->
-    lists:map(fun ({iqdisc, {queues, N}}) -> {iqdisc, N};
-		  (Opt) -> Opt
-	      end,
-	      Opts).
+    [transform_module_options_1(V1) || V1 <- Opts].
+
+transform_module_options_1({iqdisc, {queues, N}}) ->
+    {iqdisc, N};
+transform_module_options_1(Opt) -> Opt.
 
 - spec ( { { opt_type , 1 } , [ { type , 157 , 'fun' , [ { type , 157 , product , [ { type , 157 , atom , [ ] } ] } , { type , 157 , union , [ { type , 157 , 'fun' , [ { type , 157 , product , [ { type , 157 , any , [ ] } ] } , { type , 157 , any , [ ] } ] } , { type , 157 , list , [ { type , 157 , atom , [ ] } ] } ] } ] } ] } ) .
 
diff --git a/src/gen_mod.erl b/src/gen_mod.erl
index ee9edae..8178987 100644
--- a/src/gen_mod.erl
+++ b/src/gen_mod.erl
@@ -480,11 +480,9 @@ get_module_opt(Host, Module, Opt, F)
     get_module_opt(Host, Module, Opt, undefined);
 get_module_opt(global, Module, Opt, Default) ->
     Hosts = ejabberd_config:get_myhosts(),
-    [Value | Values] = lists:map(fun (Host) ->
-					 get_module_opt(Host, Module, Opt,
-							Default)
-				 end,
-				 Hosts),
+    [Value | Values] = [get_module_opt_1(V1, Default,
+					 Module, Opt)
+			|| V1 <- Hosts],
     Same_all = lists:all(fun (Other_value) ->
 				 Other_value == Value
 			 end,
@@ -501,6 +499,9 @@ get_module_opt(Host, Module, Opt, Default) ->
 	  get_opt(Opt, Opts, Default)
     end.
 
+get_module_opt_1(Host, Default, Module, Opt) ->
+    get_module_opt(Host, Module, Opt, Default).
+
 - spec ( { { get_module_opt , 5 } , [ { type , 442 , 'fun' , [ { type , 442 , product , [ { type , 442 , union , [ { atom , 442 , global } , { type , 442 , binary , [ ] } ] } , { type , 442 , atom , [ ] } , { type , 442 , atom , [ ] } , { type , 442 , check_fun , [ ] } , { type , 442 , any , [ ] } ] } , { type , 442 , any , [ ] } ] } ] } ) .
 
 
@@ -1069,10 +1070,8 @@ is_opt_list(_) -> false.
 
 
 opt_type(modules) ->
-    fun (Mods) ->
-	    lists:map(fun ({M, A}) when is_atom(M) ->
-			      true = is_opt_list(A), {M, A}
-		      end,
-		      Mods)
-    end;
+    fun (Mods) -> [opt_type_1(V1) || V1 <- Mods] end;
 opt_type(_) -> [modules].
+
+opt_type_1({M, A}) when is_atom(M) ->
+    true = is_opt_list(A), {M, A}.
diff --git a/src/jd2ejd.erl b/src/jd2ejd.erl
index 9df07f2..e2944cd 100644
--- a/src/jd2ejd.erl
+++ b/src/jd2ejd.erl
@@ -75,15 +75,7 @@ import_file(File) ->
 
 import_dir(Dir) ->
     {ok, Files} = file:list_dir(Dir),
-    MsgFiles = lists:filter(fun (FN) ->
-				    case length(FN) > 4 of
-				      true ->
-					  string:substr(FN, length(FN) - 3) ==
-					    ".xml";
-				      _ -> false
-				    end
-			    end,
-			    Files),
+    MsgFiles = [V1 || V1 <- Files, import_dir_1(V1)],
     lists:foldl(fun (FN, A) ->
 			Res = import_file(filename:join([Dir, FN])),
 			case {A, Res} of
@@ -95,6 +87,12 @@ import_dir(Dir) ->
 		end,
 		ok, MsgFiles).
 
+import_dir_1(FN) ->
+    case length(FN) > 4 of
+      true -> string:substr(FN, length(FN) - 3) == ".xml";
+      _ -> false
+    end.
+
 %%%----------------------------------------------------------------------
 %%% Internal functions
 %%%----------------------------------------------------------------------
@@ -136,13 +134,7 @@ xdb_data(User, Server, #xmlel{attrs = Attrs} = El) ->
       XMLNS ->
 	  case fxml:get_attr_s(<<"j_private_flag">>, Attrs) of
 	    <<"1">> ->
-		NewAttrs = lists:filter(fun ({<<"j_private_flag">>,
-					      _}) ->
-						false;
-					    ({<<"xdbns">>, _}) -> false;
-					    (_) -> true
-					end,
-					Attrs),
+		NewAttrs = [V1 || V1 <- Attrs, xdb_data_1(V1)],
 		catch mod_private:set_data(LUser, LServer,
 					   [{XMLNS,
 					     El#xmlel{attrs = NewAttrs}}]);
@@ -152,6 +144,10 @@ xdb_data(User, Server, #xmlel{attrs = Attrs} = El) ->
 	  ok
     end.
 
+xdb_data_1({<<"j_private_flag">>, _}) -> false;
+xdb_data_1({<<"xdbns">>, _}) -> false;
+xdb_data_1(_) -> true.
+
 process_offline(Server, To, #xmlel{children = Els}) ->
     LServer = jid:nameprep(Server),
     lists:foreach(fun (#xmlel{} = El) ->
diff --git a/src/misc.erl b/src/misc.erl
index d4edbd0..6e5a510 100644
--- a/src/misc.erl
+++ b/src/misc.erl
@@ -281,13 +281,7 @@ decode_pid(PidBin, NodeBin) ->
 
 
 compile_exprs(Mod, Exprs) ->
-    try Forms = lists:map(fun (Expr) ->
-				  {ok, Tokens, _} =
-				      erl_scan:string(lists:flatten(Expr)),
-				  {ok, Form} = erl_parse:parse_form(Tokens),
-				  Form
-			  end,
-			  Exprs),
+    try Forms = [compile_exprs_1(V1) || V1 <- Exprs],
 	{ok, Code} = case compile:forms(Forms, []) of
 		       {ok, Mod, Bin} -> {ok, Bin};
 		       {ok, Mod, Bin, _Warnings} -> {ok, Bin};
@@ -302,6 +296,11 @@ compile_exprs(Mod, Exprs) ->
       _:{badmatch, error} -> {error, compile_failed}
     end.
 
+compile_exprs_1(Expr) ->
+    {ok, Tokens, _} = erl_scan:string(lists:flatten(Expr)),
+    {ok, Form} = erl_parse:parse_form(Tokens),
+    Form.
+
 - spec ( { { join_atoms , 2 } , [ { type , 277 , 'fun' , [ { type , 277 , product , [ { type , 277 , list , [ { type , 277 , atom , [ ] } ] } , { type , 277 , binary , [ ] } ] } , { type , 277 , binary , [ ] } ] } ] } ) .
 
 
@@ -417,7 +416,9 @@ get_descr(Lang, Text) ->
 
 
 intersection(L1, L2) ->
-    lists:filter(fun (E) -> lists:member(E, L2) end, L1).
+    [V1 || V1 <- L1, intersection_1(V1, L2)].
+
+intersection_1(E, L2) -> lists:member(E, L2).
 
 - spec ( { { format_val , 1 } , [ { type , 371 , 'fun' , [ { type , 371 , product , [ { type , 371 , any , [ ] } ] } , { type , 371 , iodata , [ ] } ] } ] } ) .
 
diff --git a/src/mod_admin_extra.erl b/src/mod_admin_extra.erl
index af3e56d..4d1a117 100644
--- a/src/mod_admin_extra.erl
+++ b/src/mod_admin_extra.erl
@@ -1007,9 +1007,8 @@ check_password(User, Host, Password) ->
 check_password_hash(User, Host, PasswordHash,
 		    HashMethod) ->
     AccountPass = ejabberd_auth:get_password_s(User, Host),
-    Methods = lists:map(fun (A) -> atom_to_binary(A, latin1)
-			end,
-			proplists:get_value(hashs, crypto:supports())),
+    Methods = [check_password_hash_1(V1)
+	       || V1 <- proplists:get_value(hashs, crypto:supports())],
     MethodAllowed = lists:member(HashMethod, Methods),
     AccountPassHash = case {AccountPass, MethodAllowed} of
 			{A, _} when is_tuple(A) -> scrammed;
@@ -1031,6 +1030,8 @@ check_password_hash(User, Host, PasswordHash,
       _ -> false
     end.
 
+check_password_hash_1(A) -> atom_to_binary(A, latin1).
+
 get_hash(AccountPass, Method) ->
     iolist_to_binary([io_lib:format("~2.16.0B", [X])
 		      || X
@@ -1087,10 +1088,11 @@ ban_account(User, Host, ReasonText) ->
     ok.
 
 kick_sessions(User, Server, Reason) ->
-    lists:map(fun (Resource) ->
-		      kick_this_session(User, Server, Resource, Reason)
-	      end,
-	      ejabberd_sm:get_user_resources(User, Server)).
+    [kick_sessions_1(V1, Reason, Server, User)
+     || V1 <- ejabberd_sm:get_user_resources(User, Server)].
+
+kick_sessions_1(Resource, Reason, Server, User) ->
+    kick_this_session(User, Server, Resource, Reason).
 
 set_random_password(User, Server, Reason) ->
     NewPass = build_random_password(Reason),
@@ -1185,12 +1187,13 @@ get_status_list(Host, Status_required) ->
 	Fstatus(Status, Status_required)].
 
 connected_users_info() ->
-    lists:map(fun ({U, S, R}) ->
-		      Info = user_session_info(U, S, R),
-		      Jid = jid:encode(jid:make(U, S, R)),
-		      erlang:insert_element(1, Info, Jid)
-	      end,
-	      ejabberd_sm:dirty_get_sessions_list()).
+    [connected_users_info_1(V1)
+     || V1 <- ejabberd_sm:dirty_get_sessions_list()].
+
+connected_users_info_1({U, S, R}) ->
+    Info = user_session_info(U, S, R),
+    Jid = jid:encode(jid:make(U, S, R)),
+    erlang:insert_element(1, Info, Jid).
 
 connected_users_vhost(Host) ->
     USRs = ejabberd_sm:get_vh_session_list(Host),
diff --git a/src/mod_avatar.erl b/src/mod_avatar.erl
index 3443190..75b2eeb 100644
--- a/src/mod_avatar.erl
+++ b/src/mod_avatar.erl
@@ -124,10 +124,7 @@ vcard_iq_publish(#iq{sub_els =
 	  case lists:keyfind(SHA1, #avatar_info.id, Info) of
 	    #avatar_info{} -> IQ;
 	    false ->
-		Info1 = lists:filter(fun (#avatar_info{url = URL}) ->
-					     URL /= <<"">>
-				     end,
-				     Info),
+		Info1 = [V1 || V1 <- Info, vcard_iq_publish_1(V1)],
 		Meta1 = Meta#avatar_meta{info = Info1},
 		publish_avatar(IQ, Meta1, MimeType, Data, SHA1)
 	  end;
@@ -136,6 +133,9 @@ vcard_iq_publish(#iq{sub_els =
     end;
 vcard_iq_publish(Acc) -> Acc.
 
+vcard_iq_publish_1(#avatar_info{url = URL}) ->
+    URL /= <<"">>.
+
 - spec ( { { get_sm_features , 5 } , [ { type , 154 , 'fun' , [ { type , 154 , product , [ { type , 154 , union , [ { type , 154 , tuple , [ { atom , 154 , error } , { type , 154 , stanza_error , [ ] } ] } , { atom , 154 , empty } , { type , 154 , tuple , [ { atom , 154 , result } , { type , 154 , list , [ { type , 154 , binary , [ ] } ] } ] } ] } , { type , 155 , jid , [ ] } , { type , 155 , jid , [ ] } , { type , 155 , binary , [ ] } , { type , 155 , binary , [ ] } ] } , { type , 156 , union , [ { type , 156 , tuple , [ { atom , 156 , error } , { type , 156 , stanza_error , [ ] } ] } , { atom , 156 , empty } , { type , 156 , tuple , [ { atom , 156 , result } , { type , 156 , list , [ { type , 156 , binary , [ ] } ] } ] } ] } ] } ] } ) .
 
 
diff --git a/src/mod_blocking.erl b/src/mod_blocking.erl
index 723e7b2..2453624 100644
--- a/src/mod_blocking.erl
+++ b/src/mod_blocking.erl
@@ -200,10 +200,7 @@ process_unblock_all(#iq{from = From} = IQ) ->
     case mod_privacy:get_user_list(LUser, LServer, default)
 	of
       {ok, {Name, List}} ->
-	  NewList = lists:filter(fun (#listitem{action = A}) ->
-					 A /= deny
-				 end,
-				 List),
+	  NewList = [V1 || V1 <- List, process_unblock_all_1(V1)],
 	  case mod_privacy:set_list(LUser, LServer, Name, NewList)
 	      of
 	    ok ->
@@ -218,6 +215,9 @@ process_unblock_all(#iq{from = From} = IQ) ->
       {error, _} -> err_db_failure(IQ)
     end.
 
+process_unblock_all_1(#listitem{action = A}) ->
+    A /= deny.
+
 - spec ( { { process_unblock , 2 } , [ { type , 206 , 'fun' , [ { type , 206 , product , [ { type , 206 , iq , [ ] } , { type , 206 , list , [ { type , 206 , ljid , [ ] } ] } ] } , { type , 206 , iq , [ ] } ] } ] } ) .
 
 
@@ -226,12 +226,8 @@ process_unblock(#iq{from = From} = IQ, LJIDs) ->
     case mod_privacy:get_user_list(LUser, LServer, default)
 	of
       {ok, {Name, List}} ->
-	  NewList = lists:filter(fun (#listitem{action = deny,
-						type = jid, value = LJID}) ->
-					 not lists:member(LJID, LJIDs);
-				     (_) -> true
-				 end,
-				 List),
+	  NewList = [V1
+		     || V1 <- List, process_unblock_1(V1, LJIDs)],
 	  case mod_privacy:set_list(LUser, LServer, Name, NewList)
 	      of
 	    ok ->
@@ -250,6 +246,12 @@ process_unblock(#iq{from = From} = IQ, LJIDs) ->
       {error, _} -> err_db_failure(IQ)
     end.
 
+process_unblock_1(#listitem{action = deny, type = jid,
+			    value = LJID},
+		  LJIDs) ->
+    not lists:member(LJID, LJIDs);
+process_unblock_1(_, LJIDs) -> true.
+
 - spec ( { { broadcast_event , 2 } , [ { type , 237 , 'fun' , [ { type , 237 , product , [ { type , 237 , jid , [ ] } , { type , 237 , union , [ { type , 237 , block , [ ] } , { type , 237 , unblock , [ ] } ] } ] } , { atom , 237 , ok } ] } ] } ) .
 
 
diff --git a/src/mod_caps.erl b/src/mod_caps.erl
index 656ec34..0bc2fb6 100644
--- a/src/mod_caps.erl
+++ b/src/mod_caps.erl
@@ -409,16 +409,16 @@ make_my_disco_hash(Host) ->
 				  [Host, undefined, <<"">>, <<"">>])}
 	of
       {{result, Features}, Identities, Info} ->
-	  Feats = lists:map(fun ({{Feat, _Host}}) -> Feat;
-				(Feat) -> Feat
-			    end,
-			    Features),
+	  Feats = [make_my_disco_hash_1(V1) || V1 <- Features],
 	  DiscoInfo = #disco_info{identities = Identities,
 				  features = Feats, xdata = Info},
 	  compute_disco_hash(DiscoInfo, sha);
       _Err -> <<"">>
     end.
 
+make_my_disco_hash_1({{Feat, _Host}}) -> Feat;
+make_my_disco_hash_1(Feat) -> Feat.
+
 -type({digest_type,
        {type, 419, union,
 	[{atom, 419, md5}, {atom, 419, sha},
diff --git a/src/mod_configure.erl b/src/mod_configure.erl
index 6356635..c0aee68 100644
--- a/src/mod_configure.erl
+++ b/src/mod_configure.erl
@@ -325,11 +325,12 @@ get_sm_items(Acc, From,
 
 get_user_resources(User, Server) ->
     Rs = ejabberd_sm:get_user_resources(User, Server),
-    lists:map(fun (R) ->
-		      #disco_item{jid = jid:make(User, Server, R),
-				  name = User}
-	      end,
-	      lists:sort(Rs)).
+    [get_user_resources_1(V1, Server, User)
+     || V1 <- lists:sort(Rs)].
+
+get_user_resources_1(R, Server, User) ->
+    #disco_item{jid = jid:make(User, Server, R),
+		name = User}.
 
 %%%-----------------------------------------------------------------------
 
@@ -347,19 +348,21 @@ adhoc_local_items(Acc, From,
 	  PermLev = get_permission_level(From),
 	  Nodes = recursively_get_local_items(PermLev, LServer,
 					      <<"">>, Server, Lang),
-	  Nodes1 = lists:filter(fun (#disco_item{node = Nd}) ->
-					F = get_local_features([], From, To, Nd,
-							       Lang),
-					case F of
-					  {result, [?NS_COMMANDS]} -> true;
-					  _ -> false
-					end
-				end,
-				Nodes),
+	  Nodes1 = [V1
+		    || V1 <- Nodes,
+		       adhoc_local_items_1(V1, From, Lang, To)],
 	  {result, Items ++ Nodes1};
       _ -> Acc
     end.
 
+adhoc_local_items_1(#disco_item{node = Nd}, From, Lang,
+		    To) ->
+    F = get_local_features([], From, To, Nd, Lang),
+    case F of
+      {result, [?NS_COMMANDS]} -> true;
+      _ -> false
+    end.
+
 recursively_get_local_items(_PermLev, _LServer,
 			    <<"online users">>, _Server, _Lang) ->
     [];
@@ -375,21 +378,21 @@ recursively_get_local_items(PermLev, LServer, Node,
 	      {result, Res} -> Res;
 	      {error, _Error} -> []
 	    end,
-    lists:flatten(lists:map(fun (#disco_item{jid =
-						 #jid{server = S},
-					     node = Nd} =
-				     Item) ->
-				    if (S /= Server) or (Nd == <<"">>) -> [];
-				       true ->
-					   [Item,
-					    recursively_get_local_items(PermLev,
-									LServer,
-									Nd,
-									Server,
-									Lang)]
-				    end
-			    end,
-			    Items)).
+    lists:flatten([recursively_get_local_items_1(V1,
+						 LServer, Lang, PermLev, Server)
+		   || V1 <- Items]).
+
+recursively_get_local_items_1(#disco_item{jid =
+					      #jid{server = S},
+					  node = Nd} =
+				  Item,
+			      LServer, Lang, PermLev, Server) ->
+    if (S /= Server) or (Nd == <<"">>) -> [];
+       true ->
+	   [Item,
+	    recursively_get_local_items(PermLev, LServer, Nd,
+					Server, Lang)]
+    end.
 
 get_permission_level(JID) ->
     case acl:match_rule(global, configure, JID) of
@@ -564,12 +567,7 @@ get_local_items({_, Host},
 	N1 = binary_to_integer(S1),
 	N2 = binary_to_integer(S2),
 	Sub = lists:sublist(SUsers, N1, N2 - N1 + 1),
-	{result,
-	 lists:map(fun ({S, U}) ->
-			   #disco_item{jid = jid:make(U, S),
-				       name = <<U/binary, $@, S/binary>>}
-		   end,
-		   Sub)}
+	{result, [get_local_items_1(V1) || V1 <- Sub]}
     catch
       _:_ -> xmpp:err_not_acceptable()
     end;
@@ -659,18 +657,22 @@ get_local_items(_Host,
 get_local_items(_Host, _, _Server, _Lang) ->
     {error, xmpp:err_item_not_found()}.
 
+get_local_items_1({S, U}) ->
+    #disco_item{jid = jid:make(U, S),
+		name = <<U/binary, $@, S/binary>>}.
+
 get_online_vh_users(Host) ->
     case catch ejabberd_sm:get_vh_session_list(Host) of
       {'EXIT', _Reason} -> [];
       USRs ->
 	  SURs = lists:sort([{S, U, R} || {U, S, R} <- USRs]),
-	  lists:map(fun ({S, U, R}) ->
-			    #disco_item{jid = jid:make(U, S, R),
-					name = <<U/binary, "@", S/binary>>}
-		    end,
-		    SURs)
+	  [get_online_vh_users_1(V1) || V1 <- SURs]
     end.
 
+get_online_vh_users_1({S, U, R}) ->
+    #disco_item{jid = jid:make(U, S, R),
+		name = <<U/binary, "@", S/binary>>}.
+
 get_all_vh_users(Host) ->
     case catch ejabberd_auth:get_users(Host) of
       {'EXIT', _Reason} -> [];
@@ -678,34 +680,33 @@ get_all_vh_users(Host) ->
 	  SUsers = lists:sort([{S, U} || {U, S} <- Users]),
 	  case length(SUsers) of
 	    N when N =< 100 ->
-		lists:map(fun ({S, U}) ->
-				  #disco_item{jid = jid:make(U, S),
-					      name = <<U/binary, $@, S/binary>>}
-			  end,
-			  SUsers);
+		[get_all_vh_users_1(V1) || V1 <- SUsers];
 	    N ->
 		NParts = trunc(math:sqrt(N * 6.17999999999999993783e-1))
 			   + 1,
 		M = trunc(N / NParts) + 1,
-		lists:map(fun (K) ->
-				  L = K + M - 1,
-				  Node = <<"@", (integer_to_binary(K))/binary,
-					   "-", (integer_to_binary(L))/binary>>,
-				  {FS, FU} = lists:nth(K, SUsers),
-				  {LS, LU} = if L < N -> lists:nth(L, SUsers);
-						true -> lists:last(SUsers)
-					     end,
-				  Name = <<FU/binary, "@", FS/binary, " -- ",
-					   LU/binary, "@", LS/binary>>,
-				  #disco_item{jid = jid:make(Host),
-					      node =
-						  <<"all users/", Node/binary>>,
-					      name = Name}
-			  end,
-			  lists:seq(1, N, M))
+		[get_all_vh_users_1(V2, Host, M, N, SUsers)
+		 || V2 <- lists:seq(1, N, M)]
 	  end
     end.
 
+get_all_vh_users_1({S, U}) ->
+    #disco_item{jid = jid:make(U, S),
+		name = <<U/binary, $@, S/binary>>}.
+
+get_all_vh_users_1(K, Host, M, N, SUsers) ->
+    L = K + M - 1,
+    Node = <<"@", (integer_to_binary(K))/binary, "-",
+	     (integer_to_binary(L))/binary>>,
+    {FS, FU} = lists:nth(K, SUsers),
+    {LS, LU} = if L < N -> lists:nth(L, SUsers);
+		  true -> lists:last(SUsers)
+	       end,
+    Name = <<FU/binary, "@", FS/binary, " -- ", LU/binary,
+	     "@", LS/binary>>,
+    #disco_item{jid = jid:make(Host),
+		node = <<"all users/", Node/binary>>, name = Name}.
+
 get_outgoing_s2s(Host, Lang) ->
     case catch ejabberd_s2s:dirty_get_connections() of
       {'EXIT', _Reason} -> [];
@@ -714,45 +715,48 @@ get_outgoing_s2s(Host, Lang) ->
 	  TConns = [TH
 		    || {FH, TH} <- Connections,
 		       Host == FH orelse str:suffix(DotHost, FH)],
-	  lists:map(fun (T) ->
-			    Name = str:format(?T(Lang, <<"To ~s">>), [T]),
-			    #disco_item{jid = jid:make(Host),
-					node = <<"outgoing s2s/", T/binary>>,
-					name = Name}
-		    end,
-		    lists:usort(TConns))
+	  [get_outgoing_s2s_1(V1, Host, Lang)
+	   || V1 <- lists:usort(TConns)]
     end.
 
+get_outgoing_s2s_1(T, Host, Lang) ->
+    Name = str:format(?T(Lang, <<"To ~s">>), [T]),
+    #disco_item{jid = jid:make(Host),
+		node = <<"outgoing s2s/", T/binary>>, name = Name}.
+
 get_outgoing_s2s(Host, Lang, To) ->
     case catch ejabberd_s2s:dirty_get_connections() of
       {'EXIT', _Reason} -> [];
       Connections ->
-	  lists:map(fun ({F, _T}) ->
-			    Node = <<"outgoing s2s/", To/binary, "/",
-				     F/binary>>,
-			    Name = str:format(?T(Lang, <<"From ~s">>), [F]),
-			    #disco_item{jid = jid:make(Host), node = Node,
-					name = Name}
-		    end,
-		    lists:keysort(1,
-				  lists:filter(fun (E) -> element(2, E) == To
-					       end,
-					       Connections)))
+	  [get_outgoing_s2s_1(V2, Host, Lang, To)
+	   || V2
+		  <- lists:keysort(1,
+				   [V1
+				    || V1 <- Connections,
+				       get_outgoing_s2s_1(V1, To)])]
     end.
 
+get_outgoing_s2s_1(E, To) -> element(2, E) == To.
+
+get_outgoing_s2s_1({F, _T}, Host, Lang, To) ->
+    Node = <<"outgoing s2s/", To/binary, "/", F/binary>>,
+    Name = str:format(?T(Lang, <<"From ~s">>), [F]),
+    #disco_item{jid = jid:make(Host), node = Node,
+		name = Name}.
+
 get_running_nodes(Server, _Lang) ->
     case catch mnesia:system_info(running_db_nodes) of
       {'EXIT', _Reason} -> [];
       DBNodes ->
-	  lists:map(fun (N) ->
-			    S = iolist_to_binary(atom_to_list(N)),
-			    #disco_item{jid = jid:make(Server),
-					node = <<"running nodes/", S/binary>>,
-					name = S}
-		    end,
-		    lists:sort(DBNodes))
+	  [get_running_nodes_1(V1, Server)
+	   || V1 <- lists:sort(DBNodes)]
     end.
 
+get_running_nodes_1(N, Server) ->
+    S = iolist_to_binary(atom_to_list(N)),
+    #disco_item{jid = jid:make(Server),
+		node = <<"running nodes/", S/binary>>, name = S}.
+
 get_stopped_nodes(_Lang) ->
     case catch lists:usort(mnesia:system_info(db_nodes) ++
 			     mnesia:system_info(extra_db_nodes))
@@ -760,16 +764,15 @@ get_stopped_nodes(_Lang) ->
 	of
       {'EXIT', _Reason} -> [];
       DBNodes ->
-	  lists:map(fun (N) ->
-			    S = iolist_to_binary(atom_to_list(N)),
-			    #disco_item{jid =
-					    jid:make(ejabberd_config:get_myname()),
-					node = <<"stopped nodes/", S/binary>>,
-					name = S}
-		    end,
-		    lists:sort(DBNodes))
+	  [get_stopped_nodes_1(V1) || V1 <- lists:sort(DBNodes)]
     end.
 
+get_stopped_nodes_1(N) ->
+    S = iolist_to_binary(atom_to_list(N)),
+    #disco_item{jid =
+		    jid:make(ejabberd_config:get_myname()),
+		node = <<"stopped nodes/", S/binary>>, name = S}.
+
 %%-------------------------------------------------------------------------
 
 -define(COMMANDS_RESULT(LServerOrGlobal, From, To,
@@ -905,18 +908,7 @@ get_form(_Host, [<<"running nodes">>, ENode, <<"DB">>],
 			      <<"Database Tables Configuration at ">>))/binary,
 			  ENode/binary>>,
 		Instr = (?T(Lang, <<"Choose storage type of tables">>)),
-		try Fs = lists:map(fun (Table) ->
-					   case ejabberd_cluster:call(Node,
-								      mnesia,
-								      table_info,
-								      [Table,
-								       storage_type])
-					       of
-					     Type when is_atom(Type) ->
-						 ?TABLEFIELD(Table, Type)
-					   end
-				   end,
-				   STables),
+		try Fs = [get_form_1(V1, Node) || V1 <- STables],
 		    {result,
 		     #xdata{title = Title, type = form,
 			    instructions = [Instr], fields = [?HFIELD() | Fs]}}
@@ -950,11 +942,7 @@ get_form(Host,
 		Title = <<(?T(Lang, <<"Stop Modules at ">>))/binary,
 			  ENode/binary>>,
 		Instr = (?T(Lang, <<"Choose modules to stop">>)),
-		Fs = lists:map(fun (M) ->
-				       S = misc:atom_to_binary(M),
-				       ?XFIELD(boolean, S, S, <<"0">>)
-			       end,
-			       SModules),
+		Fs = [get_form_1(V2) || V2 <- SModules],
 		{result,
 		 #xdata{title = Title, type = form,
 			instructions = [Instr], fields = [?HFIELD() | Fs]}}
@@ -1298,6 +1286,17 @@ get_form(Host, ?NS_ADMINL(<<"get-online-users-num">>),
 get_form(_Host, _, _Lang) ->
     {error, xmpp:err_service_unavailable()}.
 
+get_form_1(Table, Node) ->
+    case ejabberd_cluster:call(Node, mnesia, table_info,
+			       [Table, storage_type])
+	of
+      Type when is_atom(Type) -> ?TABLEFIELD(Table, Type)
+    end.
+
+get_form_1(M) ->
+    S = misc:atom_to_binary(M),
+    ?XFIELD(boolean, S, S, <<"0">>).
+
 set_form(_From, _Host,
 	 [<<"running nodes">>, ENode, <<"DB">>], Lang, XData) ->
     case search_running_node(ENode) of
@@ -1652,16 +1651,8 @@ set_form(From, Host, ?NS_ADMINL(<<"delete-user">>),
     AccountStringList = get_values(<<"accountjids">>,
 				   XData),
     [_ | _] = AccountStringList,
-    ASL2 = lists:map(fun (AccountString) ->
-			     JID = jid:decode(AccountString),
-			     User = JID#jid.luser,
-			     Server = JID#jid.lserver,
-			     true = Server == Host orelse
-				      get_permission_level(From) == global,
-			     true = ejabberd_auth:user_exists(User, Server),
-			     {User, Server}
-		     end,
-		     AccountStringList),
+    ASL2 = [set_form_1(V1, From, Host)
+	    || V1 <- AccountStringList],
     [ejabberd_auth:remove_user(User, Server)
      || {User, Server} <- ASL2],
     {result, undefined};
@@ -1774,6 +1765,15 @@ set_form(From, Host, ?NS_ADMINL(<<"user-stats">>), Lang,
 set_form(_From, _Host, _, _Lang, _XData) ->
     {error, xmpp:err_service_unavailable()}.
 
+set_form_1(AccountString, From, Host) ->
+    JID = jid:decode(AccountString),
+    User = JID#jid.luser,
+    Server = JID#jid.lserver,
+    true = Server == Host orelse
+	     get_permission_level(From) == global,
+    true = ejabberd_auth:user_exists(User, Server),
+    {User, Server}.
+
 get_value(Field, XData) -> hd(get_values(Field, XData)).
 
 get_values(Field, XData) ->
diff --git a/src/mod_delegation.erl b/src/mod_delegation.erl
index c74fc0f..265920d 100644
--- a/src/mod_delegation.erl
+++ b/src/mod_delegation.erl
@@ -76,14 +76,12 @@ stop(Host) -> gen_mod:stop_child(?MODULE, Host).
 reload(_Host, _NewOpts, _OldOpts) -> ok.
 
 mod_opt_type(namespaces) ->
-    fun (L) ->
-	    lists:map(fun ({NS, Opts}) ->
-			      Attrs = proplists:get_value(filtering, Opts, []),
-			      Access = proplists:get_value(access, Opts, none),
-			      {NS, Attrs, Access}
-		      end,
-		      L)
-    end.
+    fun (L) -> [mod_opt_type_1(V1) || V1 <- L] end.
+
+mod_opt_type_1({NS, Opts}) ->
+    Attrs = proplists:get_value(filtering, Opts, []),
+    Access = proplists:get_value(access, Opts, none),
+    {NS, Attrs, Access}.
 
 mod_options(_Host) -> [{namespaces, []}].
 
diff --git a/src/mod_disco.erl b/src/mod_disco.erl
index da0087d..4a9dcb1 100644
--- a/src/mod_disco.erl
+++ b/src/mod_disco.erl
@@ -261,15 +261,14 @@ get_local_services(Acc, _From, To, <<"">>, _Lang) ->
 	    end,
     Host = To#jid.lserver,
     {result,
-     lists:usort(lists:map(fun (Domain) ->
-				   #disco_item{jid = jid:make(Domain)}
-			   end,
-			   get_vh_services(Host) ++
-			     ets:select(disco_extra_domains,
-					ets:fun2ms(fun ({{D, H}})
-							   when H == Host ->
-							   D
-						   end))))
+     lists:usort([get_local_services_1(V1)
+		  || V1
+			 <- get_vh_services(Host) ++
+			      ets:select(disco_extra_domains,
+					 ets:fun2ms(fun ({{D, H}})
+							    when H == Host ->
+							    D
+						    end))])
        ++ Items};
 get_local_services({result, _} = Acc, _From, _To, _Node,
 		   _Lang) ->
@@ -279,6 +278,9 @@ get_local_services(empty, _From, _To, _Node, Lang) ->
      xmpp:err_item_not_found(<<"No services available">>,
 			     Lang)}.
 
+get_local_services_1(Domain) ->
+    #disco_item{jid = jid:make(Domain)}.
+
 - spec ( { { get_vh_services , 1 } , [ { type , 236 , 'fun' , [ { type , 236 , product , [ { type , 236 , binary , [ ] } ] } , { type , 236 , list , [ { type , 236 , binary , [ ] } ] } ] } ] } ) .
 
 
@@ -287,20 +289,19 @@ get_vh_services(Host) ->
 			       byte_size(H1) >= byte_size(H2)
 		       end,
 		       ejabberd_config:get_myhosts()),
-    lists:filter(fun (H) ->
-			 case lists:dropwhile(fun (VH) ->
-						      not
-							str:suffix(<<".",
-								     VH/binary>>,
-								   H)
-					      end,
-					      Hosts)
-			     of
-			   [] -> false;
-			   [VH | _] -> VH == Host
-			 end
-		 end,
-		 ejabberd_router:get_all_routes()).
+    [V1
+     || V1 <- ejabberd_router:get_all_routes(),
+	get_vh_services_1(V1, Host, Hosts)].
+
+get_vh_services_1(H, Host, Hosts) ->
+    case lists:dropwhile(fun (VH) ->
+				 not str:suffix(<<".", VH/binary>>, H)
+			 end,
+			 Hosts)
+	of
+      [] -> false;
+      [VH | _] -> VH == Host
+    end.
 
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
@@ -446,18 +447,17 @@ get_user_resources(User, Server) ->
 
 
 transform_module_options(Opts) ->
-    lists:map(fun ({server_info, Infos}) ->
-		      NewInfos = lists:map(fun ({Modules, Name, URLs}) ->
-						   [[{modules, Modules},
-						     {name, Name},
-						     {urls, URLs}]];
-					       (Opt) -> Opt
-					   end,
-					   Infos),
-		      {server_info, NewInfos};
-		  (Opt) -> Opt
-	      end,
-	      Opts).
+    [transform_module_options_2(V2) || V2 <- Opts].
+
+transform_module_options_1({Modules, Name, URLs}) ->
+    [[{modules, Modules}, {name, Name}, {urls, URLs}]];
+transform_module_options_1(Opt) -> Opt.
+
+transform_module_options_2({server_info, Infos}) ->
+    NewInfos = [transform_module_options_1(V1)
+		|| V1 <- Infos],
+    {server_info, NewInfos};
+transform_module_options_2(Opt) -> Opt.
 
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
@@ -485,17 +485,18 @@ get_info(Acc, _, _, _Node, _) -> Acc.
 get_fields(Host, Module) ->
     Fields = gen_mod:get_module_opt(Host, ?MODULE,
 				    server_info),
-    Fields1 = lists:filter(fun ({Modules, _, _}) ->
-				   case Modules of
-				     all -> true;
-				     Modules -> lists:member(Module, Modules)
-				   end
-			   end,
-			   Fields),
+    Fields1 = [V1
+	       || V1 <- Fields, get_fields_1(V1, Module)],
     [#xdata_field{var = Var, type = 'list-multi',
 		  values = Values}
      || {_, Var, Values} <- Fields1].
 
+get_fields_1({Modules, _, _}, Module) ->
+    case Modules of
+      all -> true;
+      Modules -> lists:member(Module, Modules)
+    end.
+
 - spec ( { { depends , 2 } , [ { type , 427 , 'fun' , [ { type , 427 , product , [ { type , 427 , binary , [ ] } , { remote_type , 427 , [ { atom , 427 , gen_mod } , { atom , 427 , opts } , [ ] ] } ] } , { type , 427 , nil , [ ] } ] } ] } ) .
 
 
@@ -505,15 +506,13 @@ mod_opt_type(extra_domains) ->
     fun (Hs) -> [iolist_to_binary(H) || H <- Hs] end;
 mod_opt_type(name) -> fun iolist_to_binary/1;
 mod_opt_type(server_info) ->
-    fun (L) ->
-	    lists:map(fun (Opts) ->
-			      Mods = proplists:get_value(modules, Opts, all),
-			      Name = proplists:get_value(name, Opts, <<>>),
-			      URLs = proplists:get_value(urls, Opts, []),
-			      {Mods, Name, URLs}
-		      end,
-		      L)
-    end.
+    fun (L) -> [mod_opt_type_1(V1) || V1 <- L] end.
+
+mod_opt_type_1(Opts) ->
+    Mods = proplists:get_value(modules, Opts, all),
+    Name = proplists:get_value(name, Opts, <<>>),
+    URLs = proplists:get_value(urls, Opts, []),
+    {Mods, Name, URLs}.
 
 mod_options(_Host) ->
     [{extra_domains, []}, {server_info, []},
diff --git a/src/mod_http_api.erl b/src/mod_http_api.erl
index 783f420..bce5bcc 100644
--- a/src/mod_http_api.erl
+++ b/src/mod_http_api.erl
@@ -341,11 +341,8 @@ format_arg({Elements},
 		 Tuple}})
     when is_list(Elements) andalso
 	   (Tuple1S == binary orelse Tuple1S == string) ->
-    lists:map(fun ({F1, F2}) ->
-		      {format_arg(F1, Tuple1S), format_arg(F2, Tuple2S)};
-		  ({Val}) when is_list(Val) -> format_arg({Val}, Tuple)
-	      end,
-	      Elements);
+    [format_arg_1(V1, Tuple, Tuple1S, Tuple2S)
+     || V1 <- Elements];
 format_arg(Elements,
 	   {list, {_ElementDefName, {list, _} = ElementDefFormat}})
     when is_list(Elements) ->
@@ -362,21 +359,7 @@ format_arg({[{Name, Value}]},
     {format_arg(Name, Tuple1S), format_arg(Value, Tuple2S)};
 format_arg({Elements}, {tuple, ElementsDef})
     when is_list(Elements) ->
-    F = lists:map(fun ({TElName, TElDef}) ->
-			  case lists:keyfind(atom_to_binary(TElName, latin1), 1,
-					     Elements)
-			      of
-			    {_, Value} -> format_arg(Value, TElDef);
-			    _ when TElDef == binary; TElDef == string -> <<"">>;
-			    _ ->
-				?ERROR_MSG("missing field ~p in tuple ~p",
-					   [TElName, Elements]),
-				throw({invalid_parameter,
-				       io_lib:format("Missing field ~w in tuple ~w",
-						     [TElName, Elements])})
-			  end
-		  end,
-		  ElementsDef),
+    F = [format_arg_1(V2, Elements) || V2 <- ElementsDef],
     list_to_tuple(F);
 format_arg(Elements, {list, ElementsDef})
     when is_list(Elements) and is_atom(ElementsDef) ->
@@ -399,12 +382,33 @@ format_arg(Arg, Format) ->
 	   io_lib:format("Arg ~w is not in format ~w",
 			 [Arg, Format])}).
 
+format_arg_1({F1, F2}, Tuple, Tuple1S, Tuple2S) ->
+    {format_arg(F1, Tuple1S), format_arg(F2, Tuple2S)};
+format_arg_1({Val}, Tuple, Tuple1S, Tuple2S)
+    when is_list(Val) ->
+    format_arg({Val}, Tuple).
+
+format_arg_1({TElName, TElDef}, Elements) ->
+    case lists:keyfind(atom_to_binary(TElName, latin1), 1,
+		       Elements)
+	of
+      {_, Value} -> format_arg(Value, TElDef);
+      _ when TElDef == binary; TElDef == string -> <<"">>;
+      _ ->
+	  ?ERROR_MSG("missing field ~p in tuple ~p",
+		     [TElName, Elements]),
+	  throw({invalid_parameter,
+		 io_lib:format("Missing field ~w in tuple ~w",
+			       [TElName, Elements])})
+    end.
+
 process_unicode_codepoints(Str) ->
-    iolist_to_binary(lists:map(fun (X) when X > 255 ->
-				       unicode:characters_to_binary([X]);
-				   (Y) -> Y
-			       end,
-			       Str)).
+    iolist_to_binary([process_unicode_codepoints_1(V1)
+		      || V1 <- Str]).
+
+process_unicode_codepoints_1(X) when X > 255 ->
+    unicode:characters_to_binary([X]);
+process_unicode_codepoints_1(Y) -> Y.
 
 %% ----------------
 %% internal helpers
@@ -523,17 +527,17 @@ log(Call, Args, IP) ->
 	      [Call, hide_sensitive_args(Args), IP]).
 
 hide_sensitive_args(Args = [_H | _T]) ->
-    lists:map(fun ({<<"password">>, Password}) ->
-		      {<<"password">>,
-		       ejabberd_config:may_hide_data(Password)};
-		  ({<<"newpass">>, NewPassword}) ->
-		      {<<"newpass">>,
-		       ejabberd_config:may_hide_data(NewPassword)};
-		  (E) -> E
-	      end,
-	      Args);
+    [hide_sensitive_args_1(V1) || V1 <- Args];
 hide_sensitive_args(NonListArgs) -> NonListArgs.
 
+hide_sensitive_args_1({<<"password">>, Password}) ->
+    {<<"password">>,
+     ejabberd_config:may_hide_data(Password)};
+hide_sensitive_args_1({<<"newpass">>, NewPassword}) ->
+    {<<"newpass">>,
+     ejabberd_config:may_hide_data(NewPassword)};
+hide_sensitive_args_1(E) -> E.
+
 permission_addon() ->
     Access = gen_mod:get_module_opt(global, ?MODULE,
 				    admin_ip_access),
diff --git a/src/mod_http_fileserver.erl b/src/mod_http_fileserver.erl
index 61d4a13..73264d7 100644
--- a/src/mod_http_fileserver.erl
+++ b/src/mod_http_fileserver.erl
@@ -489,22 +489,19 @@ last_modified(FileInfo) ->
 ip_to_string(Address) when size(Address) == 4 ->
     join(tuple_to_list(Address), ".");
 ip_to_string(Address) when size(Address) == 8 ->
-    Parts = lists:map(fun (Int) ->
-			      io_lib:format("~.16B", [Int])
-		      end,
-		      tuple_to_list(Address)),
+    Parts = [ip_to_string_1(V1)
+	     || V1 <- tuple_to_list(Address)],
     string:to_lower(lists:flatten(join(Parts, ":"))).
 
+ip_to_string_1(Int) -> io_lib:format("~.16B", [Int]).
+
 mod_opt_type(accesslog) ->
     fun (undefined) -> undefined;
 	(File) -> iolist_to_binary(File)
     end;
 mod_opt_type(content_types) ->
     fun (L) when is_list(L) ->
-	    lists:map(fun ({K, V}) ->
-			      {iolist_to_binary(K), iolist_to_binary(V)}
-		      end,
-		      L)
+	    [mod_opt_type_1(V1) || V1 <- L]
     end;
 mod_opt_type(custom_headers) ->
     fun (L) when is_list(L) -> L end;
@@ -525,12 +522,15 @@ mod_opt_type(docroot) ->
     end;
 mod_opt_type(must_authenticate_with) ->
     fun (L) when is_list(L) ->
-	    lists:map(fun (UP) when is_binary(UP) ->
-			      [K, V] = binary:split(UP, <<":">>), {K, V}
-		      end,
-		      L)
+	    [mod_opt_type_2(V2) || V2 <- L]
     end.
 
+mod_opt_type_1({K, V}) ->
+    {iolist_to_binary(K), iolist_to_binary(V)}.
+
+mod_opt_type_2(UP) when is_binary(UP) ->
+    [K, V] = binary:split(UP, <<":">>), {K, V}.
+
 mod_options(_) ->
     [{accesslog, undefined}, {content_types, []},
      {default_content_type, <<"application/octet-stream">>},
diff --git a/src/mod_http_upload.erl b/src/mod_http_upload.erl
index 5c12f3a..fe9e965 100644
--- a/src/mod_http_upload.erl
+++ b/src/mod_http_upload.erl
@@ -189,11 +189,7 @@ mod_opt_type(service_url) ->
 	    misc:try_url(URL)
     end;
 mod_opt_type(custom_headers) ->
-    fun (Headers) ->
-	    lists:map(fun ({K, V}) ->
-			      {iolist_to_binary(K), iolist_to_binary(V)}
-		      end,
-		      Headers)
+    fun (Headers) -> [mod_opt_type_1(V1) || V1 <- Headers]
     end;
 mod_opt_type(rm_on_unregister) ->
     fun (B) when is_boolean(B) -> B end;
@@ -211,6 +207,9 @@ mod_opt_type(thumbnail) ->
     end;
 mod_opt_type(external_secret) -> fun iolist_to_binary/1.
 
+mod_opt_type_1({K, V}) ->
+    {iolist_to_binary(K), iolist_to_binary(V)}.
+
 - spec ( { { mod_options , 1 } , [ { type , 223 , 'fun' , [ { type , 223 , product , [ { type , 223 , binary , [ ] } ] } , { type , 223 , list , [ { type , 223 , tuple , [ { type , 223 , atom , [ ] } , { type , 223 , any , [ ] } ] } ] } ] } ] } ) .
 
 
diff --git a/src/mod_http_upload_quota.erl b/src/mod_http_upload_quota.erl
index d16a672..471089e 100644
--- a/src/mod_http_upload_quota.erl
+++ b/src/mod_http_upload_quota.erl
@@ -219,12 +219,10 @@ handle_info(sweep,
       {ok, Entries} ->
 	  BackThen = secs_since_epoch() - MaxDays * 86400,
 	  DocRootS = binary_to_list(DocRoot),
-	  PathNames = lists:map(fun (Entry) ->
-					DocRootS ++ "/" ++ Entry
-				end,
-				Entries),
-	  UserDirs = lists:filter(fun filelib:is_dir/1,
-				  PathNames),
+	  PathNames = [handle_info_1(V1, DocRootS)
+		       || V1 <- Entries],
+	  UserDirs = [V2
+		      || V2 <- PathNames, fun filelib:is_dir/1(V2)],
 	  lists:foreach(fun (UserDir) ->
 				delete_old_files(UserDir, BackThen)
 			end,
@@ -238,6 +236,9 @@ handle_info(Info, State) ->
     ?ERROR_MSG("Got unexpected info: ~p", [Info]),
     {noreply, State}.
 
+handle_info_1(Entry, DocRootS) ->
+    DocRootS ++ "/" ++ Entry.
+
 - spec ( { { terminate , 2 } , [ { type , 217 , 'fun' , [ { type , 217 , product , [ { type , 217 , union , [ { atom , 217 , normal } , { atom , 217 , shutdown } , { type , 217 , tuple , [ { atom , 217 , shutdown } , { var , 217 , '_' } ] } , { var , 217 , '_' } ] } , { type , 217 , state , [ ] } ] } , { atom , 217 , ok } ] } ] } ) .
 
 
diff --git a/src/mod_mam.erl b/src/mod_mam.erl
index 8a243ec..3743b50 100644
--- a/src/mod_mam.erl
+++ b/src/mod_mam.erl
@@ -562,30 +562,30 @@ delete_old_messages(TypeBin, Days)
     Diff = Days * 24 * 60 * 60 * 1000000,
     TimeStamp = misc:usec_to_now(CurrentTime - Diff),
     Type = misc:binary_to_atom(TypeBin),
-    DBTypes = lists:usort(lists:map(fun (Host) ->
-					    case gen_mod:get_module_opt(Host,
-									?MODULE,
-									db_type)
-						of
-					      sql -> {sql, Host};
-					      Other -> {Other, global}
-					    end
-				    end,
-				    ejabberd_config:get_myhosts())),
-    Results = lists:map(fun ({DBType, ServerHost}) ->
-				Mod = gen_mod:db_mod(DBType, ?MODULE),
-				Mod:delete_old_messages(ServerHost, TimeStamp,
-							Type)
-			end,
-			DBTypes),
-    case lists:filter(fun (Res) -> Res /= ok end, Results)
-	of
+    DBTypes = lists:usort([delete_old_messages_1(V1)
+			   || V1 <- ejabberd_config:get_myhosts()]),
+    Results = [delete_old_messages_1(V2, TimeStamp, Type)
+	       || V2 <- DBTypes],
+    case [V3 || V3 <- Results, delete_old_messages_2(V3)] of
       [] -> ok;
       [NotOk | _] -> NotOk
     end;
 delete_old_messages(_TypeBin, _Days) ->
     unsupported_type.
 
+delete_old_messages_1(Host) ->
+    case gen_mod:get_module_opt(Host, ?MODULE, db_type) of
+      sql -> {sql, Host};
+      Other -> {Other, global}
+    end.
+
+delete_old_messages_1({DBType, ServerHost}, TimeStamp,
+		      Type) ->
+    Mod = gen_mod:db_mod(DBType, ?MODULE),
+    Mod:delete_old_messages(ServerHost, TimeStamp, Type).
+
+delete_old_messages_2(Res) -> Res /= ok.
+
 export(LServer) ->
     Mod = gen_mod:db_mod(LServer, ?MODULE),
     Mod:export(LServer).
@@ -711,40 +711,32 @@ strip_my_stanza_id(Pkt, LServer) ->
 
 strip_x_jid_tags(Pkt) ->
     Els = xmpp:get_els(Pkt),
-    NewEls = lists:filter(fun (El) ->
-				  case xmpp:get_name(El) of
-				    <<"x">> ->
-					NS = xmpp:get_ns(El),
-					Items = if NS == (?NS_MUC_USER);
-						   NS == (?NS_MUC_ADMIN);
-						   NS == (?NS_MUC_OWNER) ->
-						       try xmpp:decode(El) of
-							 #muc_user{items =
-								       Is} ->
-							     Is;
-							 #muc_admin{items =
-									Is} ->
-							     Is;
-							 #muc_owner{items =
-									Is} ->
-							     Is
-						       catch
-							 _:{xmpp_codec, _} -> []
-						       end;
-						   true -> []
-						end,
-					not
-					  lists:any(fun (#muc_item{jid =
-								       JID}) ->
-							    JID /= undefined
-						    end,
-						    Items);
-				    _ -> true
-				  end
-			  end,
-			  Els),
+    NewEls = [V1 || V1 <- Els, strip_x_jid_tags_1(V1)],
     xmpp:set_els(Pkt, NewEls).
 
+strip_x_jid_tags_1(El) ->
+    case xmpp:get_name(El) of
+      <<"x">> ->
+	  NS = xmpp:get_ns(El),
+	  Items = if NS == (?NS_MUC_USER);
+		     NS == (?NS_MUC_ADMIN);
+		     NS == (?NS_MUC_OWNER) ->
+			 try xmpp:decode(El) of
+			   #muc_user{items = Is} -> Is;
+			   #muc_admin{items = Is} -> Is;
+			   #muc_owner{items = Is} -> Is
+			 catch
+			   _:{xmpp_codec, _} -> []
+			 end;
+		     true -> []
+		  end,
+	  not
+	    lists:any(fun (#muc_item{jid = JID}) -> JID /= undefined
+		      end,
+		      Items);
+      _ -> true
+    end.
+
 - spec ( { { should_archive_peer , 4 } , [ { type , 724 , 'fun' , [ { type , 724 , product , [ { type , 724 , binary , [ ] } , { type , 724 , binary , [ ] } , { type , 725 , record , [ { atom , 725 , archive_prefs } ] } , { type , 725 , jid , [ ] } ] } , { type , 725 , boolean , [ ] } ] } ] } ) .
 
 
@@ -1067,14 +1059,7 @@ send(Msgs, Count, IsComplete,
 	 sub_els = [#mam_query{id = QID, xmlns = NS}]} =
 	 IQ) ->
     Hint = #hint{type = 'no-store'},
-    Els = lists:map(fun ({ID, _IDInt, El}) ->
-			    #message{from = To, to = From,
-				     sub_els =
-					 [#mam_result{xmlns = NS, id = ID,
-						      queryid = QID,
-						      sub_els = [El]}]}
-		    end,
-		    Msgs),
+    Els = [send_1(V1, From, NS, QID, To) || V1 <- Msgs],
     RSMOut = make_rsm_out(Msgs, Count),
     Result = if NS == (?NS_MAM_TMP) ->
 		    #mam_query{xmlns = NS, id = QID, rsm = RSMOut};
@@ -1095,6 +1080,12 @@ send(Msgs, Count, IsComplete,
 	   ignore
     end.
 
+send_1({ID, _IDInt, El}, From, NS, QID, To) ->
+    #message{from = To, to = From,
+	     sub_els =
+		 [#mam_result{xmlns = NS, id = ID, queryid = QID,
+			      sub_els = [El]}]}.
+
 - spec ( { { make_rsm_out , 2 } , [ { type , 1086 , 'fun' , [ { type , 1086 , product , [ { type , 1086 , list , [ { type , 1086 , tuple , [ { type , 1086 , binary , [ ] } , { type , 1086 , integer , [ ] } , { type , 1086 , xmlel , [ ] } ] } ] } , { type , 1086 , non_neg_integer , [ ] } ] } , { type , 1086 , rsm_set , [ ] } ] } ] } ) .
 
 
diff --git a/src/mod_mam_mnesia.erl b/src/mod_mam_mnesia.erl
index 932f195..a166aad 100644
--- a/src/mod_mam_mnesia.erl
+++ b/src/mod_mam_mnesia.erl
@@ -112,13 +112,9 @@ delete_old_user_messages('$end_of_table', _TimeStamp,
 delete_old_user_messages(User, TimeStamp, Type) ->
     F = fun () ->
 		Msgs = mnesia:read(archive_msg, User),
-		Keep = lists:filter(fun (#archive_msg{timestamp = MsgTS,
-						      type = MsgType}) ->
-					    MsgTS >= TimeStamp orelse
-					      Type /= all andalso
-						Type /= MsgType
-				    end,
-				    Msgs),
+		Keep = [V1
+			|| V1 <- Msgs,
+			   delete_old_user_messages_1(V1, TimeStamp, Type)],
 		if length(Keep) < length(Msgs) ->
 		       mnesia:delete({archive_msg, User}),
 		       lists:foreach(fun (Msg) -> mnesia:write(Msg) end, Keep);
@@ -134,6 +130,13 @@ delete_old_user_messages(User, TimeStamp, Type) ->
 	  Err
     end.
 
+delete_old_user_messages_1(#archive_msg{timestamp =
+					    MsgTS,
+					type = MsgType},
+			   TimeStamp, Type) ->
+    MsgTS >= TimeStamp orelse
+      Type /= all andalso Type /= MsgType.
+
 extended_fields() -> [].
 
 store(Pkt, _, {LUser, LServer}, Type, Peer, Nick, _Dir,
@@ -254,10 +257,7 @@ filter_by_rsm(Msgs,
 	      #rsm_set{max = Max, before = Before,
 		       'after' = After}) ->
     NewMsgs = if is_binary(After), After /= <<"">> ->
-		     lists:filter(fun (#archive_msg{id = I}) ->
-					  ?BIN_GREATER_THAN(I, After)
-				  end,
-				  Msgs);
+		     [V1 || V1 <- Msgs, filter_by_rsm_1(V1, After)];
 		 is_binary(Before), Before /= <<"">> ->
 		     lists:foldl(fun (#archive_msg{id = I} = Msg, Acc)
 					 when ?BIN_LESS_THAN(I, Before) ->
@@ -271,6 +271,9 @@ filter_by_rsm(Msgs,
 	      end,
     filter_by_max(NewMsgs, Max).
 
+filter_by_rsm_1(#archive_msg{id = I}, After) ->
+    ?BIN_GREATER_THAN(I, After).
+
 filter_by_max(Msgs, undefined) -> {Msgs, true};
 filter_by_max(Msgs, Len)
     when is_integer(Len), Len >= 0 ->
diff --git a/src/mod_muc.erl b/src/mod_muc.erl
index b721a72..419eca5 100644
--- a/src/mod_muc.erl
+++ b/src/mod_muc.erl
@@ -966,43 +966,38 @@ count_online_rooms(ServerHost, Host) ->
     RMod:count_online_rooms(ServerHost, Host).
 
 opts_to_binary(Opts) ->
-    lists:map(fun ({title, Title}) ->
-		      {title, iolist_to_binary(Title)};
-		  ({description, Desc}) ->
-		      {description, iolist_to_binary(Desc)};
-		  ({password, Pass}) ->
-		      {password, iolist_to_binary(Pass)};
-		  ({subject, [C | _] = Subj})
-		      when is_integer(C), C >= 0, C =< 255 ->
-		      {subject, iolist_to_binary(Subj)};
-		  ({subject_author, Author}) ->
-		      {subject_author, iolist_to_binary(Author)};
-		  ({affiliations, Affs}) ->
-		      {affiliations,
-		       lists:map(fun ({{U, S, R}, Aff}) ->
-					 NewAff = case Aff of
-						    {A, Reason} ->
-							{A,
-							 iolist_to_binary(Reason)};
-						    _ -> Aff
-						  end,
-					 {{iolist_to_binary(U),
-					   iolist_to_binary(S),
-					   iolist_to_binary(R)},
-					  NewAff}
-				 end,
-				 Affs)};
-		  ({captcha_whitelist, CWList}) ->
-		      {captcha_whitelist,
-		       lists:map(fun ({U, S, R}) ->
-					 {iolist_to_binary(U),
-					  iolist_to_binary(S),
-					  iolist_to_binary(R)}
-				 end,
-				 CWList)};
-		  (Opt) -> Opt
-	      end,
-	      Opts).
+    [opts_to_binary_3(V3) || V3 <- Opts].
+
+opts_to_binary_1({{U, S, R}, Aff}) ->
+    NewAff = case Aff of
+	       {A, Reason} -> {A, iolist_to_binary(Reason)};
+	       _ -> Aff
+	     end,
+    {{iolist_to_binary(U), iolist_to_binary(S),
+      iolist_to_binary(R)},
+     NewAff}.
+
+opts_to_binary_2({U, S, R}) ->
+    {iolist_to_binary(U), iolist_to_binary(S),
+     iolist_to_binary(R)}.
+
+opts_to_binary_3({title, Title}) ->
+    {title, iolist_to_binary(Title)};
+opts_to_binary_3({description, Desc}) ->
+    {description, iolist_to_binary(Desc)};
+opts_to_binary_3({password, Pass}) ->
+    {password, iolist_to_binary(Pass)};
+opts_to_binary_3({subject, [C | _] = Subj})
+    when is_integer(C), C >= 0, C =< 255 ->
+    {subject, iolist_to_binary(Subj)};
+opts_to_binary_3({subject_author, Author}) ->
+    {subject_author, iolist_to_binary(Author)};
+opts_to_binary_3({affiliations, Affs}) ->
+    {affiliations, [opts_to_binary_1(V1) || V1 <- Affs]};
+opts_to_binary_3({captcha_whitelist, CWList}) ->
+    {captcha_whitelist,
+     [opts_to_binary_2(V2) || V2 <- CWList]};
+opts_to_binary_3(Opt) -> Opt.
 
 export(LServer) ->
     Mod = gen_mod:db_mod(LServer, ?MODULE),
@@ -1135,16 +1130,14 @@ mod_opt_type({default_room_options, max_users}) ->
     fun (I) when is_integer(I), I > 0 -> I end;
 mod_opt_type({default_room_options,
 	      presence_broadcast}) ->
-    fun (L) ->
-	    lists:map(fun (moderator) -> moderator;
-			  (participant) -> participant;
-			  (visitor) -> visitor
-		      end,
-		      L)
-    end;
+    fun (L) -> [mod_opt_type_1(V1) || V1 <- L] end;
 mod_opt_type({default_room_options, lang}) ->
     fun iolist_to_binary/1.
 
+mod_opt_type_1(moderator) -> moderator;
+mod_opt_type_1(participant) -> participant;
+mod_opt_type_1(visitor) -> visitor.
+
 mod_options(Host) ->
     [{access, all}, {access_admin, none},
      {access_create, all}, {access_persistent, all},
diff --git a/src/mod_muc_admin.erl b/src/mod_muc_admin.erl
index e45b3d4..cf2cb5e 100644
--- a/src/mod_muc_admin.erl
+++ b/src/mod_muc_admin.erl
@@ -577,10 +577,7 @@ make_rooms_page(Host, Lang,
     Rooms_sorted = sort_rooms(Sort_direction, Sort_column,
 			      Rooms_infos),
     Rooms_prepared = prepare_rooms_infos(Rooms_sorted),
-    TList = lists:map(fun (Room) ->
-			      ?XE(<<"tr">>, [?XC(<<"td">>, E) || E <- Room])
-		      end,
-		      Rooms_prepared),
+    TList = [make_rooms_page_1(V1) || V1 <- Rooms_prepared],
     Titles = [<<"Jabber ID">>, <<"# participants">>,
 	      <<"Last message">>, <<"Public">>, <<"Persistent">>,
 	      <<"Logging">>, <<"Just created">>, <<"Room title">>],
@@ -605,6 +602,9 @@ make_rooms_page(Host, Lang,
 	 [?XE(<<"thead">>, [?XE(<<"tr">>, Titles_TR)]),
 	  ?XE(<<"tbody">>, TList)])].
 
+make_rooms_page_1(Room) ->
+    ?XE(<<"tr">>, [?XC(<<"td">>, E) || E <- Room]).
+
 sort_rooms(Direction, Column, Rooms) ->
     Rooms2 = lists:keysort(Column, Rooms),
     case Direction of
@@ -930,11 +930,12 @@ get_room_occupants(Room, Host) ->
 
 get_room_occupants(Pid) ->
     S = get_room_state(Pid),
-    lists:map(fun ({_LJID, Info}) ->
-		      {jid:encode(Info#user.jid), Info#user.nick,
-		       atom_to_list(Info#user.role)}
-	      end,
-	      dict:to_list(S#state.users)).
+    [get_room_occupants_1(V1)
+     || V1 <- dict:to_list(S#state.users)].
+
+get_room_occupants_1({_LJID, Info}) ->
+    {jid:encode(Info#user.jid), Info#user.nick,
+     atom_to_list(Info#user.role)}.
 
 get_room_occupants_number(Room, Host) ->
     case get_room_pid(Room, Host) of
@@ -1122,16 +1123,17 @@ get_options(Config) ->
     Fields = [misc:atom_to_binary(Field)
 	      || Field <- record_info(fields, config)],
     [config | ValuesRaw] = tuple_to_list(Config),
-    Values = lists:map(fun (V) when is_atom(V) ->
-			       misc:atom_to_binary(V);
-			   (V) when is_integer(V) -> integer_to_binary(V);
-			   (V) when is_tuple(V); is_list(V) ->
-			       list_to_binary(hd(io_lib:format("~w", [V])));
-			   (V) -> V
-		       end,
-		       ValuesRaw),
+    Values = [get_options_1(V1) || V1 <- ValuesRaw],
     lists:zip(Fields, Values).
 
+get_options_1(V) when is_atom(V) ->
+    misc:atom_to_binary(V);
+get_options_1(V) when is_integer(V) ->
+    integer_to_binary(V);
+get_options_1(V) when is_tuple(V); is_list(V) ->
+    list_to_binary(hd(io_lib:format("~w", [V])));
+get_options_1(V) -> V.
+
 %%----------------------------
 %% Get Room Affiliations
 %%----------------------------
@@ -1147,16 +1149,18 @@ get_room_affiliations(Name, Service) ->
 							     get_state),
 	  Affiliations =
 	      (?DICT):to_list(StateData#state.affiliations),
-	  lists:map(fun ({{Uname, Domain, _Res}, {Aff, Reason}})
-			    when is_atom(Aff) ->
-			    {Uname, Domain, Aff, Reason};
-			({{Uname, Domain, _Res}, Aff}) when is_atom(Aff) ->
-			    {Uname, Domain, Aff, <<>>}
-		    end,
-		    Affiliations);
+	  [get_room_affiliations_1(V1) || V1 <- Affiliations];
       error -> throw({error, "The room does not exist."})
     end.
 
+get_room_affiliations_1({{Uname, Domain, _Res},
+			 {Aff, Reason}})
+    when is_atom(Aff) ->
+    {Uname, Domain, Aff, Reason};
+get_room_affiliations_1({{Uname, Domain, _Res}, Aff})
+    when is_atom(Aff) ->
+    {Uname, Domain, Aff, <<>>}.
+
 %%----------------------------
 %% Get Room Affiliation
 %%----------------------------
diff --git a/src/mod_muc_log.erl b/src/mod_muc_log.erl
index 3fe1402..32ef905 100644
--- a/src/mod_muc_log.erl
+++ b/src/mod_muc_log.erl
@@ -88,11 +88,11 @@ check_access_log(Host, From) ->
     end.
 
 transform_module_options(Opts) ->
-    lists:map(fun ({top_link, {S1, S2}}) ->
-		      {top_link, [{S1, S2}]};
-		  (Opt) -> Opt
-	      end,
-	      Opts).
+    [transform_module_options_1(V1) || V1 <- Opts].
+
+transform_module_options_1({top_link, {S1, S2}}) ->
+    {top_link, [{S1, S2}]};
+transform_module_options_1(Opt) -> Opt.
 
 depends(_Host, _Opts) -> [{mod_muc, hard}].
 
diff --git a/src/mod_muc_riak.erl b/src/mod_muc_riak.erl
index 0911d6f..3d934c5 100644
--- a/src/mod_muc_riak.erl
+++ b/src/mod_muc_riak.erl
@@ -85,14 +85,13 @@ can_use_nick(_LServer, Host, JID, Nick) ->
 
 get_rooms(_LServer, Host) ->
     case ejabberd_riak:get(muc_room, muc_room_schema()) of
-      {ok, Rs} ->
-	  lists:filter(fun (#muc_room{name_host = {_, H}}) ->
-			       Host == H
-		       end,
-		       Rs);
+      {ok, Rs} -> [V1 || V1 <- Rs, get_rooms_1(V1, Host)];
       _Err -> []
     end.
 
+get_rooms_1(#muc_room{name_host = {_, H}}, Host) ->
+    Host == H.
+
 get_nick(LServer, Host, From) ->
     {LUser, LServer, _} = jid:tolower(From),
     US = {LUser, LServer},
diff --git a/src/mod_muc_room.erl b/src/mod_muc_room.erl
index 0bdd960..2a88fdb 100644
--- a/src/mod_muc_room.erl
+++ b/src/mod_muc_room.erl
@@ -581,8 +581,9 @@ handle_sync_event({process_item_change, Item, UJID},
     end;
 handle_sync_event(get_subscribers, _From, StateName,
 		  StateData) ->
-    JIDs = lists:map(fun jid:make/1,
-		     (?DICT):fetch_keys(StateData#state.subscribers)),
+    JIDs = [fun jid:make/1(V1)
+	    || V1
+		   <- (?DICT):fetch_keys(StateData#state.subscribers)],
     {reply, {ok, JIDs}, StateName, StateData};
 handle_sync_event({muc_subscribe, From, Nick, Nodes},
 		  _From, StateName, StateData) ->
@@ -1954,17 +1955,17 @@ remove_online_user(JID, StateData, Reason) ->
 
 
 filter_presence(Presence) ->
-    Els = lists:filter(fun (El) ->
-			       XMLNS = xmpp:get_ns(El),
-			       case catch binary:part(XMLNS, 0, size(?NS_MUC))
-				   of
-				 ?NS_MUC -> false;
-				 _ -> true
-			       end
-		       end,
-		       xmpp:get_els(Presence)),
+    Els = [V1
+	   || V1 <- xmpp:get_els(Presence), filter_presence_1(V1)],
     xmpp:set_els(Presence, Els).
 
+filter_presence_1(El) ->
+    XMLNS = xmpp:get_ns(El),
+    case catch binary:part(XMLNS, 0, size(?NS_MUC)) of
+      ?NS_MUC -> false;
+      _ -> true
+    end.
+
 - spec ( { { strip_status , 1 } , [ { type , 1750 , 'fun' , [ { type , 1750 , product , [ { type , 1750 , presence , [ ] } ] } , { type , 1750 , presence , [ ] } ] } ] } ) .
 
 
@@ -3014,22 +3015,26 @@ process_iq_admin(_From, #iq{type = get, lang = Lang},
 
 
 items_with_role(SRole, StateData) ->
-    lists:map(fun ({_, U}) -> user_to_item(U, StateData)
-	      end,
-	      search_role(SRole, StateData)).
+    [items_with_role_1(V1, StateData)
+     || V1 <- search_role(SRole, StateData)].
+
+items_with_role_1({_, U}, StateData) ->
+    user_to_item(U, StateData).
 
 - spec ( { { items_with_affiliation , 2 } , [ { type , 2668 , 'fun' , [ { type , 2668 , product , [ { type , 2668 , affiliation , [ ] } , { type , 2668 , state , [ ] } ] } , { type , 2668 , list , [ { type , 2668 , muc_item , [ ] } ] } ] } ] } ) .
 
 
 items_with_affiliation(SAffiliation, StateData) ->
-    lists:map(fun ({JID, {Affiliation, Reason}}) ->
-		      #muc_item{affiliation = Affiliation,
-				jid = jid:make(JID), reason = Reason};
-		  ({JID, Affiliation}) ->
-		      #muc_item{affiliation = Affiliation,
-				jid = jid:make(JID)}
-	      end,
-	      search_affiliation(SAffiliation, StateData)).
+    [items_with_affiliation_1(V1)
+     || V1 <- search_affiliation(SAffiliation, StateData)].
+
+items_with_affiliation_1({JID,
+			  {Affiliation, Reason}}) ->
+    #muc_item{affiliation = Affiliation,
+	      jid = jid:make(JID), reason = Reason};
+items_with_affiliation_1({JID, Affiliation}) ->
+    #muc_item{affiliation = Affiliation,
+	      jid = jid:make(JID)}.
 
 - spec ( { { user_to_item , 2 } , [ { type , 2679 , 'fun' , [ { type , 2679 , product , [ { type , 2679 , record , [ { atom , 2679 , user } ] } , { type , 2679 , state , [ ] } ] } , { type , 2679 , muc_item , [ ] } ] } ] } ) .
 
@@ -3044,9 +3049,11 @@ user_to_item(#user{role = Role, nick = Nick, jid = JID},
 
 
 search_role(Role, StateData) ->
-    lists:filter(fun ({_, #user{role = R}}) -> Role == R
-		 end,
-		 (?DICT):to_list(StateData#state.users)).
+    [V1
+     || V1 <- (?DICT):to_list(StateData#state.users),
+	search_role_1(V1, Role)].
+
+search_role_1({_, #user{role = R}}, Role) -> Role == R.
 
 - spec ( { { search_affiliation , 2 } , [ { type , 2694 , 'fun' , [ { type , 2694 , product , [ { type , 2694 , affiliation , [ ] } , { type , 2694 , state , [ ] } ] } , { type , 2695 , list , [ { type , 2695 , tuple , [ { type , 2695 , ljid , [ ] } , { type , 2696 , union , [ { type , 2696 , affiliation , [ ] } , { type , 2696 , tuple , [ { type , 2696 , affiliation , [ ] } , { type , 2696 , binary , [ ] } ] } ] } ] } ] } ] } ] } ) .
 
@@ -3072,13 +3079,15 @@ search_affiliation(Affiliation, StateData) ->
 
 
 search_affiliation_fallback(Affiliation, StateData) ->
-    lists:filter(fun ({_, A}) ->
-			 case A of
-			   {A1, _Reason} -> Affiliation == A1;
-			   _ -> Affiliation == A
-			 end
-		 end,
-		 (?DICT):to_list(StateData#state.affiliations)).
+    [V1
+     || V1 <- (?DICT):to_list(StateData#state.affiliations),
+	search_affiliation_fallback_1(V1, Affiliation)].
+
+search_affiliation_fallback_1({_, A}, Affiliation) ->
+    case A of
+      {A1, _Reason} -> Affiliation == A1;
+      _ -> Affiliation == A
+    end.
 
 - spec ( { { process_admin_items_set , 4 } , [ { type , 2725 , 'fun' , [ { type , 2725 , product , [ { type , 2725 , jid , [ ] } , { type , 2725 , list , [ { type , 2725 , muc_item , [ ] } ] } , { type , 2725 , binary , [ ] } , { type , 2726 , record , [ { atom , 2726 , state } ] } ] } , { type , 2726 , union , [ { type , 2726 , tuple , [ { atom , 2726 , result } , { atom , 2726 , undefined } , { type , 2726 , record , [ { atom , 2726 , state } ] } ] } , { type , 2727 , tuple , [ { atom , 2727 , error } , { type , 2727 , stanza_error , [ ] } ] } ] } ] } ] } ) .
 
@@ -3547,26 +3556,26 @@ get_actor_nick(MJID, StateData) ->
     end.
 
 convert_legacy_fields(Fs) ->
-    lists:map(fun (#xdata_field{var = Var} = F) ->
-		      NewVar = case Var of
-				 <<"muc#roomconfig_allowvisitorstatus">> ->
-				     <<"allow_visitor_status">>;
-				 <<"muc#roomconfig_allowvisitornickchange">> ->
-				     <<"allow_visitor_nickchange">>;
-				 <<"muc#roomconfig_allowvoicerequests">> ->
-				     <<"allow_voice_requests">>;
-				 <<"muc#roomconfig_allow_subscription">> ->
-				     <<"allow_subscription">>;
-				 <<"muc#roomconfig_voicerequestmininterval">> ->
-				     <<"voice_request_min_interval">>;
-				 <<"muc#roomconfig_captcha_whitelist">> ->
-				     <<"captcha_whitelist">>;
-				 <<"muc#roomconfig_mam">> -> <<"mam">>;
-				 _ -> Var
-			       end,
-		      F#xdata_field{var = NewVar}
-	      end,
-	      Fs).
+    [convert_legacy_fields_1(V1) || V1 <- Fs].
+
+convert_legacy_fields_1(#xdata_field{var = Var} = F) ->
+    NewVar = case Var of
+	       <<"muc#roomconfig_allowvisitorstatus">> ->
+		   <<"allow_visitor_status">>;
+	       <<"muc#roomconfig_allowvisitornickchange">> ->
+		   <<"allow_visitor_nickchange">>;
+	       <<"muc#roomconfig_allowvoicerequests">> ->
+		   <<"allow_voice_requests">>;
+	       <<"muc#roomconfig_allow_subscription">> ->
+		   <<"allow_subscription">>;
+	       <<"muc#roomconfig_voicerequestmininterval">> ->
+		   <<"voice_request_min_interval">>;
+	       <<"muc#roomconfig_captcha_whitelist">> ->
+		   <<"captcha_whitelist">>;
+	       <<"muc#roomconfig_mam">> -> <<"mam">>;
+	       _ -> Var
+	     end,
+    F#xdata_field{var = NewVar}.
 
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 % Owner stuff
@@ -3811,8 +3820,9 @@ get_config(Lang, StateData, From) ->
 	       end
 		 ++
 		 [{captcha_whitelist,
-		   lists:map(fun jid:make/1,
-			     (?SETS):to_list(Config#config.captcha_whitelist))}]
+		   [fun jid:make/1(V1)
+		    || V1
+			   <- (?SETS):to_list(Config#config.captcha_whitelist)]}]
 		   ++
 		   case
 		     mod_muc_log:check_access_log(StateData#state.server_host,
@@ -4658,19 +4668,16 @@ remove_subscriptions(StateData) ->
 
 get_subscription_nodes(#iq{sub_els =
 			       [#muc_subscribe{events = Nodes}]}) ->
-    lists:filter(fun (Node) ->
-			 lists:member(Node,
-				      [?NS_MUCSUB_NODES_PRESENCE,
-				       ?NS_MUCSUB_NODES_MESSAGES,
-				       ?NS_MUCSUB_NODES_AFFILIATIONS,
-				       ?NS_MUCSUB_NODES_SUBJECT,
-				       ?NS_MUCSUB_NODES_CONFIG,
-				       ?NS_MUCSUB_NODES_PARTICIPANTS,
-				       ?NS_MUCSUB_NODES_SUBSCRIBERS])
-		 end,
-		 Nodes);
+    [V1 || V1 <- Nodes, get_subscription_nodes_1(V1)];
 get_subscription_nodes(_) -> [].
 
+get_subscription_nodes_1(Node) ->
+    lists:member(Node,
+		 [?NS_MUCSUB_NODES_PRESENCE, ?NS_MUCSUB_NODES_MESSAGES,
+		  ?NS_MUCSUB_NODES_AFFILIATIONS, ?NS_MUCSUB_NODES_SUBJECT,
+		  ?NS_MUCSUB_NODES_CONFIG, ?NS_MUCSUB_NODES_PARTICIPANTS,
+		  ?NS_MUCSUB_NODES_SUBSCRIBERS]).
+
 - spec ( { { subscribe_result , 1 } , [ { type , 4137 , 'fun' , [ { type , 4137 , product , [ { type , 4137 , iq , [ ] } ] } , { type , 4137 , muc_subscribe , [ ] } ] } ] } ) .
 
 
diff --git a/src/mod_muc_sql.erl b/src/mod_muc_sql.erl
index aed3a62..0906bd3 100644
--- a/src/mod_muc_sql.erl
+++ b/src/mod_muc_sql.erl
@@ -124,11 +124,7 @@ restore_room(LServer, Host, Name) ->
 		end,
 		OptsR;
 	    {selected, Subs} ->
-		SubData = lists:map(fun ({Jid, Nick, Nodes}) ->
-					    {jid:decode(Jid), Nick,
-					     ejabberd_sql:decode_term(Nodes)}
-				    end,
-				    Subs),
+		SubData = [restore_room_1(V1) || V1 <- Subs],
 		Opts2 = lists:keystore(subscribers, 1, OptsD,
 				       {subscribers, SubData}),
 		mod_muc:opts_to_binary(Opts2);
@@ -137,6 +133,10 @@ restore_room(LServer, Host, Name) ->
       _ -> error
     end.
 
+restore_room_1({Jid, Nick, Nodes}) ->
+    {jid:decode(Jid), Nick,
+     ejabberd_sql:decode_term(Nodes)}.
+
 forget_room(LServer, Host, Name) ->
     F = fun () ->
 		ejabberd_sql:sql_query_t(?SQL("delete from muc_room where name=%(Name)s "
@@ -177,34 +177,30 @@ get_rooms(LServer, Host) ->
 							Dict)
 				    end,
 				    dict:new(), Subs),
-		lists:map(fun ({Room, Opts}) ->
-				  OptsD = ejabberd_sql:decode_term(Opts),
-				  OptsD2 = case {dict:find(Room, SubsD),
-						 lists:keymember(subscribers, 1,
-								 OptsD)}
-					       of
-					     {_, true} ->
-						 store_room(LServer, Host, Room,
-							    mod_muc:opts_to_binary(OptsD),
-							    undefined),
-						 OptsD;
-					     {{ok, SubsI}, false} ->
-						 lists:keystore(subscribers, 1,
-								OptsD,
-								{subscribers,
-								 SubsI});
-					     _ -> OptsD
-					   end,
-				  #muc_room{name_host = {Room, Host},
-					    opts =
-						mod_muc:opts_to_binary(OptsD2)}
-			  end,
-			  RoomOpts);
+		[get_rooms_1(V1, Host, LServer, SubsD)
+		 || V1 <- RoomOpts];
 	    _Err -> []
 	  end;
       _Err -> []
     end.
 
+get_rooms_1({Room, Opts}, Host, LServer, SubsD) ->
+    OptsD = ejabberd_sql:decode_term(Opts),
+    OptsD2 = case {dict:find(Room, SubsD),
+		   lists:keymember(subscribers, 1, OptsD)}
+		 of
+	       {_, true} ->
+		   store_room(LServer, Host, Room,
+			      mod_muc:opts_to_binary(OptsD), undefined),
+		   OptsD;
+	       {{ok, SubsI}, false} ->
+		   lists:keystore(subscribers, 1, OptsD,
+				  {subscribers, SubsI});
+	       _ -> OptsD
+	     end,
+    #muc_room{name_host = {Room, Host},
+	      opts = mod_muc:opts_to_binary(OptsD2)}.
+
 get_nick(LServer, Host, From) ->
     SJID =
 	jid:encode(jid:tolower(jid:remove_resource(From))),
diff --git a/src/mod_multicast.erl b/src/mod_multicast.erl
index 7df94f5..2c0afdd 100644
--- a/src/mod_multicast.erl
+++ b/src/mod_multicast.erl
@@ -290,16 +290,15 @@ route_trusted(LServiceS, LServerS, FromJID,
 	      Destinations, Packet) ->
     Packet_stripped = Packet,
     Delivereds = [],
-    Dests2 = lists:map(fun (D) ->
-			       #dest{jid_string = jid:encode(D), jid_jid = D,
-				     type = bcc,
-				     address = #address{type = bcc, jid = D}}
-		       end,
-		       Destinations),
+    Dests2 = [route_trusted_1(V1) || V1 <- Destinations],
     Groups = group_dests(Dests2),
     route_common(LServerS, LServiceS, FromJID, Groups,
 		 Delivereds, Packet_stripped).
 
+route_trusted_1(D) ->
+    #dest{jid_string = jid:encode(D), jid_jid = D,
+	  type = bcc, address = #address{type = bcc, jid = D}}.
+
 - spec ( { { route_untrusted , 5 } , [ { type , 279 , 'fun' , [ { type , 279 , product , [ { type , 279 , binary , [ ] } , { type , 279 , binary , [ ] } , { type , 279 , atom , [ ] } , { type , 279 , record , [ { atom , 279 , service_limits } ] } , { type , 279 , stanza , [ ] } ] } , { atom , 279 , ok } ] } ] } ) .
 
 
@@ -463,13 +462,15 @@ check_limit_dests(SLimits, FromJID, Packet,
 
 
 convert_dest_record(Addrs) ->
-    lists:map(fun (#address{jid = undefined} = Addr) ->
-		      #dest{jid_string = none, address = Addr};
-		  (#address{jid = JID, type = Type} = Addr) ->
-		      #dest{jid_string = jid:encode(JID), jid_jid = JID,
-			    type = Type, address = Addr}
-	      end,
-	      Addrs).
+    [convert_dest_record_1(V1) || V1 <- Addrs].
+
+convert_dest_record_1(#address{jid = undefined} =
+			  Addr) ->
+    #dest{jid_string = none, address = Addr};
+convert_dest_record_1(#address{jid = JID, type = Type} =
+			  Addr) ->
+    #dest{jid_string = jid:encode(JID), jid_jid = JID,
+	  type = Type, address = Addr}.
 
 %%%-------------------------
 %%% Split destinations by existence of JID
@@ -1178,14 +1179,14 @@ mod_opt_type(hosts) -> fun ejabberd_config:v_hosts/1;
 mod_opt_type(name) -> fun iolist_to_binary/1;
 mod_opt_type({limits, Type})
     when (Type == local) or (Type == remote) ->
-    fun (L) ->
-	    lists:map(fun ({message, infinite} = O) -> O;
-			  ({presence, infinite} = O) -> O;
-			  ({message, I} = O) when is_integer(I) -> O;
-			  ({presence, I} = O) when is_integer(I) -> O
-		      end,
-		      L)
-    end.
+    fun (L) -> [mod_opt_type_1(V1) || V1 <- L] end.
+
+mod_opt_type_1({message, infinite} = O) -> O;
+mod_opt_type_1({presence, infinite} = O) -> O;
+mod_opt_type_1({message, I} = O) when is_integer(I) ->
+    O;
+mod_opt_type_1({presence, I} = O) when is_integer(I) ->
+    O.
 
 mod_options(_Host) ->
     [{access, all}, {host, <<"multicast.@HOST@">>},
diff --git a/src/mod_offline.erl b/src/mod_offline.erl
index 5f4ccd3..71b1390 100644
--- a/src/mod_offline.erl
+++ b/src/mod_offline.erl
@@ -243,15 +243,14 @@ get_sm_items(_Acc, #jid{luser = U, lserver = S} = JID,
     Mod = gen_mod:db_mod(S, ?MODULE),
     Hdrs = Mod:read_message_headers(U, S),
     BareJID = jid:remove_resource(JID),
-    {result,
-     lists:map(fun ({Seq, From, _To, _TS, _El}) ->
-		       Node = integer_to_binary(Seq),
-		       #disco_item{jid = BareJID, node = Node,
-				   name = jid:encode(From)}
-	       end,
-	       Hdrs)};
+    {result, [get_sm_items_1(V1, BareJID) || V1 <- Hdrs]};
 get_sm_items(Acc, _From, _To, _Node, _Lang) -> Acc.
 
+get_sm_items_1({Seq, From, _To, _TS, _El}, BareJID) ->
+    Node = integer_to_binary(Seq),
+    #disco_item{jid = BareJID, node = Node,
+		name = jid:encode(From)}.
+
 - spec ( { { get_info , 5 } , [ { type , 230 , 'fun' , [ { type , 230 , product , [ { type , 230 , list , [ { type , 230 , xdata , [ ] } ] } , { type , 230 , binary , [ ] } , { type , 230 , module , [ ] } , { type , 230 , binary , [ ] } , { type , 230 , binary , [ ] } ] } , { type , 230 , list , [ { type , 230 , xdata , [ ] } ] } ] } , { type , 231 , 'fun' , [ { type , 231 , product , [ { type , 231 , list , [ { type , 231 , xdata , [ ] } ] } , { type , 231 , jid , [ ] } , { type , 231 , jid , [ ] } , { type , 231 , binary , [ ] } , { type , 231 , binary , [ ] } ] } , { type , 231 , list , [ { type , 231 , xdata , [ ] } ] } ] } ] } ) .
 
 
@@ -660,34 +659,33 @@ read_messages(LUser, LServer) ->
 		  Mod:read_message_headers(LUser, LServer)).
 
 format_user_queue(Hdrs) ->
-    lists:map(fun ({Seq, From, To, TS, El}) ->
-		      ID = integer_to_binary(Seq),
-		      FPacket = ejabberd_web_admin:pretty_print_xml(El),
-		      SFrom = jid:encode(From),
-		      STo = jid:encode(To),
-		      Time = case TS of
-			       undefined ->
-				   Stamp = fxml:get_path_s(El,
-							   [{elem, <<"delay">>},
-							    {attr,
-							     <<"stamp">>}]),
-				   try xmpp_util:decode_timestamp(Stamp) of
-				     {_, _, _} = Now -> format_time(Now)
-				   catch
-				     _:_ -> <<"">>
-				   end;
-			       {_, _, _} = Now -> format_time(Now)
-			     end,
-		      ?XE(<<"tr">>,
-			  [?XAE(<<"td">>, [{<<"class">>, <<"valign">>}],
-				[?INPUT(<<"checkbox">>, <<"selected">>, ID)]),
-			   ?XAC(<<"td">>, [{<<"class">>, <<"valign">>}], Time),
-			   ?XAC(<<"td">>, [{<<"class">>, <<"valign">>}], SFrom),
-			   ?XAC(<<"td">>, [{<<"class">>, <<"valign">>}], STo),
-			   ?XAE(<<"td">>, [{<<"class">>, <<"valign">>}],
-				[?XC(<<"pre">>, FPacket)])])
-	      end,
-	      Hdrs).
+    [format_user_queue_1(V1) || V1 <- Hdrs].
+
+format_user_queue_1({Seq, From, To, TS, El}) ->
+    ID = integer_to_binary(Seq),
+    FPacket = ejabberd_web_admin:pretty_print_xml(El),
+    SFrom = jid:encode(From),
+    STo = jid:encode(To),
+    Time = case TS of
+	     undefined ->
+		 Stamp = fxml:get_path_s(El,
+					 [{elem, <<"delay">>},
+					  {attr, <<"stamp">>}]),
+		 try xmpp_util:decode_timestamp(Stamp) of
+		   {_, _, _} = Now -> format_time(Now)
+		 catch
+		   _:_ -> <<"">>
+		 end;
+	     {_, _, _} = Now -> format_time(Now)
+	   end,
+    ?XE(<<"tr">>,
+	[?XAE(<<"td">>, [{<<"class">>, <<"valign">>}],
+	      [?INPUT(<<"checkbox">>, <<"selected">>, ID)]),
+	 ?XAC(<<"td">>, [{<<"class">>, <<"valign">>}], Time),
+	 ?XAC(<<"td">>, [{<<"class">>, <<"valign">>}], SFrom),
+	 ?XAC(<<"td">>, [{<<"class">>, <<"valign">>}], STo),
+	 ?XAE(<<"td">>, [{<<"class">>, <<"valign">>}],
+	      [?XC(<<"pre">>, FPacket)])]).
 
 format_time(Now) ->
     {{Year, Month, Day}, {Hour, Minute, Second}} =
diff --git a/src/mod_offline_mnesia.erl b/src/mod_offline_mnesia.erl
index 5b05977..b6f1ea3 100644
--- a/src/mod_offline_mnesia.erl
+++ b/src/mod_offline_mnesia.erl
@@ -109,13 +109,13 @@ remove_user(LUser, LServer) ->
 read_message_headers(LUser, LServer) ->
     Msgs = mnesia:dirty_read({offline_msg,
 			      {LUser, LServer}}),
-    Hdrs = lists:map(fun (#offline_msg{from = From, to = To,
-				       packet = Pkt, timestamp = TS}) ->
-			     Seq = now_to_integer(TS), {Seq, From, To, TS, Pkt}
-		     end,
-		     Msgs),
+    Hdrs = [read_message_headers_1(V1) || V1 <- Msgs],
     lists:keysort(1, Hdrs).
 
+read_message_headers_1(#offline_msg{from = From,
+				    to = To, packet = Pkt, timestamp = TS}) ->
+    Seq = now_to_integer(TS), {Seq, From, To, TS, Pkt}.
+
 read_message(LUser, LServer, I) ->
     US = {LUser, LServer},
     TS = integer_to_now(I),
diff --git a/src/mod_offline_riak.erl b/src/mod_offline_riak.erl
index 5c15d0e..c396156 100644
--- a/src/mod_offline_riak.erl
+++ b/src/mod_offline_riak.erl
@@ -85,16 +85,15 @@ read_message_headers(LUser, LServer) ->
 				    {LUser, LServer})
 	of
       {ok, Rs} ->
-	  Hdrs = lists:map(fun (#offline_msg{from = From, to = To,
-					     packet = Pkt, timestamp = TS}) ->
-				   Seq = now_to_integer(TS),
-				   {Seq, From, To, TS, Pkt}
-			   end,
-			   Rs),
+	  Hdrs = [read_message_headers_1(V1) || V1 <- Rs],
 	  lists:keysort(1, Hdrs);
       _Err -> []
     end.
 
+read_message_headers_1(#offline_msg{from = From,
+				    to = To, packet = Pkt, timestamp = TS}) ->
+    Seq = now_to_integer(TS), {Seq, From, To, TS, Pkt}.
+
 read_message(_LUser, _LServer, I) ->
     TS = integer_to_now(I),
     case ejabberd_riak:get(offline_msg,
diff --git a/src/mod_privacy.erl b/src/mod_privacy.erl
index 2221cc9..2345a3e 100644
--- a/src/mod_privacy.erl
+++ b/src/mod_privacy.erl
@@ -225,7 +225,7 @@ process_list_get(#iq{from =
 		 Name) ->
     case get_user_list(LUser, LServer, Name) of
       {ok, {_, List}} ->
-	  Items = lists:map(fun encode_list_item/1, List),
+	  Items = [encode_list_item(V1) || V1 <- List],
 	  xmpp:make_iq_result(IQ,
 			      #privacy_query{lists =
 						 [#privacy_list{name = Name,
@@ -414,7 +414,7 @@ process_lists_set(#iq{from =
 		      lang = Lang} =
 		      IQ,
 		  Name, Items) ->
-    case catch lists:map(fun decode_item/1, Items) of
+    case catch [decode_item(V1) || V1 <- Items] of
       {error, Why} ->
 	  Txt = xmpp:io_format_error(Why),
 	  xmpp:make_error(IQ, xmpp:err_bad_request(Txt, Lang));
diff --git a/src/mod_privacy_mnesia.erl b/src/mod_privacy_mnesia.erl
index e756b39..3a54cdc 100644
--- a/src/mod_privacy_mnesia.erl
+++ b/src/mod_privacy_mnesia.erl
@@ -149,32 +149,7 @@ need_transform(_) -> false.
 transform(#privacy{us = {U, S}, default = Def,
 		   lists = Lists} =
 	      R) ->
-    NewLists = lists:map(fun ({Name, Ls}) ->
-				 NewLs = lists:map(fun (#listitem{value = Val} =
-							    L) ->
-							   NewVal = case Val of
-								      {LU, LS,
-								       LR} ->
-									  {iolist_to_binary(LU),
-									   iolist_to_binary(LS),
-									   iolist_to_binary(LR)};
-								      none ->
-									  none;
-								      both ->
-									  both;
-								      from ->
-									  from;
-								      to -> to;
-								      _ ->
-									  iolist_to_binary(Val)
-								    end,
-							   L#listitem{value =
-									  NewVal}
-						   end,
-						   Ls),
-				 {iolist_to_binary(Name), NewLs}
-			 end,
-			 Lists),
+    NewLists = [transform_2(V2) || V2 <- Lists],
     NewDef = case Def of
 	       none -> none;
 	       _ -> iolist_to_binary(Def)
@@ -183,6 +158,23 @@ transform(#privacy{us = {U, S}, default = Def,
     R#privacy{us = NewUS, default = NewDef,
 	      lists = NewLists}.
 
+transform_1(#listitem{value = Val} = L) ->
+    NewVal = case Val of
+	       {LU, LS, LR} ->
+		   {iolist_to_binary(LU), iolist_to_binary(LS),
+		    iolist_to_binary(LR)};
+	       none -> none;
+	       both -> both;
+	       from -> from;
+	       to -> to;
+	       _ -> iolist_to_binary(Val)
+	     end,
+    L#listitem{value = NewVal}.
+
+transform_2({Name, Ls}) ->
+    NewLs = [transform_1(V1) || V1 <- Ls],
+    {iolist_to_binary(Name), NewLs}.
+
 %%%===================================================================
 %%% Internal functions
 %%%===================================================================
diff --git a/src/mod_privacy_sql.erl b/src/mod_privacy_sql.erl
index 6f73efa..3efdb49 100644
--- a/src/mod_privacy_sql.erl
+++ b/src/mod_privacy_sql.erl
@@ -88,8 +88,7 @@ set_lists(#privacy{us = {LUser, LServer},
 				      {selected, [<<"id">>], [[I]]} =
 					  get_privacy_list_id_t(LUser, LServer,
 								Name),
-				      RItems = lists:map(fun item_to_raw/1,
-							 List),
+				      RItems = [item_to_raw(V1) || V1 <- List],
 				      set_privacy_list(I, RItems),
 				      if is_binary(Default) ->
 					     set_default_privacy_list(LUser,
@@ -103,7 +102,7 @@ set_lists(#privacy{us = {LUser, LServer},
     transaction(LServer, F).
 
 set_list(LUser, LServer, Name, List) ->
-    RItems = lists:map(fun item_to_raw/1, List),
+    RItems = [item_to_raw(V1) || V1 <- List],
     F = fun () ->
 		ID = case get_privacy_list_id_t(LUser, LServer, Name) of
 		       {selected, []} ->
@@ -200,8 +199,7 @@ export(Server) ->
 	      end
 		++
 		lists:flatmap(fun ({Name, List}) ->
-				      RItems = lists:map(fun item_to_raw/1,
-							 List),
+				      RItems = [item_to_raw(V1) || V1 <- List],
 				      ID = get_id(),
 				      [?SQL("delete from privacy_list where username=%(LUs"
 					    "er)s and %(LServer)H and name=%(Name)s;"),
diff --git a/src/mod_proxy65_service.erl b/src/mod_proxy65_service.erl
index 86d5478..d4ff1db 100644
--- a/src/mod_proxy65_service.erl
+++ b/src/mod_proxy65_service.erl
@@ -280,13 +280,15 @@ process_bytestreams(#iq{type = set, lang = Lang,
 %%% Auxiliary functions.
 %%%-------------------------
 transform_module_options(Opts) ->
-    lists:map(fun ({ip, IP}) when is_tuple(IP) ->
-		      {ip, misc:ip_to_list(IP)};
-		  ({hostname, IP}) when is_tuple(IP) ->
-		      {hostname, misc:ip_to_list(IP)};
-		  (Opt) -> Opt
-	      end,
-	      Opts).
+    [transform_module_options_1(V1) || V1 <- Opts].
+
+transform_module_options_1({ip, IP})
+    when is_tuple(IP) ->
+    {ip, misc:ip_to_list(IP)};
+transform_module_options_1({hostname, IP})
+    when is_tuple(IP) ->
+    {hostname, misc:ip_to_list(IP)};
+transform_module_options_1(Opt) -> Opt.
 
 - spec ( { { get_streamhost , 2 } , [ { type , 239 , 'fun' , [ { type , 239 , product , [ { type , 239 , binary , [ ] } , { type , 239 , binary , [ ] } ] } , { type , 239 , streamhost , [ ] } ] } ] } ) .
 
diff --git a/src/mod_pubsub.erl b/src/mod_pubsub.erl
index b36a26e..db29a10 100644
--- a/src/mod_pubsub.erl
+++ b/src/mod_pubsub.erl
@@ -1360,19 +1360,9 @@ iq_disco_info(ServerHost, Host, SNode, From, Lang) ->
 
 
 iq_disco_items(Host, <<>>, From, _RSM) ->
-    Items = lists:map(fun (#pubsub_node{nodeid =
-					    {_, SubNode},
-					options = Options}) ->
-			      case get_option(Options, title) of
-				false ->
-				    #disco_item{jid = jid:make(Host),
-						node = SubNode};
-				Title ->
-				    #disco_item{jid = jid:make(Host),
-						name = Title, node = SubNode}
-			      end
-		      end,
-		      tree_action(Host, get_subnodes, [Host, <<>>, From])),
+    Items = [iq_disco_items_1(V1, Host)
+	     || V1
+		    <- tree_action(Host, get_subnodes, [Host, <<>>, From])],
     {result, #disco_items{items = Items}};
 iq_disco_items(Host, ?NS_COMMANDS, _From, _RSM) ->
     {result,
@@ -1402,41 +1392,12 @@ iq_disco_items(Host, Item, From, RSM) ->
 						   {result, R} -> R;
 						   _ -> {[], undefined}
 						 end,
-			   Nodes = lists:map(fun (#pubsub_node{nodeid =
-								   {_, SubNode},
-							       options =
-								   SubOptions}) ->
-						     case get_option(SubOptions,
-								     title)
-							 of
-						       false ->
-							   #disco_item{jid =
-									   jid:make(Host),
-								       node =
-									   SubNode};
-						       Title ->
-							   #disco_item{jid =
-									   jid:make(Host),
-								       name =
-									   Title,
-								       node =
-									   SubNode}
-						     end
-					     end,
-					     tree_call(Host, get_subnodes,
-						       [Host, Node, From])),
-			   Items = lists:map(fun (#pubsub_item{itemid =
-								   {RN, _}}) ->
-						     {result, Name} =
-							 node_call(Host, Type,
-								   get_item_name,
-								   [Host, Node,
-								    RN]),
-						     #disco_item{jid =
-								     jid:make(Host),
-								 name = Name}
-					     end,
-					     NodeItems),
+			   Nodes = [iq_disco_items_2(V2, Host)
+				    || V2
+					   <- tree_call(Host, get_subnodes,
+							[Host, Node, From])],
+			   Items = [iq_disco_items_1(V3, Host, Node, Type)
+				    || V3 <- NodeItems],
 			   {result,
 			    #disco_items{items = Nodes ++ Items, rsm = RsmOut}}
 		   end,
@@ -1446,6 +1407,34 @@ iq_disco_items(Host, Item, From, RSM) ->
 	  end
     end.
 
+iq_disco_items_1(#pubsub_node{nodeid = {_, SubNode},
+			      options = Options},
+		 Host) ->
+    case get_option(Options, title) of
+      false ->
+	  #disco_item{jid = jid:make(Host), node = SubNode};
+      Title ->
+	  #disco_item{jid = jid:make(Host), name = Title,
+		      node = SubNode}
+    end.
+
+iq_disco_items_2(#pubsub_node{nodeid = {_, SubNode},
+			      options = SubOptions},
+		 Host) ->
+    case get_option(SubOptions, title) of
+      false ->
+	  #disco_item{jid = jid:make(Host), node = SubNode};
+      Title ->
+	  #disco_item{jid = jid:make(Host), name = Title,
+		      node = SubNode}
+    end.
+
+iq_disco_items_1(#pubsub_item{itemid = {RN, _}}, Host,
+		 Node, Type) ->
+    {result, Name} = node_call(Host, Type, get_item_name,
+			       [Host, Node, RN]),
+    #disco_item{jid = jid:make(Host), name = Name}.
+
 - spec ( { { iq_sm , 1 } , [ { type , 1063 , 'fun' , [ { type , 1063 , product , [ { type , 1063 , iq , [ ] } ] } , { type , 1063 , iq , [ ] } ] } ] } ) .
 
 
@@ -1900,10 +1889,7 @@ handle_authorization_response(Host,
 
 update_auth(Host, Node, Type, Nidx, Subscriber, Allow,
 	    Subs) ->
-    Sub = lists:filter(fun ({pending, _}) -> true;
-			   (_) -> false
-		       end,
-		       Subs),
+    Sub = [V1 || V1 <- Subs, update_auth_1(V1)],
     case Sub of
       [{pending, SubId} | _] ->
 	  NewSub = case Allow of
@@ -1922,6 +1908,9 @@ update_auth(Host, Node, Type, Nidx, Subscriber, Allow,
 				       ejabberd_config:get_mylang())}
     end.
 
+update_auth_1({pending, _}) -> true;
+update_auth_1(_) -> false.
+
 %% @doc <p>Create new pubsub nodes</p>
 %%<p>In addition to method-specific error conditions, there are several general reasons why the node creation request might fail:</p>
 %%<ul>
@@ -2619,12 +2608,7 @@ get_items(Host, Node, From, SubId, _MaxItems, ItemIds,
       {result, {TNode, {Items, RsmOut}}} ->
 	  SendItems = case ItemIds of
 			[] -> Items;
-			_ ->
-			    lists:filter(fun (#pubsub_item{itemid =
-							       {ItemId, _}}) ->
-						 lists:member(ItemId, ItemIds)
-					 end,
-					 Items)
+			_ -> [V1 || V1 <- Items, get_items_1(V1, ItemIds)]
 		      end,
 	  Options = TNode#pubsub_node.options,
 	  {result,
@@ -2637,6 +2621,10 @@ get_items(Host, Node, From, SubId, _MaxItems, ItemIds,
       Error -> Error
     end.
 
+get_items_1(#pubsub_item{itemid = {ItemId, _}},
+	    ItemIds) ->
+    lists:member(ItemId, ItemIds).
+
 get_items(Host, Node) ->
     Action = fun (#pubsub_node{type = Type, id = Nidx}) ->
 		     node_call(Host, Type, get_items,
@@ -4077,15 +4065,16 @@ max_items(Host, Options) ->
 
 
 get_configure_xfields(_Type, Options, Lang, Groups) ->
-    pubsub_node_config:encode(lists:map(fun
-					  ({roster_groups_allowed, Value}) ->
-					      {roster_groups_allowed, Value,
-					       Groups};
-					  (Opt) -> Opt
-					end,
-					Options),
+    pubsub_node_config:encode([get_configure_xfields_1(V1,
+						       Groups)
+			       || V1 <- Options],
 			      Lang).
 
+get_configure_xfields_1({roster_groups_allowed, Value},
+			Groups) ->
+    {roster_groups_allowed, Value, Groups};
+get_configure_xfields_1(Opt, Groups) -> Opt.
+
 %%<p>There are several reasons why the node configuration request might fail:</p>
 %%<ul>
 %%<li>The service does not support node configuration.</li>
@@ -4874,13 +4863,7 @@ mod_opt_type(max_subscriptions_node) ->
 	(undefined) -> undefined
     end;
 mod_opt_type(force_node_config) ->
-    fun (NodeOpts) ->
-	    lists:map(fun ({Node, Opts}) ->
-			      {ok, RE} =
-				  re:compile(ejabberd_regexp:sh_to_awk(Node)),
-			      {RE, lists:keysort(1, Opts)}
-		      end,
-		      NodeOpts)
+    fun (NodeOpts) -> [mod_opt_type_1(V1) || V1 <- NodeOpts]
     end;
 mod_opt_type(default_node_config) ->
     fun (A) when is_list(A) -> A end;
@@ -4891,6 +4874,10 @@ mod_opt_type(pep_mapping) ->
 mod_opt_type(plugins) ->
     fun (A) when is_list(A) -> A end.
 
+mod_opt_type_1({Node, Opts}) ->
+    {ok, RE} = re:compile(ejabberd_regexp:sh_to_awk(Node)),
+    {RE, lists:keysort(1, Opts)}.
+
 mod_options(Host) ->
     [{access_createnode, all},
      {db_type, ejabberd_config:default_db(Host, ?MODULE)},
diff --git a/src/mod_push.erl b/src/mod_push.erl
index 2cf66ab..6501b89 100644
--- a/src/mod_push.erl
+++ b/src/mod_push.erl
@@ -218,25 +218,13 @@ delete_old_sessions(Days) ->
     CurrentTime = p1_time_compat:system_time(micro_seconds),
     Diff = Days * 24 * 60 * 60 * 1000000,
     TimeStamp = misc:usec_to_now(CurrentTime - Diff),
-    DBTypes = lists:usort(lists:map(fun (Host) ->
-					    case gen_mod:get_module_opt(Host,
-									?MODULE,
-									db_type)
-						of
-					      sql -> {sql, Host};
-					      Other -> {Other, global}
-					    end
-				    end,
-				    ejabberd_config:get_myhosts())),
-    Results = lists:map(fun ({DBType, Host}) ->
-				Mod = gen_mod:db_mod(DBType, ?MODULE),
-				Mod:delete_old_sessions(Host, TimeStamp)
-			end,
-			DBTypes),
+    DBTypes = lists:usort([delete_old_sessions_1(V1)
+			   || V1 <- ejabberd_config:get_myhosts()]),
+    Results = [delete_old_sessions_1(V2, TimeStamp)
+	       || V2 <- DBTypes],
     ets_cache:clear(?PUSH_CACHE,
 		    ejabberd_cluster:get_nodes()),
-    case lists:filter(fun (Res) -> Res /= ok end, Results)
-	of
+    case [V3 || V3 <- Results, delete_old_sessions_2(V3)] of
       [] ->
 	  ?INFO_MSG("Deleted push sessions older than ~B "
 		    "days",
@@ -248,6 +236,18 @@ delete_old_sessions(Days) ->
 	  NotOk
     end.
 
+delete_old_sessions_1(Host) ->
+    case gen_mod:get_module_opt(Host, ?MODULE, db_type) of
+      sql -> {sql, Host};
+      Other -> {Other, global}
+    end.
+
+delete_old_sessions_1({DBType, Host}, TimeStamp) ->
+    Mod = gen_mod:db_mod(DBType, ?MODULE),
+    Mod:delete_old_sessions(Host, TimeStamp).
+
+delete_old_sessions_2(Res) -> Res /= ok.
+
 %%--------------------------------------------------------------------
 %% Register/unregister hooks.
 %%--------------------------------------------------------------------
diff --git a/src/mod_push_sql.erl b/src/mod_push_sql.erl
index 7784af6..366cfe5 100644
--- a/src/mod_push_sql.erl
+++ b/src/mod_push_sql.erl
@@ -107,15 +107,17 @@ lookup_sessions(LUser, LServer, PushJID) ->
 	of
       {selected, Rows} ->
 	  {ok,
-	   lists:map(fun ({TS, XML, Node}) ->
-			     NowTS = misc:usec_to_now(TS),
-			     XData = decode_xdata(XML, LUser, LServer),
-			     {NowTS, PushLJID, Node, XData}
-		     end,
-		     Rows)};
+	   [lookup_sessions_1(V1, LServer, LUser, PushLJID)
+	    || V1 <- Rows]};
       _Err -> {error, db_failure}
     end.
 
+lookup_sessions_1({TS, XML, Node}, LServer, LUser,
+		  PushLJID) ->
+    NowTS = misc:usec_to_now(TS),
+    XData = decode_xdata(XML, LUser, LServer),
+    {NowTS, PushLJID, Node, XData}.
+
 lookup_sessions(LUser, LServer) ->
     case ejabberd_sql:sql_query(LServer,
 				?SQL("select @(timestamp)d, @(xml)s, @(node)s, "
@@ -124,16 +126,17 @@ lookup_sessions(LUser, LServer) ->
 	of
       {selected, Rows} ->
 	  {ok,
-	   lists:map(fun ({TS, XML, Node, Service}) ->
-			     NowTS = misc:usec_to_now(TS),
-			     XData = decode_xdata(XML, LUser, LServer),
-			     PushLJID = jid:tolower(jid:decode(Service)),
-			     {NowTS, PushLJID, Node, XData}
-		     end,
-		     Rows)};
+	   [lookup_sessions_1(V1, LServer, LUser) || V1 <- Rows]};
       _Err -> {error, db_failure}
     end.
 
+lookup_sessions_1({TS, XML, Node, Service}, LServer,
+		  LUser) ->
+    NowTS = misc:usec_to_now(TS),
+    XData = decode_xdata(XML, LUser, LServer),
+    PushLJID = jid:tolower(jid:decode(Service)),
+    {NowTS, PushLJID, Node, XData}.
+
 lookup_sessions(LServer) ->
     case ejabberd_sql:sql_query(LServer,
 				?SQL("select @(username)s, @(timestamp)d, "
@@ -141,17 +144,17 @@ lookup_sessions(LServer) ->
 				     "push_session where %(LServer)H"))
 	of
       {selected, Rows} ->
-	  {ok,
-	   lists:map(fun ({LUser, TS, XML, Node, Service}) ->
-			     NowTS = misc:usec_to_now(TS),
-			     XData = decode_xdata(XML, LUser, LServer),
-			     PushLJID = jid:tolower(jid:decode(Service)),
-			     {NowTS, PushLJID, Node, XData}
-		     end,
-		     Rows)};
+	  {ok, [lookup_sessions_1(V1, LServer) || V1 <- Rows]};
       _Err -> {error, db_failure}
     end.
 
+lookup_sessions_1({LUser, TS, XML, Node, Service},
+		  LServer) ->
+    NowTS = misc:usec_to_now(TS),
+    XData = decode_xdata(XML, LUser, LServer),
+    PushLJID = jid:tolower(jid:decode(Service)),
+    {NowTS, PushLJID, Node, XData}.
+
 delete_session(LUser, LServer, NowTS) ->
     TS = misc:now_to_usec(NowTS),
     case ejabberd_sql:sql_query(LServer,
diff --git a/src/mod_register_web.erl b/src/mod_register_web.erl
index 7e1c9fa..fb937b8 100644
--- a/src/mod_register_web.erl
+++ b/src/mod_register_web.erl
@@ -325,14 +325,16 @@ form_new_post(Q) ->
     end.
 
 get_register_parameters(Q) ->
-    lists:map(fun (Key) ->
-		      case lists:keysearch(Key, 1, Q) of
-			{value, {_Key, Value}} -> Value;
-			false -> false
-		      end
-	      end,
-	      [<<"username">>, <<"host">>, <<"password">>,
-	       <<"password2">>, <<"id">>, <<"key">>]).
+    [get_register_parameters_1(V1, Q)
+     || V1
+	    <- [<<"username">>, <<"host">>, <<"password">>,
+		<<"password2">>, <<"id">>, <<"key">>]].
+
+get_register_parameters_1(Key, Q) ->
+    case lists:keysearch(Key, 1, Q) of
+      {value, {_Key, Value}} -> Value;
+      false -> false
+    end.
 
 form_new_post(Username, Host, Password,
 	      {false, false}) ->
@@ -438,12 +440,14 @@ get_changepass_parameters(Q) ->
     %%                                              {error, account_doesnt_exist} |
     %%                                              {error, password_not_changed} |
     %%                                              {error, password_incorrect}
-    lists:map(fun (Key) ->
-		      {value, {_Key, Value}} = lists:keysearch(Key, 1, Q),
-		      Value
-	      end,
-	      [<<"username">>, <<"host">>, <<"passwordold">>,
-	       <<"password">>, <<"password2">>]).
+    [get_changepass_parameters_1(V1, Q)
+     || V1
+	    <- [<<"username">>, <<"host">>, <<"passwordold">>,
+		<<"password">>, <<"password2">>]].
+
+get_changepass_parameters_1(Key, Q) ->
+    {value, {_Key, Value}} = lists:keysearch(Key, 1, Q),
+    Value.
 
 try_change_password(Username, Host, PasswordOld,
 		    Password) ->
@@ -561,11 +565,12 @@ get_unregister_parameters(Q) ->
     %%                                    {error, account_doesnt_exist} |
     %%                                    {error, account_exists} |
     %%                                    {error, password_incorrect}
-    lists:map(fun (Key) ->
-		      {value, {_Key, Value}} = lists:keysearch(Key, 1, Q),
-		      Value
-	      end,
-	      [<<"username">>, <<"host">>, <<"password">>]).
+    [get_unregister_parameters_1(V1, Q)
+     || V1 <- [<<"username">>, <<"host">>, <<"password">>]].
+
+get_unregister_parameters_1(Key, Q) ->
+    {value, {_Key, Value}} = lists:keysearch(Key, 1, Q),
+    Value.
 
 try_unregister_account(Username, Host, Password) ->
     try unregister_account(Username, Host, Password) of
diff --git a/src/mod_roster.erl b/src/mod_roster.erl
index 99c114e..f9e77c2 100644
--- a/src/mod_roster.erl
+++ b/src/mod_roster.erl
@@ -324,20 +324,22 @@ process_iq_get(#iq{to = To, lang = Lang,
 						   RosterVersion =
 						       write_roster_version(LUser,
 									    LServer),
-						   {lists:map(fun encode_item/1,
-							      ejabberd_hooks:run_fold(roster_get,
-										      To#jid.lserver,
-										      [],
-										      [US])),
+						   {[encode_item(V1)
+						     || V1
+							    <- ejabberd_hooks:run_fold(roster_get,
+										       To#jid.lserver,
+										       [],
+										       [US])],
 						    RosterVersion};
 					       {ok, RequestedVersion} ->
 						   {false, false};
 					       {ok, NewVersion} ->
-						   {lists:map(fun encode_item/1,
-							      ejabberd_hooks:run_fold(roster_get,
-										      To#jid.lserver,
-										      [],
-										      [US])),
+						   {[encode_item(V2)
+						     || V2
+							    <- ejabberd_hooks:run_fold(roster_get,
+										       To#jid.lserver,
+										       [],
+										       [US])],
 						    NewVersion}
 					     end;
 					 {true, false}
@@ -352,16 +354,17 @@ process_iq_get(#iq{to = To, lang = Lang,
 					       RequestedVersion ->
 						   {false, false};
 					       New ->
-						   {lists:map(fun encode_item/1,
-							      RosterItems),
+						   {[encode_item(V3)
+						     || V3 <- RosterItems],
 						    New}
 					     end;
 					 _ ->
-					     {lists:map(fun encode_item/1,
-							ejabberd_hooks:run_fold(roster_get,
-										To#jid.lserver,
-										[],
-										[US])),
+					     {[encode_item(V4)
+					       || V4
+						      <- ejabberd_hooks:run_fold(roster_get,
+										 To#jid.lserver,
+										 [],
+										 [US])],
 					      false}
 				       end,
 	xmpp:make_iq_result(IQ,
@@ -386,13 +389,12 @@ process_iq_get(#iq{to = To, lang = Lang,
 
 get_user_roster(Acc, {LUser, LServer}) ->
     Items = get_roster(LUser, LServer),
-    lists:filter(fun (#roster{subscription = none,
-			      ask = in}) ->
-			 false;
-		     (_) -> true
-		 end,
-		 Items)
-      ++ Acc.
+    [V1 || V1 <- Items, get_user_roster_1(V1)] ++ Acc.
+
+get_user_roster_1(#roster{subscription = none,
+			  ask = in}) ->
+    false;
+get_user_roster_1(_) -> true.
 
 get_roster(LUser, LServer) ->
     Mod = gen_mod:db_mod(LServer, ?MODULE),
@@ -975,54 +977,7 @@ user_roster(User, Server, Query, Lang) ->
 				   ?XCT(<<"td">>, <<"Pending">>),
 				   ?XCT(<<"td">>, <<"Groups">>)])]),
 			 ?XE(<<"tbody">>,
-			     (lists:map(fun (R) ->
-						Groups = lists:flatmap(fun
-									 (Group) ->
-									     [?C(Group),
-									      ?BR]
-								       end,
-								       R#roster.groups),
-						Pending =
-						    ask_to_pending(R#roster.ask),
-						TDJID =
-						    build_contact_jid_td(R#roster.jid),
-						?XE(<<"tr">>,
-						    [TDJID,
-						     ?XAC(<<"td">>,
-							  [{<<"class">>,
-							    <<"valign">>}],
-							  (R#roster.name)),
-						     ?XAC(<<"td">>,
-							  [{<<"class">>,
-							    <<"valign">>}],
-							  (iolist_to_binary(atom_to_list(R#roster.subscription)))),
-						     ?XAC(<<"td">>,
-							  [{<<"class">>,
-							    <<"valign">>}],
-							  (iolist_to_binary(atom_to_list(Pending)))),
-						     ?XAE(<<"td">>,
-							  [{<<"class">>,
-							    <<"valign">>}],
-							  Groups),
-						     if Pending == in ->
-							    ?XAE(<<"td">>,
-								 [{<<"class">>,
-								   <<"valign">>}],
-								 [?INPUTT(<<"submit">>,
-									  <<"validate",
-									    (ejabberd_web_admin:term_to_id(R#roster.jid))/binary>>,
-									  <<"Validate">>)]);
-							true -> ?X(<<"td">>)
-						     end,
-						     ?XAE(<<"td">>,
-							  [{<<"class">>,
-							    <<"valign">>}],
-							  [?INPUTT(<<"submit">>,
-								   <<"remove",
-								     (ejabberd_web_admin:term_to_id(R#roster.jid))/binary>>,
-								   <<"Remove">>)])])
-					end,
-					SItems)))])]
+			     [user_roster_1(V1) || V1 <- SItems])])]
 	     end,
     [?XC(<<"h1">>,
 	 <<(?T(<<"Roster of ">>))/binary,
@@ -1042,6 +997,35 @@ user_roster(User, Server, Query, Lang) ->
 		  ?INPUTT(<<"submit">>, <<"addjid">>,
 			  <<"Add Jabber ID">>)]))].
 
+user_roster_1(R) ->
+    Groups = lists:flatmap(fun (Group) -> [?C(Group), ?BR]
+			   end,
+			   R#roster.groups),
+    Pending = ask_to_pending(R#roster.ask),
+    TDJID = build_contact_jid_td(R#roster.jid),
+    ?XE(<<"tr">>,
+	[TDJID,
+	 ?XAC(<<"td">>, [{<<"class">>, <<"valign">>}],
+	      (R#roster.name)),
+	 ?XAC(<<"td">>, [{<<"class">>, <<"valign">>}],
+	      (iolist_to_binary(atom_to_list(R#roster.subscription)))),
+	 ?XAC(<<"td">>, [{<<"class">>, <<"valign">>}],
+	      (iolist_to_binary(atom_to_list(Pending)))),
+	 ?XAE(<<"td">>, [{<<"class">>, <<"valign">>}], Groups),
+	 if Pending == in ->
+		?XAE(<<"td">>, [{<<"class">>, <<"valign">>}],
+		     [?INPUTT(<<"submit">>,
+			      <<"validate",
+				(ejabberd_web_admin:term_to_id(R#roster.jid))/binary>>,
+			      <<"Validate">>)]);
+	    true -> ?X(<<"td">>)
+	 end,
+	 ?XAE(<<"td">>, [{<<"class">>, <<"valign">>}],
+	      [?INPUTT(<<"submit">>,
+		       <<"remove",
+			 (ejabberd_web_admin:term_to_id(R#roster.jid))/binary>>,
+		       <<"Remove">>)])]).
+
 build_contact_jid_td(RosterJID) ->
     ContactJID = jid:make(RosterJID),
     JIDURI = case {ContactJID#jid.luser,
diff --git a/src/mod_service_log.erl b/src/mod_service_log.erl
index 39db996..1b58027 100644
--- a/src/mod_service_log.erl
+++ b/src/mod_service_log.erl
@@ -84,13 +84,11 @@ log_packet(Packet, Host) ->
 		  Loggers).
 
 mod_opt_type(loggers) ->
-    fun (L) ->
-	    lists:map(fun (S) ->
-			      B = iolist_to_binary(S),
-			      N = jid:nameprep(B),
-			      if N /= error -> N end
-		      end,
-		      L)
-    end.
+    fun (L) -> [mod_opt_type_1(V1) || V1 <- L] end.
+
+mod_opt_type_1(S) ->
+    B = iolist_to_binary(S),
+    N = jid:nameprep(B),
+    if N /= error -> N end.
 
 mod_options(_) -> [{loggers, []}].
diff --git a/src/mod_shared_roster.erl b/src/mod_shared_roster.erl
index 4def8ff..1043b74 100644
--- a/src/mod_shared_roster.erl
+++ b/src/mod_shared_roster.erl
@@ -246,18 +246,15 @@ process_item(RosterItem, Host) ->
     NameTo = RosterItem#roster.name,
     USTo = {UserTo, ServerTo},
     DisplayedGroups = get_user_displayed_groups(USFrom),
-    CommonGroups = lists:filter(fun (Group) ->
-					is_user_in_group(USTo, Group, Host)
-				end,
-				DisplayedGroups),
+    CommonGroups = [V1
+		    || V1 <- DisplayedGroups,
+		       process_item_1(V1, Host, USTo)],
     case CommonGroups of
       [] -> RosterItem;
       %% Roster item cannot be removed: We simply reset the original groups:
       _ when RosterItem#roster.subscription == remove ->
-	  GroupNames = lists:map(fun (Group) ->
-					 get_group_name(Host, Group)
-				 end,
-				 CommonGroups),
+	  GroupNames = [process_item_1(V2, Host)
+			|| V2 <- CommonGroups],
 	  RosterItem#roster{subscription = both, ask = none,
 			    groups = GroupNames};
       %% Both users have at least a common shared group,
@@ -282,6 +279,12 @@ process_item(RosterItem, Host) ->
 	  end
     end.
 
+process_item_1(Group, Host, USTo) ->
+    is_user_in_group(USTo, Group, Host).
+
+process_item_1(Group, Host) ->
+    get_group_name(Host, Group).
+
 build_roster_record(User1, Server1, User2, Server2,
 		    Name2, Groups) ->
     USR2 = {User2, Server2, <<"">>},
@@ -502,18 +505,22 @@ get_group_name(Host1, Group1) ->
 
 %% Get list of names of groups that have @all@/@online@/etc in the memberlist
 get_special_users_groups(Host) ->
-    lists:filter(fun (Group) ->
-			 get_group_opt(Host, Group, all_users, false) orelse
-			   get_group_opt(Host, Group, online_users, false)
-		 end,
-		 list_groups(Host)).
+    [V1
+     || V1 <- list_groups(Host),
+	get_special_users_groups_1(V1, Host)].
+
+get_special_users_groups_1(Group, Host) ->
+    get_group_opt(Host, Group, all_users, false) orelse
+      get_group_opt(Host, Group, online_users, false).
 
 %% Get list of names of groups that have @online@ in the memberlist
 get_special_users_groups_online(Host) ->
-    lists:filter(fun (Group) ->
-			 get_group_opt(Host, Group, online_users, false)
-		 end,
-		 list_groups(Host)).
+    [V1
+     || V1 <- list_groups(Host),
+	get_special_users_groups_online_1(V1, Host)].
+
+get_special_users_groups_online_1(Group, Host) ->
+    get_group_opt(Host, Group, online_users, false).
 
 %% Given two lists of groupnames and their options,
 %% return the list of displayed groups to the second list
@@ -540,12 +547,14 @@ displayed_groups(GroupsOpts, SelectedGroupsOpts) ->
 %% for those that have @all@ in memberlist,
 %% get the list of groups displayed
 get_special_displayed_groups(GroupsOpts) ->
-    Groups = lists:filter(fun ({_Group, Opts}) ->
-				  proplists:get_value(all_users, Opts, false)
-			  end,
-			  GroupsOpts),
+    Groups = [V1
+	      || V1 <- GroupsOpts,
+		 get_special_displayed_groups_1(V1)],
     displayed_groups(GroupsOpts, Groups).
 
+get_special_displayed_groups_1({_Group, Opts}) ->
+    proplists:get_value(all_users, Opts, false).
+
 %% Given a username and server, and a list of group names with options,
 %% for the list of groups of that server that user is member
 %% get the list of groups displayed
@@ -628,13 +637,13 @@ remove_user_from_group(Host, US, Group) ->
 						       Group),
 	  NewGroupOpts = case LUser of
 			   <<"@all@">> ->
-			       lists:filter(fun (X) -> X /= {all_users, true}
-					    end,
-					    GroupOpts);
+			       [V1
+				|| V1 <- GroupOpts,
+				   remove_user_from_group_1(V1)];
 			   <<"@online@">> ->
-			       lists:filter(fun (X) -> X /= {online_users, true}
-					    end,
-					    GroupOpts)
+			       [V2
+				|| V2 <- GroupOpts,
+				   remove_user_from_group_2(V2)]
 			 end,
 	  mod_shared_roster:set_group_opts(Host, Group,
 					   NewGroupOpts);
@@ -650,6 +659,11 @@ remove_user_from_group(Host, US, Group) ->
 	  Result
     end.
 
+remove_user_from_group_1(X) -> X /= {all_users, true}.
+
+remove_user_from_group_2(X) ->
+    X /= {online_users, true}.
+
 push_members_to_user(LUser, LServer, Group, Host,
 		     Subscription) ->
     GroupsOpts = groups_with_opts(LServer),
@@ -727,14 +741,15 @@ push_user_to_group(LUser, LServer, Group, Host,
 %% Get list of groups to which this group is displayed
 displayed_to_groups(GroupName, LServer) ->
     GroupsOpts = groups_with_opts(LServer),
-    Gs = lists:filter(fun ({_Group, Opts}) ->
-			      lists:member(GroupName,
-					   proplists:get_value(displayed_groups,
-							       Opts, []))
-		      end,
-		      GroupsOpts),
+    Gs = [V1
+	  || V1 <- GroupsOpts,
+	     displayed_to_groups_1(V1, GroupName)],
     [Name || {Name, _} <- Gs].
 
+displayed_to_groups_1({_Group, Opts}, GroupName) ->
+    lists:member(GroupName,
+		 proplists:get_value(displayed_groups, Opts, [])).
+
 push_item(User, Server, Item) ->
     mod_roster:push_item(jid:make(User, Server),
 			 Item#roster{subscription = none}, Item).
@@ -806,17 +821,8 @@ list_shared_roster_groups(Host, Query, Lang) ->
     SRGroups = mod_shared_roster:list_groups(Host),
     FGroups = (?XAE(<<"table">>, [],
 		    [?XE(<<"tbody">>,
-			 (lists:map(fun (Group) ->
-					    ?XE(<<"tr">>,
-						[?XE(<<"td">>,
-						     [?INPUT(<<"checkbox">>,
-							     <<"selected">>,
-							     Group)]),
-						 ?XE(<<"td">>,
-						     [?AC(<<Group/binary, "/">>,
-							  Group)])])
-				    end,
-				    lists:sort(SRGroups))
+			 ([list_shared_roster_groups_1(V1)
+			   || V1 <- lists:sort(SRGroups)]
 			    ++
 			    [?XE(<<"tr">>,
 				 [?X(<<"td">>),
@@ -841,6 +847,12 @@ list_shared_roster_groups(Host, Query, Lang) ->
 	       ?INPUTT(<<"submit">>, <<"delete">>,
 		       <<"Delete Selected">>)])].
 
+list_shared_roster_groups_1(Group) ->
+    ?XE(<<"tr">>,
+	[?XE(<<"td">>,
+	     [?INPUT(<<"checkbox">>, <<"selected">>, Group)]),
+	 ?XE(<<"td">>, [?AC(<<Group/binary, "/">>, Group)])]).
+
 list_sr_groups_parse_query(Host, Query) ->
     case lists:keysearch(<<"addnew">>, 1, Query) of
       {value, _} -> list_sr_groups_parse_addnew(Host, Query);
@@ -1054,15 +1066,15 @@ displayed_groups_update(Members, DisplayedGroups,
 		  Members).
 
 opts_to_binary(Opts) ->
-    lists:map(fun ({name, Name}) ->
-		      {name, iolist_to_binary(Name)};
-		  ({description, Desc}) ->
-		      {description, iolist_to_binary(Desc)};
-		  ({displayed_groups, Gs}) ->
-		      {displayed_groups, [iolist_to_binary(G) || G <- Gs]};
-		  (Opt) -> Opt
-	      end,
-	      Opts).
+    [opts_to_binary_1(V1) || V1 <- Opts].
+
+opts_to_binary_1({name, Name}) ->
+    {name, iolist_to_binary(Name)};
+opts_to_binary_1({description, Desc}) ->
+    {description, iolist_to_binary(Desc)};
+opts_to_binary_1({displayed_groups, Gs}) ->
+    {displayed_groups, [iolist_to_binary(G) || G <- Gs]};
+opts_to_binary_1(Opt) -> Opt.
 
 export(LServer) ->
     Mod = gen_mod:db_mod(LServer, ?MODULE),
diff --git a/src/mod_shared_roster_ldap.erl b/src/mod_shared_roster_ldap.erl
index f4e22be..16d631f 100644
--- a/src/mod_shared_roster_ldap.erl
+++ b/src/mod_shared_roster_ldap.erl
@@ -546,29 +546,32 @@ cache_opts(_Host, Opts) ->
      {life_time, LifeTime}].
 
 transform_module_options(Opts) ->
-    lists:map(fun ({ldap_group_cache_size, I}) ->
-		      ?WARNING_MSG("Option 'ldap_group_cache_size' is deprecated, "
-				   "use 'cache_size' instead",
-				   []),
-		      {cache_size, I};
-		  ({ldap_user_cache_size, I}) ->
-		      ?WARNING_MSG("Option 'ldap_user_cache_size' is deprecated, "
-				   "use 'cache_size' instead",
-				   []),
-		      {cache_size, I};
-		  ({ldap_group_cache_validity, Secs}) ->
-		      ?WARNING_MSG("Option 'ldap_group_cache_validity' is "
-				   "deprecated, use 'cache_life_time' instead",
-				   []),
-		      {cache_life_time, Secs};
-		  ({ldap_user_cache_validity, Secs}) ->
-		      ?WARNING_MSG("Option 'ldap_user_cache_validity' is "
-				   "deprecated, use 'cache_life_time' instead",
-				   []),
-		      {cache_life_time, Secs};
-		  (Opt) -> Opt
-	      end,
-	      Opts).
+    [transform_module_options_1(V1) || V1 <- Opts].
+
+transform_module_options_1({ldap_group_cache_size,
+			    I}) ->
+    ?WARNING_MSG("Option 'ldap_group_cache_size' is deprecated, "
+		 "use 'cache_size' instead",
+		 []),
+    {cache_size, I};
+transform_module_options_1({ldap_user_cache_size, I}) ->
+    ?WARNING_MSG("Option 'ldap_user_cache_size' is deprecated, "
+		 "use 'cache_size' instead",
+		 []),
+    {cache_size, I};
+transform_module_options_1({ldap_group_cache_validity,
+			    Secs}) ->
+    ?WARNING_MSG("Option 'ldap_group_cache_validity' is "
+		 "deprecated, use 'cache_life_time' instead",
+		 []),
+    {cache_life_time, Secs};
+transform_module_options_1({ldap_user_cache_validity,
+			    Secs}) ->
+    ?WARNING_MSG("Option 'ldap_user_cache_validity' is "
+		 "deprecated, use 'cache_life_time' instead",
+		 []),
+    {cache_life_time, Secs};
+transform_module_options_1(Opt) -> Opt.
 
 mod_opt_type(ldap_auth_check) ->
     fun (on) -> true;
@@ -627,10 +630,11 @@ mod_options(Host) ->
      {cache_size, ejabberd_config:cache_size(Host)},
      {cache_missed, ejabberd_config:cache_missed(Host)},
      {cache_life_time, ejabberd_config:cache_life_time(Host)}
-     | lists:map(fun ({Opt, Default}) ->
-			 {Opt, ejabberd_config:get_option({Opt, Host}, Default)}
-		 end,
-		 eldap_utils:options(Host))].
+     | [mod_options_1(V1, Host)
+	|| V1 <- eldap_utils:options(Host)]].
+
+mod_options_1({Opt, Default}, Host) ->
+    {Opt, ejabberd_config:get_option({Opt, Host}, Default)}.
 
 opt_type(O)
     when O == ldap_rfilter;
diff --git a/src/mod_shared_roster_mnesia.erl b/src/mod_shared_roster_mnesia.erl
index 69d8225..ccfd447 100644
--- a/src/mod_shared_roster_mnesia.erl
+++ b/src/mod_shared_roster_mnesia.erl
@@ -66,7 +66,9 @@ groups_with_opts(Host) ->
 			     [{#sr_group{group_host = {'$1', Host}, opts = '$2',
 					 _ = '_'},
 			       [], [['$1', '$2']]}]),
-    lists:map(fun ([G, O]) -> {G, O} end, Gs).
+    [groups_with_opts_1(V1) || V1 <- Gs].
+
+groups_with_opts_1([G, O]) -> {G, O}.
 
 create_group(Host, Group, Opts) ->
     R = #sr_group{group_host = {Group, Host}, opts = Opts},
diff --git a/src/mod_shared_roster_sql.erl b/src/mod_shared_roster_sql.erl
index 911bc09..7d46409 100644
--- a/src/mod_shared_roster_sql.erl
+++ b/src/mod_shared_roster_sql.erl
@@ -126,13 +126,13 @@ get_group_explicit_users(Host, Group) ->
 					   ")s and %(Host)H"))
 	of
       {selected, Rs} ->
-	  lists:map(fun ({JID}) ->
-			    {U, S, _} = jid:tolower(jid:decode(JID)), {U, S}
-		    end,
-		    Rs);
+	  [get_group_explicit_users_1(V1) || V1 <- Rs];
       _ -> []
     end.
 
+get_group_explicit_users_1({JID}) ->
+    {U, S, _} = jid:tolower(jid:decode(JID)), {U, S}.
+
 get_user_displayed_groups(LUser, LServer, GroupsOpts) ->
     SJID = make_jid_s(LUser, LServer),
     case catch ejabberd_sql:sql_query(LServer,
diff --git a/src/mod_sip.erl b/src/mod_sip.erl
index 7ebd182..877a63e 100644
--- a/src/mod_sip.erl
+++ b/src/mod_sip.erl
@@ -280,13 +280,9 @@ check_auth(#sip{method = Method, hdrs = Hdrs,
 	esip:get_hdr(Issuer, Hdrs),
     LUser = jid:nodeprep(User),
     LServer = jid:nameprep(Host),
-    case lists:filter(fun ({_, Params}) ->
-			      Username = esip:get_param(<<"username">>, Params),
-			      Realm = esip:get_param(<<"realm">>, Params),
-			      (LUser == esip:unquote(Username)) and
-				(LServer == esip:unquote(Realm))
-		      end,
-		      esip:get_hdrs(AuthHdr, Hdrs))
+    case [V1
+	  || V1 <- esip:get_hdrs(AuthHdr, Hdrs),
+	     check_auth_1(V1, LServer, LUser)]
 	of
       [Auth | _] ->
 	  case ejabberd_auth:get_password_s(LUser, LServer) of
@@ -302,6 +298,12 @@ check_auth(#sip{method = Method, hdrs = Hdrs,
       [] -> false
     end.
 
+check_auth_1({_, Params}, LServer, LUser) ->
+    Username = esip:get_param(<<"username">>, Params),
+    Realm = esip:get_param(<<"realm">>, Params),
+    (LUser == esip:unquote(Username)) and
+      (LServer == esip:unquote(Realm)).
+
 allow() -> [<<"OPTIONS">>, <<"REGISTER">>].
 
 supported() -> [<<"path">>, <<"outbound">>].
@@ -346,29 +348,24 @@ mod_opt_type(record_route) ->
 	    #uri{} = esip:decode_uri(S)
     end;
 mod_opt_type(routes) ->
-    fun (L) ->
-	    lists:map(fun (IOList) ->
-			      S = iolist_to_binary(IOList),
-			      #uri{} = esip:decode_uri(S)
-		      end,
-		      L)
-    end;
+    fun (L) -> [mod_opt_type_1(V1) || V1 <- L] end;
 mod_opt_type(via) ->
-    fun (L) ->
-	    lists:map(fun (Opts) ->
-			      Type = proplists:get_value(type, Opts),
-			      Host = proplists:get_value(host, Opts),
-			      Port = proplists:get_value(port, Opts),
-			      true = (Type == tcp) or (Type == tls) or
-				       (Type == udp),
-			      true = is_binary(Host) and (Host /= <<"">>),
-			      true = is_integer(Port) and (Port > 0) and
-				       (Port < 65536)
-				       or (Port == undefined),
-			      {Type, {Host, Port}}
-		      end,
-		      L)
-    end.
+    fun (L) -> [mod_opt_type_2(V2) || V2 <- L] end.
+
+mod_opt_type_1(IOList) ->
+    S = iolist_to_binary(IOList),
+    #uri{} = esip:decode_uri(S).
+
+mod_opt_type_2(Opts) ->
+    Type = proplists:get_value(type, Opts),
+    Host = proplists:get_value(host, Opts),
+    Port = proplists:get_value(port, Opts),
+    true = (Type == tcp) or (Type == tls) or (Type == udp),
+    true = is_binary(Host) and (Host /= <<"">>),
+    true = is_integer(Port) and (Port > 0) and
+	     (Port < 65536)
+	     or (Port == undefined),
+    {Type, {Host, Port}}.
 
 mod_options(Host) ->
     Route = <<"sip:", Host/binary, ";lr">>,
diff --git a/src/mod_sip_proxy.erl b/src/mod_sip_proxy.erl
index d6dc83f..f719486 100644
--- a/src/mod_sip_proxy.erl
+++ b/src/mod_sip_proxy.erl
@@ -363,10 +363,8 @@ collect_response(Resp,
 choose_best_response(#state{responses = Responses} =
 			 State) ->
     SortedResponses = lists:keysort(#sip.status, Responses),
-    case lists:filter(fun (#sip{status = Status}) ->
-			      Status >= 600
-		      end,
-		      SortedResponses)
+    case [V1
+	  || V1 <- SortedResponses, choose_best_response_1(V1)]
 	of
       [Resp | _] -> esip:reply(State#state.orig_trid, Resp);
       [] ->
@@ -376,6 +374,9 @@ choose_best_response(#state{responses = Responses} =
 	  end
     end.
 
+choose_best_response_1(#sip{status = Status}) ->
+    Status >= 600.
+
 %% Just compare host part only.
 cmp_uri(#uri{host = H1}, #uri{host = H2}) ->
     jid:nameprep(H1) == jid:nameprep(H2).
@@ -388,16 +389,11 @@ prepare_request(LServer, #sip{hdrs = Hdrs} = Req) ->
     ConfiguredRoutes = get_configured_routes(LServer),
     Hdrs1 = lists:flatmap(fun ({Hdr, HdrList})
 				  when Hdr == route; Hdr == 'record-route' ->
-				  case lists:filter(fun ({_, URI, _}) ->
-							    not
-							      cmp_uri(URI,
-								      ConfiguredRRoute)
-							      and
-							      not
-								is_my_route(URI,
-									    ConfiguredRoutes)
-						    end,
-						    HdrList)
+				  case [V1
+					|| V1 <- HdrList,
+					   prepare_request_1(V1,
+							     ConfiguredRRoute,
+							     ConfiguredRoutes)]
 				      of
 				    [] -> [];
 				    HdrList1 -> [{Hdr, HdrList1}]
@@ -407,17 +403,21 @@ prepare_request(LServer, #sip{hdrs = Hdrs} = Req) ->
 			  Hdrs),
     MF = esip:get_hdr('max-forwards', Hdrs1),
     Hdrs2 = esip:set_hdr('max-forwards', MF - 1, Hdrs1),
-    Hdrs3 = lists:filter(fun ({'proxy-authorization',
-			       {_, Params}}) ->
-				 Realm =
-				     esip:unquote(esip:get_param(<<"realm">>,
-								 Params)),
-				 not mod_sip:is_my_host(jid:nameprep(Realm));
-			     (_) -> true
-			 end,
-			 Hdrs2),
+    Hdrs3 = [V2 || V2 <- Hdrs2, prepare_request_1(V2)],
     Req#sip{hdrs = Hdrs3}.
 
+prepare_request_1({_, URI, _}, ConfiguredRRoute,
+		  ConfiguredRoutes) ->
+    not cmp_uri(URI, ConfiguredRRoute) and
+      not is_my_route(URI, ConfiguredRoutes).
+
+prepare_request_1({'proxy-authorization',
+		   {_, Params}}) ->
+    Realm = esip:unquote(esip:get_param(<<"realm">>,
+					Params)),
+    not mod_sip:is_my_host(jid:nameprep(Realm));
+prepare_request_1(_) -> true.
+
 safe_nodeprep(S) ->
     case jid:nodeprep(S) of
       error -> S;
diff --git a/src/mod_stats.erl b/src/mod_stats.erl
index 6e87da7..f5dc4a8 100644
--- a/src/mod_stats.erl
+++ b/src/mod_stats.erl
@@ -76,9 +76,7 @@ get_local_stats(_Server, [], [], _Lang) ->
       ?STAT(<<"users/all-hosts/total">>)]};
 get_local_stats(Server, [], Names, _Lang) ->
     {result,
-     lists:map(fun (Name) -> get_local_stat(Server, [], Name)
-	       end,
-	       Names)};
+     [get_local_stats_1(V1, Server) || V1 <- Names]};
 get_local_stats(_Server, [<<"running nodes">>, _], [],
 		_Lang) ->
     {result,
@@ -95,14 +93,18 @@ get_local_stats(_Server, [<<"running nodes">>, ENode],
 	  Txt = <<"No running node found">>,
 	  {error, xmpp:err_item_not_found(Txt, Lang)};
       Node ->
-	  {result,
-	   lists:map(fun (Name) -> get_node_stat(Node, Name) end,
-		     Names)}
+	  {result, [get_local_stats_2(V2, Node) || V2 <- Names]}
     end;
 get_local_stats(_Server, _, _, Lang) ->
     Txt = <<"No statistics found for this item">>,
     {error, xmpp:err_feature_not_implemented(Txt, Lang)}.
 
+get_local_stats_1(Name, Server) ->
+    get_local_stat(Server, [], Name).
+
+get_local_stats_2(Name, Node) ->
+    get_node_stat(Node, Name).
+
 -define(STATVAL(Val, Unit),
 	#stat{name = Name, units = Unit, value = Val}).
 
diff --git a/src/mod_vcard.erl b/src/mod_vcard.erl
index 1cf7b8b..c96b0ba 100644
--- a/src/mod_vcard.erl
+++ b/src/mod_vcard.erl
@@ -541,8 +541,10 @@ search_result(Lang, JID, ServerHost, XFields) ->
 		 (jid:encode(JID))/binary>>,
 	   reported = Reported,
 	   items =
-	       lists:map(fun (Item) -> item_to_field(Item) end,
-			 search(ServerHost, XFields))}.
+	       [search_result_1(V1)
+		|| V1 <- search(ServerHost, XFields)]}.
+
+search_result_1(Item) -> item_to_field(Item).
 
 - spec ( { { item_to_field , 1 } , [ { type , 457 , 'fun' , [ { type , 457 , product , [ { type , 457 , list , [ { type , 457 , tuple , [ { type , 457 , binary , [ ] } , { type , 457 , binary , [ ] } ] } ] } ] } , { type , 457 , list , [ { type , 457 , xdata_field , [ ] } ] } ] } ] } ) .
 
diff --git a/src/mod_vcard_ldap.erl b/src/mod_vcard_ldap.erl
index 92eee76..0d6dd00 100644
--- a/src/mod_vcard_ldap.erl
+++ b/src/mod_vcard_ldap.erl
@@ -129,10 +129,7 @@ search_items(Entries, State) ->
     SearchReported = State#state.search_reported,
     VCardMap = State#state.vcard_map,
     UIDs = State#state.uids,
-    Attributes = lists:map(fun (E) ->
-				   #eldap_entry{attributes = Attrs} = E, Attrs
-			   end,
-			   Entries),
+    Attributes = [search_items_1(V1) || V1 <- Entries],
     lists:filtermap(fun (Attrs) ->
 			    case eldap_utils:find_ldap_attrs(UIDs, Attrs) of
 			      {U, UIDAttrFormat} ->
@@ -144,16 +141,12 @@ search_items(Entries, State) ->
 								       LServer)
 					    of
 					  true ->
-					      RFields = lists:map(fun ({_,
-									VCardName}) ->
-									  {VCardName,
-									   map_vcard_attr(VCardName,
-											  Attrs,
-											  VCardMap,
-											  {Username,
-											   ejabberd_config:get_myname()})}
-								  end,
-								  SearchReported),
+					      RFields = [search_items_1(V2,
+									Attrs,
+									Username,
+									VCardMap)
+							 || V2
+								<- SearchReported],
 					      J = <<Username/binary, $@,
 						    LServer/binary>>,
 					      {true,
@@ -167,6 +160,15 @@ search_items(Entries, State) ->
 		    end,
 		    Attributes).
 
+search_items_1(E) ->
+    #eldap_entry{attributes = Attrs} = E, Attrs.
+
+search_items_1({_, VCardName}, Attrs, Username,
+	       VCardMap) ->
+    {VCardName,
+     map_vcard_attr(VCardName, Attrs, VCardMap,
+		    {Username, ejabberd_config:get_myname()})}.
+
 remove_user(_User, _Server) ->
     {atomic, not_implemented}.
 
@@ -221,15 +223,17 @@ find_ldap_user(User, State) ->
     end.
 
 ldap_attributes_to_vcard(Attributes, VCardMap, UD) ->
-    Attrs = lists:map(fun ({VCardName, _, _}) ->
-			      {stringprep:tolower(VCardName),
-			       map_vcard_attr(VCardName, Attributes, VCardMap,
-					      UD)}
-		      end,
-		      VCardMap),
+    Attrs = [ldap_attributes_to_vcard_1(V1, Attributes, UD,
+					VCardMap)
+	     || V1 <- VCardMap],
     lists:foldl(fun ldap_attribute_to_vcard/2,
 		#vcard_temp{}, Attrs).
 
+ldap_attributes_to_vcard_1({VCardName, _, _},
+			   Attributes, UD, VCardMap) ->
+    {stringprep:tolower(VCardName),
+     map_vcard_attr(VCardName, Attributes, VCardMap, UD)}.
+
 - spec ( { { ldap_attribute_to_vcard , 2 } , [ { type , 245 , 'fun' , [ { type , 245 , product , [ { type , 245 , tuple , [ { type , 245 , binary , [ ] } , { type , 245 , binary , [ ] } ] } , { type , 245 , vcard_temp , [ ] } ] } , { type , 245 , vcard_temp , [ ] } ] } ] } ) .
 
 
@@ -287,11 +291,8 @@ ldap_attribute_to_vcard({Attr, Value}, V) ->
     end.
 
 map_vcard_attr(VCardName, Attributes, Pattern, UD) ->
-    Res = lists:filter(fun ({Name, _, _}) ->
-			       eldap_utils:case_insensitive_match(Name,
-								  VCardName)
-		       end,
-		       Pattern),
+    Res = [V1
+	   || V1 <- Pattern, map_vcard_attr_1(V1, VCardName)],
     case Res of
       [{_, Str, Attrs}] ->
 	  process_pattern(Str, UD,
@@ -300,6 +301,9 @@ map_vcard_attr(VCardName, Attributes, Pattern, UD) ->
       _ -> <<"">>
     end.
 
+map_vcard_attr_1({Name, _, _}, VCardName) ->
+    eldap_utils:case_insensitive_match(Name, VCardName).
+
 process_pattern(Str, {User, Domain}, AttrValues) ->
     eldap_filter:do_sub(Str,
 			[{<<"%u">>, User}, {<<"%d">>, Domain}] ++
@@ -424,20 +428,19 @@ mod_opt_type(ldap_search_reported) ->
 	     || {S, P} <- Ls]
     end;
 mod_opt_type(ldap_vcard_map) ->
-    fun (Ls) ->
-	    lists:map(fun ({S, [{P, L}]}) ->
-			      {iolist_to_binary(S), iolist_to_binary(P),
-			       [iolist_to_binary(E) || E <- L]}
-		      end,
-		      Ls)
-    end;
+    fun (Ls) -> [mod_opt_type_1(V1) || V1 <- Ls] end;
 mod_opt_type(Opt) -> eldap_utils:opt_type(Opt).
 
+mod_opt_type_1({S, [{P, L}]}) ->
+    {iolist_to_binary(S), iolist_to_binary(P),
+     [iolist_to_binary(E) || E <- L]}.
+
 mod_options(Host) ->
     [{ldap_search_fields, default_search_fields()},
      {ldap_search_reported, default_search_reported()},
      {ldap_vcard_map, default_vcard_map()}
-     | lists:map(fun ({Opt, Default}) ->
-			 {Opt, ejabberd_config:get_option({Opt, Host}, Default)}
-		 end,
-		 eldap_utils:options(Host))].
+     | [mod_options_1(V1, Host)
+	|| V1 <- eldap_utils:options(Host)]].
+
+mod_options_1({Opt, Default}, Host) ->
+    {Opt, ejabberd_config:get_option({Opt, Host}, Default)}.
diff --git a/src/mod_vcard_mnesia.erl b/src/mod_vcard_mnesia.erl
index de7716d..3d64614 100644
--- a/src/mod_vcard_mnesia.erl
+++ b/src/mod_vcard_mnesia.erl
@@ -67,7 +67,9 @@ is_search_supported(_ServerHost) -> true.
 get_vcard(LUser, LServer) ->
     US = {LUser, LServer},
     Rs = mnesia:dirty_read(vcard, US),
-    {ok, lists:map(fun (R) -> R#vcard.vcard end, Rs)}.
+    {ok, [get_vcard_1(V1) || V1 <- Rs]}.
+
+get_vcard_1(R) -> R#vcard.vcard.
 
 set_vcard(LUser, LServer, VCARD, VCardSearch) ->
     US = {LUser, LServer},
@@ -88,7 +90,7 @@ search(LServer, Data, AllowReturnAll, MaxMatch) ->
 	       of
 	     {'EXIT', Reason} -> ?ERROR_MSG("~p", [Reason]), [];
 	     Rs ->
-		 Fields = lists:map(fun record_to_item/1, Rs),
+		 Fields = [record_to_item(V1) || V1 <- Rs],
 		 case MaxMatch of
 		   infinity -> Fields;
 		   Val -> lists:sublist(Fields, Val)
@@ -172,13 +174,13 @@ transform(#vcard{us = {U, S}, vcard = El} = R) ->
 	    vcard = fxml:to_xmlel(El)};
 transform(#vcard_search{} = VS) ->
     [vcard_search | L] = tuple_to_list(VS),
-    NewL = lists:map(fun ({U, S}) ->
-			     {iolist_to_binary(U), iolist_to_binary(S)};
-			 (Str) -> iolist_to_binary(Str)
-		     end,
-		     L),
+    NewL = [transform_1(V1) || V1 <- L],
     list_to_tuple([vcard_search | NewL]).
 
+transform_1({U, S}) ->
+    {iolist_to_binary(U), iolist_to_binary(S)};
+transform_1(Str) -> iolist_to_binary(Str).
+
 %%%===================================================================
 %%% Internal functions
 %%%===================================================================
@@ -248,12 +250,12 @@ find_my_host([_ | Tail] = Parts, Hosts) ->
     end.
 
 parts_to_string(Parts) ->
-    str:strip(list_to_binary(lists:map(fun (S) ->
-					       <<S/binary, $.>>
-				       end,
-				       Parts)),
+    str:strip(list_to_binary([parts_to_string_1(V1)
+			      || V1 <- Parts]),
 	      right, $.).
 
+parts_to_string_1(S) -> <<S/binary, $.>>.
+
 - spec ( { { record_to_item , 1 } , [ { type , 252 , 'fun' , [ { type , 252 , product , [ { type , 252 , record , [ { atom , 252 , vcard_search } ] } ] } , { type , 252 , list , [ { type , 252 , tuple , [ { type , 252 , binary , [ ] } , { type , 252 , binary , [ ] } ] } ] } ] } ] } ) .
 
 
diff --git a/src/node_flat.erl b/src/node_flat.erl
index 6a8f1c2..ef69e5f 100644
--- a/src/node_flat.erl
+++ b/src/node_flat.erl
@@ -127,25 +127,24 @@ create_node(Nidx, Owner) ->
 delete_node(Nodes) ->
     Tr = fun (#pubsub_state{stateid = {J, _},
 			    subscriptions = Ss}) ->
-		 lists:map(fun (S) -> {J, S} end, Ss)
+		 [delete_node_1(V1, J) || V1 <- Ss]
 	 end,
-    Reply = lists:map(fun (#pubsub_node{id = Nidx} =
-			       PubsubNode) ->
-			      {result, States} = get_states(Nidx),
-			      lists:foreach(fun (State) ->
-						    del_items(Nidx,
-							      State#pubsub_state.items),
-						    del_state(State#pubsub_state{items
-										     =
-										     []})
-					    end,
-					    States),
-			      del_orphan_items(Nidx),
-			      {PubsubNode, lists:flatmap(Tr, States)}
-		      end,
-		      Nodes),
+    Reply = [delete_node_2(V2, Tr) || V2 <- Nodes],
     {result, {default, broadcast, Reply}}.
 
+delete_node_1(S, J) -> {J, S}.
+
+delete_node_2(#pubsub_node{id = Nidx} = PubsubNode,
+	      Tr) ->
+    {result, States} = get_states(Nidx),
+    lists:foreach(fun (State) ->
+			  del_items(Nidx, State#pubsub_state.items),
+			  del_state(State#pubsub_state{items = []})
+		  end,
+		  States),
+    del_orphan_items(Nidx),
+    {PubsubNode, lists:flatmap(Tr, States)}.
+
 %% @doc <p>Accepts or rejects subcription requests on a PubSub node.</p>
 %% <p>The mechanism works as follow:
 %% <ul>
@@ -268,11 +267,9 @@ unsubscribe_node(Nidx, Sender, Subscriber, SubId) ->
 		 GenKey -> GenState;
 		 _ -> get_state(Nidx, SubKey)
 	       end,
-    Subscriptions = lists:filter(fun ({_Sub, _SubId}) ->
-					 true;
-				     (_SubId) -> false
-				 end,
-				 SubState#pubsub_state.subscriptions),
+    Subscriptions = [V1
+		     || V1 <- SubState#pubsub_state.subscriptions,
+			unsubscribe_node_1(V1)],
     SubIdExists = case SubId of
 		    <<>> -> false;
 		    Binary when is_binary(Binary) -> true;
@@ -322,6 +319,9 @@ unsubscribe_node(Nidx, Sender, Subscriber, SubId) ->
 				     mod_pubsub:err_subid_required())}
     end.
 
+unsubscribe_node_1({_Sub, _SubId}) -> true;
+unsubscribe_node_1(_SubId) -> false.
+
 delete_subscriptions(SubState, Subscriptions) ->
     NewSubs = lists:foldl(fun ({Subscription, SubId},
 			       Acc) ->
diff --git a/src/node_flat_sql.erl b/src/node_flat_sql.erl
index 6e1a458..5652516 100644
--- a/src/node_flat_sql.erl
+++ b/src/node_flat_sql.erl
@@ -91,23 +91,21 @@ create_node(Nidx, Owner) ->
     {result, {default, broadcast}}.
 
 delete_node(Nodes) ->
-    Reply = lists:map(fun (#pubsub_node{id = Nidx} =
-			       PubsubNode) ->
-			      Subscriptions = case
-						ejabberd_sql:sql_query_t(?SQL("select @(jid)s, @(subscriptions)s from "
-									      "pubsub_state where nodeid=%(Nidx)d"))
-						  of
-						{selected, RItems} ->
-						    [{decode_jid(SJID),
-						      decode_subscriptions(Subs)}
-						     || {SJID, Subs} <- RItems];
-						_ -> []
-					      end,
-			      {PubsubNode, Subscriptions}
-		      end,
-		      Nodes),
+    Reply = [delete_node_1(V1) || V1 <- Nodes],
     {result, {default, broadcast, Reply}}.
 
+delete_node_1(#pubsub_node{id = Nidx} = PubsubNode) ->
+    Subscriptions = case
+		      ejabberd_sql:sql_query_t(?SQL("select @(jid)s, @(subscriptions)s from "
+						    "pubsub_state where nodeid=%(Nidx)d"))
+			of
+		      {selected, RItems} ->
+			  [{decode_jid(SJID), decode_subscriptions(Subs)}
+			   || {SJID, Subs} <- RItems];
+		      _ -> []
+		    end,
+    {PubsubNode, Subscriptions}.
+
 subscribe_node(Nidx, Sender, Subscriber, AccessModel,
 	       SendLast, PresenceSubscription, RosterGroup,
 	       _Options) ->
@@ -632,21 +630,17 @@ get_states(Nidx) ->
 				    ""))
 	of
       {selected, RItems} ->
-	  {result,
-	   lists:map(fun ({SJID, Aff, Subs}) ->
-			     JID = decode_jid(SJID),
-			     #pubsub_state{stateid = {JID, Nidx},
-					   nodeidx = Nidx,
-					   items = itemids(Nidx, JID),
-					   affiliation =
-					       decode_affiliation(Aff),
-					   subscriptions =
-					       decode_subscriptions(Subs)}
-		     end,
-		     RItems)};
+	  {result, [get_states_1(V1, Nidx) || V1 <- RItems]};
       _ -> {result, []}
     end.
 
+get_states_1({SJID, Aff, Subs}, Nidx) ->
+    JID = decode_jid(SJID),
+    #pubsub_state{stateid = {JID, Nidx}, nodeidx = Nidx,
+		  items = itemids(Nidx, JID),
+		  affiliation = decode_affiliation(Aff),
+		  subscriptions = decode_subscriptions(Subs)}.
+
 get_state(Nidx, JID) ->
     State = get_state_without_itemids(Nidx, JID),
     {SJID, _} = State#pubsub_state.stateid,
diff --git a/src/nodetree_tree_sql.erl b/src/nodetree_tree_sql.erl
index 848d3c5..7299f43 100644
--- a/src/nodetree_tree_sql.erl
+++ b/src/nodetree_tree_sql.erl
@@ -269,13 +269,14 @@ create_node(Host, Node, Type, Owner, Options,
     end.
 
 delete_node(Host, Node) ->
-    lists:map(fun (Rec) ->
-		      Nidx = Rec#pubsub_node.id,
-		      catch
-			ejabberd_sql:sql_query_t(?SQL("delete from pubsub_node where nodeid=%(Nidx)d")),
-		      Rec
-	      end,
-	      get_subnodes_tree(Host, Node)).
+    [delete_node_1(V1)
+     || V1 <- get_subnodes_tree(Host, Node)].
+
+delete_node_1(Rec) ->
+    Nidx = Rec#pubsub_node.id,
+    catch
+      ejabberd_sql:sql_query_t(?SQL("delete from pubsub_node where nodeid=%(Nidx)d")),
+    Rec.
 
 %% helpers
 raw_to_node(Host, [Node, Parent, Type, Nidx]) ->
@@ -287,16 +288,7 @@ raw_to_node(Host, {Node, Parent, Type, Nidx}) ->
 						   "ion where nodeid=%(Nidx)d"))
 		  of
 		{selected, ROptions} ->
-		    DbOpts = lists:map(fun ({Key, Value}) ->
-					       RKey = misc:binary_to_atom(Key),
-					       Tokens = element(2,
-								erl_scan:string(binary_to_list(<<Value/binary,
-												 ".">>))),
-					       RValue = element(2,
-								erl_parse:parse_term(Tokens)),
-					       {RKey, RValue}
-				       end,
-				       ROptions),
+		    DbOpts = [raw_to_node_1(V1) || V1 <- ROptions],
 		    Module = misc:binary_to_atom(<<"node_", Type/binary,
 						   "_sql">>),
 		    StdOpts = Module:options(),
@@ -314,6 +306,13 @@ raw_to_node(Host, {Node, Parent, Type, Nidx}) ->
     #pubsub_node{nodeid = {Host, Node}, id = Nidx,
 		 parents = Parents, type = Type, options = Options}.
 
+raw_to_node_1({Key, Value}) ->
+    RKey = misc:binary_to_atom(Key),
+    Tokens = element(2,
+		     erl_scan:string(binary_to_list(<<Value/binary, ".">>))),
+    RValue = element(2, erl_parse:parse_term(Tokens)),
+    {RKey, RValue}.
+
 nodeidx(Host, Node) ->
     H = node_flat_sql:encode_host(Host),
     case catch
diff --git a/src/prosody2ejabberd.erl b/src/prosody2ejabberd.erl
index 5f97ef9..3b03c44 100644
--- a/src/prosody2ejabberd.erl
+++ b/src/prosody2ejabberd.erl
@@ -241,9 +241,8 @@ convert_data(Host, "privacy", User, [Data]) ->
 					      Items =
 						  proplists:get_value(<<"items">>,
 								      Vals, []),
-					      case
-						lists:map(fun convert_privacy_item/1,
-							  Items)
+					      case [convert_privacy_item(V1)
+						    || V1 <- Items]
 						  of
 						[] -> [];
 						ListItems -> [{Name, ListItems}]
@@ -533,11 +532,7 @@ el_to_offline_msg(LUser, LServer,
     try TS =
 	    xmpp_util:decode_timestamp(fxml:get_attr_s(<<"stamp">>,
 						       Attrs)),
-	Attrs1 = lists:filter(fun ({<<"stamp">>, _}) -> false;
-				  ({<<"stamp_legacy">>, _}) -> false;
-				  (_) -> true
-			      end,
-			      Attrs),
+	Attrs1 = [V1 || V1 <- Attrs, el_to_offline_msg_1(V1)],
 	El1 = El#xmlel{attrs = Attrs1},
 	case xmpp:decode(El1, ?NS_CLIENT, [ignore_els]) of
 	  #message{from = #jid{} = From, to = #jid{} = To} =
@@ -553,6 +548,10 @@ el_to_offline_msg(LUser, LServer,
       _:{xmpp_codec, _} -> []
     end.
 
+el_to_offline_msg_1({<<"stamp">>, _}) -> false;
+el_to_offline_msg_1({<<"stamp_legacy">>, _}) -> false;
+el_to_offline_msg_1(_) -> true.
+
 deserialize(L) -> deserialize(L, #xmlel{}, []).
 
 deserialize([{<<"attr">>, Attrs} | T], El, Acc) ->
diff --git a/src/pubsub_db_sql.erl b/src/pubsub_db_sql.erl
index 48c13fc..5e73ee8 100644
--- a/src/pubsub_db_sql.erl
+++ b/src/pubsub_db_sql.erl
@@ -54,8 +54,8 @@ read_subscription(SubID) ->
 	  {ok,
 	   #pubsub_subscription{subid = SubID,
 				options =
-				    lists:map(fun subscription_opt_from_sql/1,
-					      Options)}}
+				    [subscription_opt_from_sql(V1)
+				     || V1 <- Options]}}
     end.
 
 %% -spec delete_subscription(SubID :: string()) -> ok.
@@ -177,14 +177,7 @@ export(_Server) ->
 	       ?SQL("insert into pubsub_node(host,node,nodeid,pare"
 		    "nt,plugin) values (%(H)s, %(Node)s, "
 		    "%(Nidx)d, %(Parent)s, %(Type)s);")]
-		++
-		lists:map(fun ({Key, Value}) ->
-				  SKey = iolist_to_binary(atom_to_list(Key)),
-				  SValue = misc:term_to_expr(Value),
-				  ?SQL("insert into pubsub_node_option(nodeid,name,va"
-				       "l) values (%(Nidx)d, %(SKey)s, %(SValue)s);")
-			  end,
-			  Options);
+		++ [export_1(V1) || V1 <- Options];
 	  (_Host, _R) -> []
       end},
      {pubsub_state,
@@ -217,6 +210,12 @@ export(_Server) ->
 	  (_Host, _R) -> []
       end}].
 
+export_1({Key, Value}) ->
+    SKey = iolist_to_binary(atom_to_list(Key)),
+    SValue = misc:term_to_expr(Value),
+    ?SQL("insert into pubsub_node_option(nodeid,name,va"
+	 "l) values (%(Nidx)d, %(SKey)s, %(SValue)s);").
+
 encode_now({T1, T2, T3}) ->
     <<(misc:i2l(T1, 6))/binary, ":",
       (misc:i2l(T2, 6))/binary, ":",
diff --git a/src/win32_dns.erl b/src/win32_dns.erl
index 5146600..f13a317 100644
--- a/src/win32_dns.erl
+++ b/src/win32_dns.erl
@@ -40,8 +40,9 @@
 get_nameservers() ->
     {_, Config} = pick_config(),
     IPTs = get_value(["NameServer"], Config),
-    lists:filter(fun (IPTuple) -> is_good_ns(IPTuple) end,
-		 IPTs).
+    [V1 || V1 <- IPTs, get_nameservers_1(V1)].
+
+get_nameservers_1(IPTuple) -> is_good_ns(IPTuple).
 
 is_good_ns(Addr) ->
     element(1,
